<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JNI详解]]></title>
    <url>%2F2021%2F01%2F10%2FJNI%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述JNI，是Java Native Interface的缩写，中文为Java本地调用。通俗地说，JNI是一种技术，通过这种技术可以做到以下两点：· Java程序中的函数可以调用Native语言写的函数，Native一般指的是C/C++编写的函数。· Native程序中的函数可以调用Java层的函数，也就是在C/C++程序中可以调用Java的函数。 在平台无关的Java中，为什么要创建一个和Native相关的JNI技术呢？这岂不是破坏了Java的平台无关特性吗？本人觉得，JNI技术的推出可能是出于以下几个方面的考虑：· 承载Java世界的虚拟机是用Native语言写的，而虚拟机又运行在具体平台上，所以虚拟机本身无法做到平台无关。然而，有了JNI技术，就可以对Java层屏蔽具体的虚拟机实现上的差异了。这样，就能实现Java本身的平台无关特性。其实Java一直在使用JNI技术，只是我们平时较少用到罢了。· 早在Java语言诞生前，很多程序都是用Native语言写的，它们遍布在软件世界的各个角落。Java出世后，它受到了追捧，并迅速得到发展，但仍无法对软件世界彻底改朝换代，于是才有了折中的办法。既然已经有Native模块实现了相关功能，那么在Java中通过JNI技术直接使用它们就行了，免得落下重复制造轮子的坏名声。另外，在一些要求效率和速度的场合还是需要Native语言参与的。 在Android平台上，JNI就是一座将Native世界和Java世界间的天堑变成通途的桥，来看图1，它展示了Android平台上JNI所处的位置： 由上图可知，JNI将Java世界和Native世界紧密地联系在一起了。在Android平台上尽情使用Java开发的程序员们不要忘了，如果没有JNI的支持，我们将寸步难行！注意，JNI层的代码是用Native语言写的。俗话说，百闻不如一见，就来见识一下JNI技术吧。思维导图： 通过实例学习JNI初次接触JNI，感觉最神奇的就是，Java竟然能够调用Native的函数，可它是怎么做到的呢？网上有很多介绍JNI的资料。由于Android大量使用了JNI技术，本节就将通过源码中的一处实例，来学习相关的知识，并了解它是如何调用Native的函数的。这个例子，是和MediaScanner相关的。我们会单独详细分析它的工作原理，这里先看和JNI相关的部分，如图2-2所示：图2-2 MediaScanner和它的JNI将图2-2与图2-1结合来看，可以知道：· Java世界对应的是MediaScanner，而这个MediaScanner类有一些函数是需要由Native层实现的。· JNI层对应的是libmedia_jni.so。media_jni是JNI库的名字，其中，下划线前的“media”是Native层库的名字，这里就是libmedia库。下划线后的”jni“表示它是一个JNI库。注意，JNI库的名字可以随便取，不过Android平台基本上都采用“lib模块名_jni.so”的命名方式。· Native层对应的是libmedia.so，这个库完成了实际的功能。· MediaScanner将通过JNI库libmedia_jni.so和Native的libmedia.so交互。从上面的分析中还可知道：· JNI层必须实现为动态库的形式，这样Java虚拟机才能加载它并调用它的函数。 下面来看MediaScanner。 MediaScanner是Android平台中多媒体系统的重要组成部分，它的功能是扫描媒体文件，得到诸如歌曲时长、歌曲作者等媒体信息，并将它们存入到媒体数据库中，供其他应用程序使用。 Java层的MediaScanner分析来看MediaScanner（简称MS）的源码，这里将提取出和JNI有关的部分，其代码如下所示： [–&gt;MediaScanner.java]1234567891011121314151617181920212223public class MediaScanner&#123;static&#123; //static语句 /*①加载对应的JNI库，media_jni是JNI库的名字。实际加载动态库的时候会拓展成libmedia_jni.so，在Windows平台上将拓展为media_jni.dll。*/ System.loadLibrary(&quot;media_jni&quot;); native_init();//调用native_init函数 &#125;.......//非native函数public void scanDirectories(String[] directories, String volumeName)&#123; ......&#125; //②声明一个native函数。native为Java的关键字，表示它将由JNI层完成。private static native final void native_init(); ......private native void processFile(String path, String mimeType, MediaScannerClient client); ......&#125; 上面代码中列出了两个比较重要的要点： 加载JNI库 前面说过，如Java要调用Native函数，就必须通过一个位于JNI层的动态库才能做到。顾名思义，动态库就是运行时加载的库，那么是什么时候，在什么地方加载这个库呢？这个问题没有标准答案，原则上是在调用native函数前，任何时候、任何地方加载都可以。通行的做法是，在类的static语句中加载，通过调用System.loadLibrary方法就可以了。这一点，在上面的代码中也见到了，我们以后就按这种方法编写代码即可。另外，System.loadLibrary函数的参数是动态库的名字，即media_jni。系统会自动根据不同的平台拓展成真实的动态库文件名，例如在Linux系统上会拓展成libmedia_jni.so，而在Windows平台上则会拓展成media_jni.dll。解决了JNI库加载的问题，再来来看第二个关键点。 Java的native函数和总结 从上面代码中可以发现，native_init和processFile函数前都有Java的关键字native，它表示这两个函数将由JNI层来实现。Java层的分析到此结束。JNI技术也很照顾Java程序员，只要完成下面两项工作就可以使用JNI了，它们是：· 加载对应的JNI库。· 声明由关键字native修饰的函数。所以对于Java程序员来说，使用JNI技术真的是太容易了。不过JNI层可没这么轻松，下面来看MS的JNI层分析。 JNI层的MediaScanner分析MS的JNI层代码在android_media_MediaScanner.cpp中，如下所示：[–&gt;android_media_MediaScanner.cpp]123456789101112131415161718192021222324//①这个函数是native_init的JNI层实现。static void android_media_MediaScanner_native_init(JNIEnv *env)&#123; jclass clazz; clazz= env-&gt;FindClass(&quot;android/media/MediaScanner&quot;); ...... fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;,&quot;I&quot;);......return;&#125; //这个函数是processFile的JNI层实现。static void android_media_MediaScanner_processFile(JNIEnv*env, jobject thiz,jstring path, jstring mimeType, jobject client)&#123; MediaScanner* mp = (MediaScanner *)env-&gt;GetIntField(thiz, fields.context); ...... constchar *pathStr = env-&gt;GetStringUTFChars(path, NULL); ...... if(mimeType) &#123; env-&gt;ReleaseStringUTFChars(mimeType, mimeTypeStr); &#125;&#125; 上面是MS的JNI层代码，不知道读者看了以后是否会产生些疑惑？我想，最大的疑惑可能是，怎么会知道Java层的native_init函数对应的是JNI层的android_media_MediaScanner_native_init函数呢？下面就来回答这个问题。 1.注册JNI函数正如代码中注释的那样，native_init函数对应的JNI函数是android_media_MediaScanner_native_init，可是细心的读者可能要问了，你怎么知道native_init函数对应的是这个android_media_MediaScanner_native_init，而不是其他的呢？莫非是根据函数的名字？大家知道，native_init函数位于android.media这个包中，它的全路径名应该是android.media.MediaScanner.native_init，而JNI层函数的名字是android_media_MediaScanner_nativeinit。因为在Native语言中，符号“.”有着特殊的意义，所以JNI层需要把“.”换成“”。也就是通过这种方式，native_init找到了自己JNI层的本家兄弟android.media.MediaScanner.native_init。上面的问题其实讨论的是JNI函数的注册问题，“注册”之意就是将Java层的native函数和JNI层对应的实现函数关联起来，有了这种关联，调用Java层的native函数时，就能顺利转到JNI层对应的函数执行了。而JNI函数的注册实际上有两种方法，下面分别做介绍。（1）静态方法我们从网上找到的与JNI有的关资料，一般都会介绍如何使用这种方法完成JNI函数的注册，这种方法就是根据函数名来找对应的JNI函数。这种方法需要Java的工具程序javah参与，整体流程如下：· 先编写Java代码，然后编译生成.class文件。· 使用Java的工具程序javah，如javah–o output packagename.classname ，这样它会生成一个叫output.h的JNI层头文件。其中packagename.classname是Java代码编译后的class文件，而在生成的output.h文件里，声明了对应的JNI层函数，只要实现里面的函数即可。这个头文件的名字一般都会使用packagename_class.h的样式，例如MediaScanner对应的JNI层头文件就是android_media_MediaScanner.h。下面，来看这种方式生成的头文件：[–&gt;android_media_MediaScanner.h::样例文件]/ DO NOT EDIT THIS FILE - it is machinegenerated / #include //必须包含这个头文件，否则编译通不过/ Header for class android_media_MediaScanner/ #ifndef _Included_android_media_MediaScanner #define _Included_android_media_MediaScanner #ifdef __cplusplusextern “C” { #endif…… 略去一部分注释内容//processFile的JNI函数JNIEXPORT void JNICALLJava_android_media_MediaScanner_processFile (JNIEnv *, jobject, jstring,jstring, jobject); ……//略去一部分注释内容//native_init对应的JNI函数JNIEXPORT void JNICALLJava_android_media_MediaScanner_native_1init (JNIEnv*, jclass); #ifdef __cplusplus} #endif #endif 从上面代码中可以发现，nativeinit和processFile的JNI层函数被声明成：//Java层函数名中如果有一个””的话，转换成JNI后就变成了”_l”。JNIEXPORT void JNICALLJava_android_media_MediaScanner_native_1initJNIEXPORT void JNICALLJava_android_media_MediaScanner_processFile需解释一下，静态方法中native函数是如何找到对应的JNI函数的。其实，过程非常简单：· 当Java层调用native_init函数时，它会从对应的JNI库Java_android_media_MediaScanner_native_linit，如果没有，就会报错。如果找到，则会为这个native_init和Java_android_media_MediaScanner_native_linit建立一个关联关系，其实就是保存JNI层函数的函数指针。以后再调用native_init函数时，直接使用这个函数指针就可以了，当然这项工作是由虚拟机完成的。从这里可以看出，静态方法就是根据函数名来建立Java函数和JNI函数之间的关联关系的，它要求JNI层函数的名字必须遵循特定的格式。这种方法也有几个弊端，它们是：· 需要编译所有声明了native函数的Java类，每个生成的class文件都得用javah生成一个头文件。· javah生成的JNI层函数名特别长，书写起来很不方便。· 初次调用native函数时要根据函数名字搜索对应的JNI层函数来建立关联关系，这样会影响运行效率。有什么办法可以克服上面三种弊端吗？根据上面的介绍，Java native函数是通过函数指针来和JNI层函数建立关联关系的。如果直接让native函数知道JNI层对应函数的函数指针，不就万事大吉了吗？这就是下面要介绍的第二种方法：动态注册法。（2）动态注册既然Java native函数数和JNI函数是一一对应的，那么是不是会有一个结构来保存这种关联关系呢？答案是肯定的。在JNI技术中，用来记录这种一一对应关系的，是一个叫JNINativeMethod的结构，其定义如下：typedef struct { //Java中native函数的名字，不用携带包的路径。例如“native_init“。const char name;//Java函数的签名信息，用字符串表示，是参数类型和返回值类型的组合。 const char signature; void fnPtr; //JNI层对应函数的函数指针，注意它是void类型。} JNINativeMethod; 应该如何使用这个结构体呢？来看MediaScanner JNI层是如何做的，代码如下所示：[–&gt;android_media_MediaScanner.cpp]//定义一个JNINativeMethod数组，其成员就是MS中所有native函数的一一对应关系。static JNINativeMethod gMethods[] = { ……{“processFile” //Java中native函数的函数名。//processFile的签名信息，签名信息的知识，后面再做介绍。“(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V”, (void*)android_media_MediaScanner_processFile //JNI层对应函数指针。}, …… {“native_init”,“()V”,(void )android_media_MediaScanner_native_init}, ……};//注册JNINativeMethod数组int register_android_media_MediaScanner(JNIEnvenv){ //调用AndroidRuntime的registerNativeMethods函数，第二个参数表明是Java中的哪个类 returnAndroidRuntime::registerNativeMethods(env, “android/media/MediaScanner”, gMethods, NELEM(gMethods));} AndroidRunTime类提供了一个registerNativeMethods函数来完成注册工作，下面看registerNativeMethods的实现，代码如下：[–&gt;AndroidRunTime.cpp]int AndroidRuntime::registerNativeMethods(JNIEnvenv, constchar className, const JNINativeMethod gMethods, int numMethods){ //调用jniRegisterNativeMethods函数完成注册 return jniRegisterNativeMethods(env, className, gMethods, numMethods);}其中jniRegisterNativeMethods是Android平台中，为了方便JNI使用而提供的一个帮助函数，其代码如下所示：[–&gt;JNIHelp.c]int jniRegisterNativeMethods(JNIEnv env, constchar className, constJNINativeMethod gMethods, int numMethods){ jclass clazz; clazz= (env)-&gt;FindClass(env, className);……//实际上是调用JNIEnv的RegisterNatives函数完成注册的 if((env)-&gt;RegisterNatives(env, clazz, gMethods, numMethods) &lt; 0) { return -1; } return0;} wow，好像很麻烦啊！其实动态注册的工作，只用两个函数就能完成。总结如下：/env指向一个JNIEnv结构体，它非常重要，后面会讨论它。classname为对应的Java类名，由于JNINativeMethod中使用的函数名并非全路径名，所以要指明是哪个类。 /jclass clazz = (env)-&gt;FindClass(env, className);//调用JNIEnv的RegisterNatives函数，注册关联关系。(env)-&gt;RegisterNatives(env, clazz, gMethods,numMethods); 所以，在自己的JNI层代码中使用这种方法，就可以完成动态注册了。这里还有一个很棘手的问题：这些动态注册的函数在什么时候、什么地方被谁调用呢？好了，不卖关子了，直接给出该问题的答案：· 当Java层通过System.loadLibrary加载完JNI动态库后，紧接着会查找该库中一个叫JNI_OnLoad的函数，如果有，就调用它，而动态注册的工作就是在这里完成的。所以，如果想使用动态注册方法，就必须要实现JNI_OnLoad函数，只有在这个函数中，才有机会完成动态注册的工作。静态注册则没有这个要求，可我建议读者也实现这个JNI_OnLoad函数，因为有一些初始化工作是可以在这里做的。那么，libmedia_jni.so的JNI_OnLoad函数是在哪里实现的呢？由于多媒体系统很多地方都使用了JNI，所以码农把它放到android_media_MediaPlayer.cpp中了，代码如下所示：[–&gt;android_media_MediaPlayer.cpp]jint JNI_OnLoad(JavaVM vm, void reserved){ //该函数的第一个参数类型为JavaVM,这可是虚拟机在JNI层的代表喔，每个Java进程只有一//个这样的JavaVM JNIEnv* env = NULL; jint result = -1; if(vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) { goto bail; } ...... //动态注册MediaScanner的JNI函数。 if(register_android_media_MediaScanner(env) &lt; 0) { goto bail; }……return JNI_VERSION_1_4;//必须返回这个值，否则会报错。} JNI函数注册的内容介绍完了。下面来关注JNI技术中其他的几个重要部分。JNI层代码中一般要包含jni.h这个头文件。Android源码中提供了一个帮助头文件JNIHelp.h，它内部其实就包含了jni.h，所以我们在自己的代码中直接包含这个JNIHelp.h即可。2.数据类型转换通过前面的分析，解决了JNI函数的注册问题。下面来研究数据类型转换的问题。在Java中调用native函数传递的参数是Java数据类型，那么这些参数类型到了JNI层会变成什么呢？Java数据类型分为基本数据类型和引用数据类型两种，JNI层也是区别对待这二者的。先来看基本数据类型的转换。（1）基本类型的转换基本类型的转换很简单，可用表2-1表示：Java Native类型 符号属性 字长boolean jboolean 无符号 8位byte jbyte 无符号 8位char jchar 无符号 16位short jshort 有符号 16位int jint 有符号 32位long jlong 有符号 64位float jfloat 有符号 32位double jdouble 有符号 64位表2-1 基本数据类型转换关系表上面列出了Java基本数据类型和JNI层数据类型对应的转换关系，非常简单。不过，应务必注意，转换成Native类型后对应数据类型的字长，例如jchar在Native语言中是16位，占两个字节，这和普通的char占一个字节的情况完全不一样。接下来看Java引用数据类型的转换。（2）引用数据类型的转换引用数据类型的转换如表2-2所示：Java引用类型 Native类型 Java引用类型 Native类型All objects jobject char[] jcharArrayjava.lang.Class实例 jclass short[] jshortArrayjava.lang.String实例 jstring int[] jintArrayObject[] jobjectArray long[] jlongArrayboolean[] jbooleanArray float[] floatArraybyte[] jbyteArray double[] jdoubleArrayjava.lang.Throwable实例 jthrowable表2-2 Java引用数据类型转换关系表由上表可知：· 除了Java中基本数据类型的数组、Class、String和Throwable外，其余所有Java对象的数据类型在JNI中都用jobject表示。这一点太让人惊讶了！看processFile这个函数：//Java层processFile有三个参数。processFile(String path, String mimeType,MediaScannerClient client); //JNI层对应的函数，最后三个参数和processFile的参数对应。android_media_MediaScanner_processFile(JNIEnvenv, jobject thiz,jstring path, jstring mimeType, jobject client)从上面这段代码中可以发现：· Java的String类型在JNI层对应为jstring。· Java的MediaScannerClient类型在JNI层对应为jobject。如果对象类型都用jobject表示，就好比是Native层的void类型一样，对码农来说，是完全透明的。既然是透明的，那该如何使用和操作它们呢？在回答这个问题之前，再来仔细看看上面那个android_media_MediaScanner_processFile函数，代码如下：/Java中的processFile只有三个参数，为什么JNI层对应的函数会有五个参数呢？第一个参数中的JNIEnv是什么？稍后介绍。第二个参数jobject代表Java层的MediaScanner对象，它表示是在哪个MediaScanner对象上调用的processFile。如果Java层是static函数的话，那么这个参数将是jclass，表示是在调用哪个Java Class的静态函数。 /android_media_MediaScanner_processFile(JNIEnv*env,jobject thiz,jstring path, jstring mimeType, jobject client) 上面的代码，引出了下面几节的主角JNIEnv。 JNIEnv介绍JNIEnv是一个和线程相关的，代表JNI环境的结构体，图2-3展示了JNIEnv的内部结构：图2-3 JNIEnv内部结构简图从上图可知，JNIEnv实际上就是提供了一些JNI系统函数。通过这些函数可以做到：· 调用Java的函数。· 操作jobject对象等很多事情。后面小节中将具体介绍怎么使用JNIEnv中的函数。这里，先介绍一个关于JNIEnv的重要知识点。上面提到说JNIEnv，是一个和线程有关的变量。也就是说，线程A有一个JNIEnv，线程B有一个JNIEnv。由于线程相关，所以不能在线程B中使用线程A的JNIEnv结构体。读者可能会问，JNIEnv不都是native函数转换成JNI层函数后由虚拟机传进来的吗？使用传进来的这个JNIEnv总不会错吧？是的，在这种情况下使用当然不会出错。不过当后台线程收到一个网络消息，而又需要由Native层函数主动回调Java层函数时，JNIEnv是从何而来呢？根据前面的介绍可知，我们不能保存另外一个线程的JNIEnv结构体，然后把它放到后台线程中来用。这该如何是好？还记得前面介绍的那个JNI_OnLoad函数吗？它的第一个参数是JavaVM，它是虚拟机在JNI层的代表，代码如下所示：//全进程只有一个JavaVM对象，所以可以保存，任何地方使用都没有问题。jint JNI_OnLoad(JavaVM vm, void reserved) 正如上面代码所说，不论进程中有多少个线程，JavaVM却是独此一份，所以在任何地方都可以使用它。那么，JavaVM和JNIEnv又有什么关系呢？答案如下：· 调用JavaVM的AttachCurrentThread函数，就可得到这个线程的JNIEnv结构体。这样就可以在后台线程中回调Java函数了。· 另外，后台线程退出前，需要调用JavaVM的DetachCurrentThread函数来释放对应的资源。再来看JNIEnv的作用。 通过JNIEnv操作jobject前面提到过一个问题，即Java的引用类型除了少数几个外，最终在JNI层都用jobject来表示对象的数据类型，那么该如何操作这个jobject呢？从另外一个角度来解释这个问题。一个Java对象是由什么组成的？当然是它的成员变量和成员函数了。那么，操作jobject的本质就应当是操作这些对象的成员变量和成员函数(其实就是反射的思想)。所以应先来看与成员变量及成员函数有关的内容。（1）jfieldID 和jmethodID的介绍我们知道，成员变量和成员函数是由类定义的，它是类的属性，所以在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到：jfieldID GetFieldID(jclass clazz,const charname, const char sig);jmethodID GetMethodID(jclass clazz, const charname,const char sig); 其中，jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。如前所示，成员函数和成员变量都是类的信息，这两个函数的第一个参数都是jclass。MS中是怎么使用它们的呢？来看代码，如下所示：[–&gt;android_media_MediaScanner.cpp::MyMediaScannerClient构造函数]MyMediaScannerClient(JNIEnv *env, jobjectclient)……{ //先找到android.media.MediaScannerClient类在JNI层中对应的jclass实例。jclass mediaScannerClientInterface =env-&gt;FindClass(“android/media/MediaScannerClient”); //取出MediaScannerClient类中函数scanFile的jMethodID。mScanFileMethodID = env-&gt;GetMethodID(mediaScannerClientInterface, “scanFile”, “(Ljava/lang/String;JJ)V”); //取出MediaScannerClient类中函数handleStringTag的jMethodID。 mHandleStringTagMethodID = env-&gt;GetMethodID(mediaScannerClientInterface,”handleStringTag”, “(Ljava/lang/String;Ljava/lang/String;)V”); ……} 在上面代码中，将scanFile和handleStringTag函数的jmethodID保存为MyMediaScannerClient的成员变量。为什么这里要把它们保存起来呢？这个问题涉及一个事关程序运行效率的知识点：· 如果每次操作jobject前都去查询jmethoID或jfieldID的话将会影响程序运行的效率。所以我们在初始化的时候，就可以取出这些ID并保存起来以供后续使用。取出jmethodID后，又该怎么用它呢？（2）使用jfieldID和jmethodID下面再看一个例子，其代码如下所示：[–&gt;android_media_MediaScanner.cpp::MyMediaScannerClient的scanFile] virtualbool scanFile(const char* path, long long lastModified,long long fileSize) { jstring pathStr; if((pathStr = mEnv-&gt;NewStringUTF(path)) == NULL) return false; /调用JNIEnv的CallVoidMethod函数，注意CallVoidMethod的参数：第一个是代表MediaScannerClient的jobject对象，第二个参数是函数scanFile的jmethodID，后面是Java中scanFile的参数。 / mEnv-&gt;CallVoidMethod(mClient, mScanFileMethodID, pathStr,lastModified, fileSize); mEnv-&gt;DeleteLocalRef(pathStr); return (!mEnv-&gt;ExceptionCheck()); } 明白了，通过JNIEnv输出的CallVoidMethod，再把jobject、jMethodID和对应参数传进去，JNI层就能够调用Java对象的函数了！实际上JNIEnv输出了一系列类似CallVoidMethod的函数，形式如下：NativeType CallMethod(JNIEnv *env,jobject obj,jmethodID methodID, …)。 其中type是对应Java函数的返回值类型，例如CallIntMethod、CallVoidMethod等。上面是针对非static函数的，如果想调用Java中的static函数，则用JNIEnv输出的CallStaticMethod系列函数。现在，我们已了解了如何通过JNIEnv操作jobject的成员函数，那么怎么通过jfieldID操作jobject的成员变量呢？这里，直接给出整体解决方案，如下所示：//获得fieldID后，可调用GetField系列函数获取jobject对应成员变量的值。NativeType GetField(JNIEnv env,jobject obj,jfieldID fieldID)//或者调用SetField系列函数来设置jobject对应成员变量的值。void SetField(JNIEnv env,jobject obj,jfieldID fieldID,NativeType value) //下面我们列出一些参加的Get/Set函数。GetObjectField() SetObjectField()GetBooleanField() SetBooleanField()GetByteField() SetByteField()GetCharField() SetCharField()GetShortField() SetShortField()GetIntField() SetIntField()GetLongField() SetLongField()GetFloatField() SetFloatField()GetDoubleField() SetDoubleField() 通过本节的介绍，相信读者已了解jfieldID和jmethodID的作用，也知道如何通过JNIEnv的函数来操作jobject了。虽然jobject是透明的，但有了JNIEnv的帮助，还是能轻松操作jobject背后的实际对象了。 jstring介绍Java中的String也是引用类型，不过由于它的使用非常频繁，所以在JNI规范中单独创建了一个jstring类型来表示Java中的String类型。虽然jstring是一种独立的数据类型，但是它并没有提供成员函数供操作。相比而言，C++中的string类就有自己的成员函数了。那么该怎么操作jstring呢？还是得依靠JNIEnv提供的帮助。这里看几个有关jstring的函数：· 调用JNIEnv的NewString(JNIEnv env, const jcharunicodeChars,jsize len)，可以从Native的字符串得到一个jstring对象。其实，可以把一个jstring对象看成是Java中String对象在JNI层的代表，也就是说，jstring就是一个Java String。但由于Java String存储的是Unicode字符串，所以NewString函数的参数也必须是Unicode字符串。· 调用JNIEnv的NewStringUTF将根据Native的一个UTF-8字符串得到一个jstring对象。在实际工作中，这个函数用得最多。· 上面两个函数将本地字符串转换成了Java的String对象，JNIEnv还提供了GetStringChars和GetStringUTFChars函数，它们可以将Java String对象转换成本地字符串。其中GetStringChars得到一个Unicode字符串，而GetStringUTFChars得到一个UTF-8字符串。· 另外，如果在代码中调用了上面几个函数，在做完相关工作后，就都需要调用ReleaseStringChars或ReleaseStringUTFChars函数对应地释放资源，否则会导致JVM内存泄露。这一点和jstring的内部实现有关系，读者写代码时务必注意这个问题。为了加深印象，来看processFile是怎么做的：[–&gt;android_media_MediaScanner.cpp]static voidandroid_media_MediaScanner_processFile(JNIEnvenv, jobject thiz, jstring path, jstring mimeType, jobject client){MediaScanner mp = (MediaScanner )env-&gt;GetIntField(thiz,fields.context);……//调用JNIEnv的GetStringUTFChars得到本地字符串pathStr constchar pathStr = env-&gt;GetStringUTFChars(path, NULL);……//使用完后，必须调用ReleaseStringUTFChars释放资源env-&gt;ReleaseStringUTFChars(path, pathStr); ……} JNI类型签名的介绍先来看动态注册中的一段代码：tatic JNINativeMethod gMethods[] = { ……{“processFile”//processFile的签名信息，这么长的字符串，是什么意思？“(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V”,(void*)android_media_MediaScanner_processFile},……} 上面代码中的JNINativeMethod已经见过了，不过其中那个很长的字符串”(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V”是什么意思呢？根据前面的介绍可知，它是Java中对应函数的签名信息，由参数类型和返回值类型共同组成。不过为什么需要这个签名信息呢？· 这个问题的答案比较简单。因为Java支持函数重载，也就是说，可以定义同名但不同参数的函数。但仅仅根据函数名，是没法找到具体函数的。为了解决这个问题，JNI技术中就使用了参数类型和返回值类型的组合，作为一个函数的签名信息，有了签名信息和函数名，就能很顺利地找到Java中的函数了。JNI规范定义的函数签名信息看起来很别扭，不过习惯就好了。它的格式是：(参数1类型标示参数2类型标示…参数n类型标示)返回值类型标示。注意参数类型标示是连续的，没有空格和分隔符，参数在括号中，返回值在后面。来看processFile的例子：Java中函数定义为void processFile(String path, String mimeType)对应的JNI函数签名就是(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V 其中，括号内是参数类型的标示，最右边是返回值类型的标示，void类型对应的标示是V。 当参数的类型是引用类型时，其格式是”L包名;”，其中包名中的”.”换成”/”。上面例子中的Ljava/lang/String;表示是一个Java String类型。 函数签名不仅看起来麻烦，写起来更麻烦，稍微写错一个标点就会导致注册失败。所以，在具体编码时，读者可以定义字符串宏，这样改起来也方便。表2-3是常见的类型标示：类型标示 Java类型 类型标示 Java类型Z boolean F floatB byte D doubleC char L/java/langaugeString; StringS short [I int[]I int [L/java/lang/object; Object[]J long表2-3 类型标示示意表 上面列出了一些常用的类型标示。请读者注意，如果Java类型是数组，则标示中会有一个“[”，另外，引用类型（除基本类型的数组外）的标示最后都有一个“;”。再来看一个小例子，如表2-4所示：函数签名 Java函数“()Ljava/lang/String;” String f()“(ILjava/lang/Class;)J” long f(int i, Class c)“([B)V” void f(byte[] bytes)表2-4 函数签名小例子 请读者结合表2-3和表2-4左栏的内容写出对应的Java函数。虽然函数签名信息很容易写错，但Java提供一个叫javap的工具能帮助生成函数或变量的签名信息，它的用法如下：javap –s -p xxx。其中xxx为编译后的class文件，s表示输出内部数据类型的签名信息，p表示打印所有函数和成员的签名信息，而默认只会打印public成员和函数的签名信息。有了javap，就不用死记硬背上面的类型标示了。 垃圾回收我们知道，Java中创建的对象最后是由垃圾回收器来回收和释放内存的，可它对JNI有什么影响呢？下面看一个例子：[–&gt;垃圾回收例子]static jobject save_thiz = NULL; //定义一个全局的jobjectstatic voidandroid_media_MediaScanner_processFile(JNIEnv*env, jobject thiz, jstring path,jstringmimeType, jobject client){……//保存Java层传入的jobject对象，代表MediaScanner对象save_thiz = thiz;……return;}//假设在某个时间，有地方调用callMediaScanner函数void callMediaScanner(){//在这个函数中操作save_thiz，会有问题吗？} 上面的做法肯定会有问题，因为和save_thiz对应的Java层中的MediaScanner很有可能已经被垃圾回收了，也就是说，save_thiz保存的这个jobject可能是一个野指针，如使用它，后果会很严重。可能有人要问，将一个引用类型进行赋值操作，它的引用计数不会增加吗？而垃圾回收机制只会保证那些没有被引用的对象才会被清理。问得对，但如果在JNI层使用下面这样的语句，是不会增加引用计数的。save_thiz = thiz; //这种赋值不会增加jobject的引用计数。 那该怎么办？不必担心，JNI规范已很好地解决了这一问题，JNI技术一共提供了三种类型的引用，它们分别是：· Local Reference：本地引用。在JNI层函数中使用的非全局引用对象都是Local Reference。它包括函数调用时传入的jobject、在JNI层函数中创建的jobject。LocalReference最大的特点就是，一旦JNI层函数返回，这些jobject就可能被垃圾回收。· Global Reference：全局引用，这种对象如不主动释放，就永远不会被垃圾回收。· Weak Global Reference：弱全局引用，一种特殊的GlobalReference，在运行过程中可能会被垃圾回收。所以在程序中使用它之前，需要调用JNIEnv的IsSameObject判断它是不是被回收了。平时用得最多的是Local Reference和Global Reference，下面看一个实例，代码如下所示：[–&gt;android_media_MediaScanner.cpp::MyMediaScannerClient构造函数] MyMediaScannerClient(JNIEnv *env, jobjectclient) : mEnv(env), //调用NewGlobalRef创建一个GlobalReference,这样mClient就不用担心被回收了。 mClient(env-&gt;NewGlobalRef(client)), mScanFileMethodID(0), mHandleStringTagMethodID(0), mSetMimeTypeMethodID(0){ ……}//析构函数virtual ~MyMediaScannerClient(){ mEnv-&gt;DeleteGlobalRef(mClient);//调用DeleteGlobalRef释放这个全局引用。 } 每当JNI层想要保存Java层中的某个对象时，就可以使用Global Reference，使用完后记住释放它就可以了。这一点很容易理解。下面要讲有关LocalReference的一个问题，还是先看实例，代码如下所示：[–&gt;android_media_MediaScanner.cpp::MyMediaScannerClient的scanFile] virtualbool scanFile(const char path, long long lastModified,long long fileSize){ jstring pathStr; //调用NewStringUTF创建一个jstring对象，它是Local Reference类型。 if((pathStr = mEnv-&gt;NewStringUTF(path)) == NULL) return false; //调用Java的scanFile函数，把这个jstring传进去 mEnv-&gt;CallVoidMethod(mClient, mScanFileMethodID, pathStr,lastModified, fileSize); / 根据LocalReference的说明，这个函数返回后，pathStr对象就会被回收。所以 下面这个DeleteLocalRef调用看起来是多余的，其实不然，这里解释一下原因：1）如果不调用DeleteLocalRef，pathStr将在函数返回后被回收。2）如果调用DeleteLocalRef的话，pathStr会立即被回收。这两者看起来没什么区别，不过代码要是像下面这样的话，虚拟机的内存就会被很快被耗尽： for(inti = 0; i &lt; 100; i++) { jstring pathStr = mEnv-&gt;NewStringUTF(path); ……//做一些操作 //mEnv-&gt;DeleteLocalRef(pathStr); //不立即释放Local Reference}如果在上面代码的循环中不调用DeleteLocalRef的话，则会创建100个jstring，那么内存的耗费就非常可观了！*/ mEnv-&gt;DeleteLocalRef(pathStr); return(!mEnv-&gt;ExceptionCheck());}所以，没有及时回收的Local Reference或许是进程占用过多的一个原因，请务必注意这一点。 JNI中的异常处理JNI中也有异常，不过它和C++、Java的异常不太一样。当调用JNIEnv的某些函数出错后，会产生一个异常，但这个异常不会中断本地函数的执行，直到从JNI层返回到Java层后，虚拟机才会抛出这个异常。虽然在JNI层中产生的异常不会中断本地函数的运行，但一旦产生异常后，就只能做一些资源清理工作了（例如释放全局引用，或者ReleaseStringChars）。如果这时调用除上面所说函数之外的其他JNIEnv函数，则会导致程序死掉。来看一个和异常处理有关的例子，代码如下所示：[–&gt;android_media_MediaScanner.cpp::MyMediaScannerClient的scanFile函数]virtualbool scanFile(const char* path, long long lastModified,long long fileSize){jstring pathStr; //NewStringUTF调用失败后，直接返回，不能再干别的事情了。 if((pathStr = mEnv-&gt;NewStringUTF(path)) == NULL) return false; ...... } JNI层函数可以在代码中截获和修改这些异常，JNIEnv提供了三个函数进行帮助：· ExceptionOccured函数，用来判断是否发生异常。· ExceptionClear函数，用来清理当前JNI层中发生的异常。· ThrowNew函数，用来向Java层抛出异常。异常处理是JNI层代码必须关注的事情，读者在编写代码时务小心对待。总结这里通过一个实例介绍了JNI技术中的几个重要方面，包括：·JNI函数注册的方法1)静态注册 通过特定规则的文件名映射2)动态注册 通过JNINativeMethod保存Java函数和JNI函数的对应关系a.AndroidRunTime类提供了一个registerNativeMethods函数来完成注册工作b.实际上是调用JNIEnv的RegisterNatives函数完成注册的c.一般在JNI_OnLoad中执行·Java和JNI层数据类型的转换1)基本类型的转换很简单，就是在基本类型前加上一个j,例如int对应的jni层的数据类型就是jint2)转换成Native类型后对应数据类型的字长，例如jchar在Native语言中是16位，占两个字节3)引用类型的转换：除了Java中基本数据类型的数组、Class、String和Throwable外，其余所有Java对象的数据类型在JNI中都用jobject表示。·JNIEnv介绍a)JNIEnv是一个和线程相关的，代表JNI环境的结构体b)JNIEnv实际上就是提供了一些JNI系统函数c)调用JavaVM的AttachCurrentThread函数，就可得到这个线程的JNIEnv结构体·JNIEnv的作用1)通过JNIEnv操作jobject2)操作jobject的本质就应当是操作这些对象的成员变量和成员函数(其实就是反射的思想)3)JNI中，通过jfieldID 和jmethodID 来表示Java类的成员变量和成员函数4)JNIEnv输出了一系列类似CallVoidMethod的函数，对应的格式为CallMethod，其中type是对应Java函数的返回值类型，例如CallIntMethod、CallVoidMethod等。5)如果想调用Java中的static函数，则用JNIEnv输出的CallStaticMethod系列函数。6)获得fieldID后，可调用GetField系列函数获取jobject对应成员变量的值。例如GetObjectField()7)调用SetField系列函数来设置jobject对应成员变量的值。例如SetIntField·jstringa)在JNI规范中单独创建了一个jstring类型来表示Java中的String类型b)调用JNIEnv的NewString(JNIEnv env, const jcharunicodeChars,jsize len)，可以从Native的字符串得到一个jstring对象。c)调用JNIEnv的NewStringUTF将根据Native的一个UTF-8字符串得到一个jstring对象。d)GetStringChars和GetStringUTFChars函数，它们可以将Java String对象转换成本地字符串。e)在做完相关工作后，就都需要调用ReleaseStringChars或ReleaseStringUTFChars函数对应地释放资源，否则会导致JVM内存泄露。·JNI中的类型签名1)签名信息，由参数类型和返回值类型共同组成。2)为什么需要这个签名信息呢？因为Java支持函数重载3)JNI规范定义的函数签名的格式是：(参数1类型标示参数2类型标示…参数n类型标示)返回值类型标示。4)注意参数类型标示是连续的，没有空格和分隔符，参数在括号中，返回值在后面。5)如果Java类型是数组，则标示中会有一个“[”，另外，引用类型（除基本类型的数组外）的标示最后都有一个“;”。6)Java提供一个叫javap的工具能帮助生成函数或变量的签名信息,javap –s -p xxx ·垃圾回收在JNI层中的使用a)垃圾回收机制只会保证那些没有被引用的对象才会被清理。b)JNI技术一共提供了三种类型的引用c)Local Reference：本地引用。在JNI层函数中使用的非全局引用对象都是Local Reference。它包括函数调用时传入的jobject、在JNI层函数中创建的jobject。LocalReference最大的特点就是，一旦JNI层函数返回，这些jobject就可能被垃圾回收。d) Global Reference：全局引用，这种对象如不主动释放，就永远不会被垃圾回收。e)Weak Global Reference：弱全局引用，一种特殊的GlobalReference，在运行过程中可能会被垃圾回收。所以在程序中使用它之前，需要调用JNIEnv的IsSameObject判断它是不是被回收了。f)每当JNI层想要保存Java层中的某个对象时，就可以使用Global Reference，使用完后记住释放它就可以了。g)没有及时回收的Local Reference或许是进程占用过多的一个原因，请务必注意这一点。 ·异常处理1)当调用JNIEnv的某些函数出错后，会产生一个异常，但这个异常不会中断本地函数的执行，直到从JNI层返回到Java层后，虚拟机才会抛出这个异常。2)JNI层中产生的异常不会中断本地函数的运行，但一旦产生异常后，就只能做一些资源清理工作了（例如释放全局引用，或者ReleaseStringChars）。3)JNIEnv提供了三个函数进行帮助4)ExceptionOccured函数，用来判断是否发生异常。5)ExceptionClear函数，用来清理当前JNI层中发生的异常。6)ThrowNew函数，用来向Java层抛出异常。 相信掌握了上面的知识后，我们会对JNI技术有一个比较清晰的认识。这里，还要建议读者再认真阅读一下JDK文档中的《Java Native Interface Specification》，它完整和细致地阐述了JNI技术的各个方面，堪称深入学习JNI的权威指南。 参考文档《深入理解Android 卷Ⅰ》深入理解JNIhttps://blog.csdn.net/leejunyeah/article/details/85197204https://blog.csdn.net/ccjhdopc/article/details/52424463 Android NDK开发：JNI基础篇https://www.jianshu.com/p/ac00d59993aa 深入理解Android-JNIhttps://www.jianshu.com/p/1e7e6689e5b1 JNI Tipshttp://hukai.me/android-training-course-in-chinese/performance/perf-jni/index.html 源码 本章涉及的源代码文件名及位置下面是本章分析的源码文件名及其位置。· MediaScanner.javaframework/base/media/java/src/android/media/MediaScanner.java· android_media_MediaScanner.cppframework/base/media/jni/MediaScanner.cpp· android_media_MediaPlayer.cppframework/base/media/jni/android_media_MediaPlayer.cpp· AndroidRunTime.cppframework/base/core/jni/AndroidRunTime.cpp· JNIHelp.cdalvik/libnativehelper/JNIHelp.c]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String详解]]></title>
    <url>%2F2018%2F06%2F13%2FString%2F</url>
    <content type="text"><![CDATA[java中String、StringBuffer、StringBuilder是编程中经常使用的字符串类,他们之间的区别也是经常在面试中会问到的问题。 下面详细分析下这三个字符串类，并做对比总结。 StringString类是final修饰的，不能被继承，String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。 常用方法 构造方法，String有11个构造方法，支持传入不同类型的参数 length() : 返回字该字符串的长度 charAt(int indext) : 求字符串某一位置的字符，index必须&gt;=0并且&lt;= length()-1 截取字符串 substring(int beginIndex) : 该方法从beginIndex位置起（包含这个位置）到最后截取一个字符串返回。[beginIndex,最后] substring(int beginIndex，endIndex) : 该方法从beginIndex位置起（包含这个位置）到endIndex - 1截取一个字符串返回。[beginIndex,endIndex - 1] 123String str1 = new String(&quot;abcdefgkl&quot;);String str2 = str1.substring(2);//str2 = &quot;cdefgkl&quot;String str3 = str1.substring(2,5);//str3 = &quot;cde&quot; 字符串比较 public int compareTo(String anotherString) 该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。其比较规则是：拿出字符串的第一个字符与参数的第一个字符进行比较，如果两者不等，比较结束，返回两者的ascii差。这里有一点需要注意：如果两个字符串的长度不同，并且一个字符串与另一个字符串的前面N个字符相等，那么这个方法返回返回两个字符串长度之差。 public int compareToIgnore(String anotherString) 与compareTo方法相似，但忽略大小写。 public boolean equals(Object anotherObject) 比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。 public boolean equalsIgnoreCase(String anotherString) 与equals方法相似，但忽略大小写。 12345678910111213141516171819202122 String s1 = &quot;abcd&quot;; String s2 = &quot;abce&quot;; String s3 = &quot;ABC&quot;; String s4 = &quot;abcdefg&quot;; String s5 = &quot;abc&quot;; System.out.println(s1.compareTo(s2)); System.out.println(s1.compareTo(s3)); System.out.println(s4.compareTo(s1)); System.out.println(s4.compareTo(s2)); System.out.println(s3.compareToIgnoreCase(s5)); System.out.println(s3.equals(s5)); System.out.println(s3.equalsIgnoreCase(s5));output:-1323-10falsetrue 字符串连接 public String concat(String str) 将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。 字符串中单个字符查找 public int indexOf(int ch/String str) 用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。 public int indexOf(int ch/String str, int fromIndex) 与第一种类似，区别在于该方法从fromIndex位置向后查找。 public int lastIndexOf(int ch/String str) 方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。 public int lastIndexOf(int ch/String str, int fromIndex) 该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 12345678910111213 String str = &quot;I am a good student&quot;; System.out.println(str.indexOf(&apos;a&apos;)); System.out.println(str.indexOf(&quot;good&quot;)); System.out.println(str.indexOf(&quot;w&quot;,2)); System.out.println(str.lastIndexOf(&quot;a&quot;)); System.out.println(str.lastIndexOf(&quot;a&quot;,3));output:27-152 字符串中字符的大小写转换 public String toLowerCase() 返回将当前字符串中所有字符转换成小写后的新串 public String toUpperCase() 返回将当前字符串中所有字符转换成大写后的新串 字符串中字符的替换 public String replace(char oldChar, char newChar) 用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。 public String replaceFirst(String regex, String replacement) 该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。 public String replaceAll(String regex, String replacement) 该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 注意replaceAll的参数是regex,即基于规则表达式的替换, 其他方法 String trim() 截去字符串两端的空格，但对于中间的空格不处理。如果要去掉所有空格可以利用replaceAll(“ “,””); contains(String str) 判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 String[] split(String str) 将str作为分隔符进行字符串分解，分解后的字符串在字符串数组中返回。 字符串与基本类型的转换 字符串转换为基本类型 1234561)public static byte parseByte(String s)2)public static short parseShort(String s)3)public static short parseInt(String s)4)public static long parseLong(String s)5)public static float parseFloat(String s)6)public static double parseDouble(String s) 基本类型转换为字符串类型 String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。 123456781)static String valueOf(char data[])2)static String valueOf(char data[], int offset, int count)3)static String valueOf(boolean b)4)static String valueOf(char c)5)static String valueOf(int i)6)static String valueOf(long l)7)static String valueOf(float f)8)static String valueOf(double d) String常量池常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 Java为了提高性能，静态字符串（字面量/常量/常量连接的结果）在常量池中创建，并尽量使用同一个对象，重用静态字符串。对于重复出现的字符串直接量，JVM会首先在常量池中查找，如果常量池中存在即返回该对象。 12345678910111213public class test1 &#123; public static void main(String[] args) &#123; String str1 = &quot;Hello&quot;; // 常量池未有该对象，需要创建，生成两个对象 String str2 = &quot;Hello&quot;; //生成了1个对象&quot;Hello&quot; // 不会创建新的String对象，而是使用常量池中已有的&quot;Hello&quot; System.out.println(str1 == str2); // true // 使用new关键字会创建新的String对象，不管常量池里面有没有相同的值 String str3 = new String(&quot;Hello&quot;);// 生成了2个对象&quot;Hello&quot;和new String(&quot;Hello&quot;) System.out.println(str1 == str3); // false &#125;&#125; == &amp;&amp; equalequal和&quot;==&quot;两者均表示相等的意思，但是他们相等的含义却有所区别。 “==”运用在基本数据类型的时候，通过比较它们实际的值来判定是否相同；而用于比较引用类型的时候，则是**比较两个引用的地址**是否相等，也就是是否指向同一个对象。 equal方法是java.lang.Object的方法，也就是所以的Java类都会有的方法。它可以被程序员覆盖重写，通过自定义的方式来判定两个对象是否相等。 对于字符串java.lang.String类来说，它的equal方法用来比较字符串的字符序列是否完全相等。 12345678910111213141516171819public class EqualTest&#123; public static void main(String args[]) &#123; //定义三个字符串变量 String a=&quot;1234&quot;; String b=&quot;1234&quot;; String c=new String(&quot;1234&quot;); //三种不同的布尔判断 System.out.println(a==b); System.out.println(a==c); System.out.println(a.equal(c)); &#125; &#125; true false true String对象不可变String是常量，其对象一旦构造就不能再被改变。换句话说，String对象是不可变的，每一个看起来会修改String值的方法，实际上都是创造了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。 Ascii码常用字母Ascii码 ： a z A Z StringBuffer和 String 类不同的是，StringBuffer类的对象能够被多次的修改，并且不产生新的未使用对象。 常用方法 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 public StringBuffer reverse() 将此字符序列用其反转形式取代。 public delete(int start, int end) 移除此序列的子字符串中的字符。 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 int capacity() 返回当前容量 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 void setLength(int newLength) 设置字符序列的长度。 StringBuilderStringBuilder是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 两者的方法基本相同。 String、StringBuffer和StringBuilder的异同 都是 final 类, 都不允许被继承 是否可变 String: 不可变 StringBuilder：可变 StringBuffer：可变 String创建的对象位于常量池，是一个不可变常量,注意String类并不是字符串常量，而是创建的对象是字符串常量。对于String对象，当常量池中不存在，则在常量池中创建，再复制到堆中。StringBuilder/StringBuffer位于堆中，引用在java虚拟机栈的局部变量表中 线程是否安全 String: 线程安全 StringBuilder：非线程安全的 StringBuffer： 线程安全 String中的对象是不可变的，也就可以理解为常量，所以线程安全。 StringBuilder没有对方法进行加同步锁，所以是非线程安全的。 StringBuffer中的方法大都采用了synchronized关键字修饰，所以是线程安全的 字符串追加速度比较 StringBuilder &gt; StringBuffer &gt; String StringBuffer与StringBuilder，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。 注意事项1) 基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。 2) 不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。 3) StringBuilder一般使用在方法内部来完成类似”+”功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中。 4) 相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。 面试考点 String对象创建的内存模型 创建的对象 对象比较 equal &amp;&amp; == String、StringBuffer和StringBuilder的异同 使用场景1.如果要操作少量的数据用 String2.单线程操作字符串缓冲区 下操作大量数据 StringBuilder3.多线程操作字符串缓冲区 下操作大量数据 StringBuffer 源码分析TODO String、StringBuffer、StringBuilder源码解读 总结 参考文档String&amp;&amp;StringBuffer&amp;&amp;StringBuilder深层次解析 String、StringBuffer、StringBuilder详解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式详解]]></title>
    <url>%2F2018%2F05%2F20%2FStrategyPattern%2F</url>
    <content type="text"><![CDATA[概述在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 在程序客户端，可以通过注入不同的实现对象来实现策略的动态替换。 介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用： 一个系统有许多许多类，而区分它们的只是他们直接的行为。 需要安全的封装多种同一类型的操作时 出现同一个抽象类的多个子类，需要使用if-else或者switch来切换选择具体子类 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 JAVA AWT 中的 LayoutManager。 优点： 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点： 策略类会增多。 所有策略类都需要对外暴露。 使用场景： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 类图其中： Context －－ 用来操作策略的上下文环境 Stragety – 策略的抽象 ConcreateStragetyA ConcreateStragetyB – 具体的策略实现 简单实现实例：计算不同出行工具的成本：公交车，地铁。 创建一个接口 Strategy.java 123public interface CalculateStrategy &#123; public int calculatePrice(int km);&#125; 创建实现接口的实体类BusStrategy.java123456public class BusStrategy implements CalculateStrategy&#123; @Override public int calculatePrice(int km) &#123; return km * 2; &#125;&#125; SubwayStrategy.java 123456public class SubwayStrategy implements CalculateStrategy&#123; @Override public int calculatePrice(int km) &#123; return km * 5; &#125;&#125; 创建 Context 类: 提供计算出行方式的统一接口，这里其实有代理模式的意思在里面。 TranficCalculator.java1234567891011public class TranficCalculator &#123; private Strategy strategy; public setStrategy(Strategy strategy)&#123; this.strategy = strategy; &#125; public int calculatePrice(int km)&#123; return strategy.calculatePrice(km); &#125;&#125; 拓展策略类：新增一个出租车类TaxiStrategy.java 123456public class TaxiStrategy implements Strategy&#123; @Override public int calculatePrice(int km) &#123; return km * 10; &#125;&#125; 使用 Context 来查看当它改变策略 Strategy 时的行为变化。 StrategyPatternDemo.java1234567891011121314public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; TranficCalculator context = new TranficCalculator(); // 选择地铁出行 context.setStrategy(new SubwayStrategy()) System.out.println(&quot;地铁1公里&quot; + context.calculatePrice(1)); // 选择公交车 context.setStrategy(new BusStrategy()) System.out.println(&quot;公交车1公里&quot; + context.calculatePrice(1)); // 选择出租车 context.setStrategy(new TaxiStrategy()) System.out.println(&quot;出租车1公里&quot; + context.calculatePrice(1)); &#125;&#125; 策略模式与状态模式区别： 状态模式将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现，当发现传入参数不是自己这个状态所对应的参数，则自己给Context类切换状态； 而策略模式是直接依赖注入到Context类的参数进行选择策略，不存在切换状态的操作. 联系： 状态模式和策略模式都是为具有多种可能情形设计的模式，把不同的处理情形抽象为一个相同的接口，符合对扩展开放，对修改封闭的原则。 策略模式更具有一般性一些，在实践中，可以用策略模式来封装几乎任何类型的规则，只要在分析过程中听到需要在不同实践应用不同的业务规则，就可以考虑使用策略模式处理，在这点上策略模式是包含状态模式的功能的。 参考文档 策略模式|菜鸟教程 Android源码设计模式解析与实战]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式详解]]></title>
    <url>%2F2018%2F05%2F20%2FStatePattern%2F</url>
    <content type="text"><![CDATA[概述在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 介绍 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 行为随状态改变而改变的场景。 条件、分支语句的代替者。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个(不一定)。 UMLUML如下图所示，角色介绍： Context:环境类，定义客户感兴趣的接口，维护一个所有State子类的实例，这个实例定义当前的状态 State: 抽象状态类或者状态接口，定义一个或者一组接口，表示该状态下的行为。 ConcreateStateA ConcreateStateB : 具体状态类，每一个状态类实现抽象的State中定义的接口，从而实现不同状态的不同行为。 实例定义两种状态，开始和停止，分别对应不同的操作。 创建一个接口。 State.java 123public interface State &#123; public void doAction(Context context);&#125; 创建实现接口的实体类。 StartState.java 1234567891011public class StartState implements State &#123; public void doAction(Context context) &#123; System.out.println(&quot;Player is in start state&quot;); context.setState(this); &#125; public String toString()&#123; return &quot;Start State&quot;; &#125;&#125; StopState.java1234567891011public class StopState implements State &#123; public void doAction(Context context) &#123; System.out.println(&quot;Player is in stop state&quot;); context.setState(this); &#125; public String toString()&#123; return &quot;Stop State&quot;; &#125;&#125; 创建 Context 类。 Context.java123456789101112131415public class Context &#123; private State state; public Context()&#123; state = null; &#125; public void setState(State state)&#123; this.state = state; &#125; public State getState()&#123; return state; &#125;&#125; 使用 Context 来查看当状态 State 改变时的行为变化。 StatePatternDemo.java 123456789101112131415public class StatePatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); &#125;&#125; output1234Player is in start stateStart StatePlayer is in stop stateStop State Android中的状态模式Android定义了状态机，核心就是状态模式，通过使用状态机，可以清晰的在多个状态间切换。 参考文档状态模式｜菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式详解]]></title>
    <url>%2F2018%2F05%2F20%2FProxyPattern%2F</url>
    <content type="text"><![CDATA[概述在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 设计理念意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 优点： 职责清晰。 高扩展性。 智能化。 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 远程代理。 虚拟代理。 Copy-on-Write 代理。 保护（Protect or Access）代理。 Cache代理。 防火墙（Firewall）代理。 同步化（Synchronization）代理。 智能引用（Smart Reference）代理。 注意事项： 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 UML 实例创建一个接口。 Image.java public interface Image { void display();} 步骤 2 创建实现接口的实体类。 RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(“Displaying “ + fileName); } private void loadFromDisk(String fileName){ System.out.println(“Loading “ + fileName); }} ProxyImage.java public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); }} 参考文档代理模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式详解]]></title>
    <url>%2F2018%2F05%2F20%2FFlyweightPattern%2F</url>
    <content type="text"><![CDATA[享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式是对象池的一种实现 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 设计理念 定义： 使用共享对象可有效地支持大量的细粒度的对象。 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 系统中有大量对象; 这些对象消耗大量内存; 这些对象的状态大部分可以外部化; 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替; 系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。一般使用Map 关键代码：用 HashMap 存储这些对象。 应用实例： JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面 数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 系统有大量相似对象; 需要缓冲池的场景。 注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题; 这些类必须有一个工厂对象加以控制。 享元模式的UML图 实现我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle以及工厂类 ShapeFactory。 ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。 FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。 步骤 1： 创建一个接口。也可以是抽象类 1234Shape.javapublic interface Shape &#123; void draw();&#125; 步骤 2： 创建实现接口的实体类。 1234567891011121314151617181920212223242526272829Circle.javapublic class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println(&quot;Circle: Draw() [Color : &quot; + color +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius); &#125;&#125; 步骤 3： 创建一个工厂，生成基于给定信息的实体类的对象。 12345678910111213141516ShapeFactory.javaimport java.util.HashMap;public class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public static Shape getCircle(String color) &#123; Circle circle = (Circle)circleMap.get(color); if(circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println(&quot;Creating circle of color : &quot; + color); &#125; return circle; &#125;&#125; 步骤 4： 使用该工厂，通过传递颜色信息来获取实体类的对象。 12345678910111213141516171819202122232425FlyweightPatternDemo.javapublic class FlyweightPatternDemo &#123; private static final String colors[] = &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 ); &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125;&#125; Android中的享元模式Message对象的管理 参考文档享元模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式详解]]></title>
    <url>%2F2017%2F07%2F20%2FDesignPattern-md%2F</url>
    <content type="text"><![CDATA[概述设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 传送门每一种的设计模式，我们会在单章后详细分析，列表如下： 创建型模式： 工厂模式(TODO)抽象工厂模式(TODO)单例模式(TODO)建造者模式(TODO)原型模式(TODO) 结构型模式： 适配器模式(TODO)桥接模式(TODO)过滤器模式(TODO)组合模式(TODO)装饰者模式(TODO)外观模式(TODO)代理模式享元模式 行为型模式： 责任链模式(TODO)命令模式(TODO)解释器模式(TODO)迭代器模式(TODO)中介者模式(TODO)备忘录模式(TODO)观察者模式(TODO)状态模式空对象模式(TODO)策略模式模板模式(TODO)访问者模式(TODO) 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类： 创建型模式（Creational Patterns） 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。 这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式（Structural Patterns） 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 行为型模式（Behavioral Patterns） 这些设计模式特别关注对象之间的通信。 所有设计模式的分类如下图： 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 参考文档设计模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用android系统自带资源]]></title>
    <url>%2F2017%2F06%2F08%2F%E4%BD%BF%E7%94%A8android%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E8%B5%84%E6%BA%90%20%2F</url>
    <content type="text"><![CDATA[概述Android系统本身有很多的资源，包括各种各样的字符串、图片、动画、样式和布局等等，这些都可以在应用程序中直接使用。这样做的好处很多，既可以减少内存的使用，又可以减少部分工作量，也可以缩减程序安装包的大小。 Android各种资源123R.anim、R.animator、R.array、R.attr、R.bool、R.color、R.dimen、R.drawable、R.fractionR.id、R.integer、R.interpolator、R.layout、R.menu、R.mipmap、R.plurals、R.rawR.string、R.style、R.styleable、R.transition、R.xml 使用系统公开资源调用系统的样式，主题，动画资源等一般以@开头 使用@符号, 就可以在一个资源中引用另一个资源,使用android.R类中可用的系统的Android资源类, 则需要指定android作为包的名称, 使用”@android:”, 而不是”@”; 123android:theme=&quot;@android:style/Theme.Dialog&quot;android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; 调用attr下的资源设置view的属性，一般以?开头，比如： 123android:textColor=&quot;?android:attr/textColorPrimary&quot;style=&quot;?android:attr/progressBarStyleLarge&quot; @id和@+id区别@+id 新增一个资源id＠id和android：id，引用现有的资源id Android中的组件需要用一个int类型的值来表示，这个值就是组件标签中的id属性值。 id属性只能接受资源类型的值，也就是必须以@开头的值，例如，@id/abc、@+id/xyz等。 如果在@后面使用“+”，表示当修改完某个布局文件并保存后，系统会自动在R.java文件中生成相应的int类型变量。变量名就是“/”后面的值，例如，@+id/xyz会在R.java文件中生成int xyz = value，其中value是一个十六进制的数。如果xyz在R.java中已经存在同名的变量，就不再生成新的变量，而该组件会使用这个已存在的变量的值。 既然组件的id属性是一个资源id就可以，那么自然可以设置任何已经存在的资源id值，例如，@drawable/icon、@string/ok、@+string/you等。也可以设置android系统中已存在的资源id，例如@id/android:list，那么，这个android是什么意思呢，实际上，这个android就是系统的R类（在R.java文件中）所在的package。 我们可以在Java代码编辑区输入android.R.id.，就会列出相应的资源id，例如，也可以设置id属性值为@id/android:message。 利用系统定义的字符串资源123java: android.R.string.string_name XML: @string/string_nameResources.getString(); 利用系统的图片资源12 java: android.R.drawable.ImageNamexml: android:icon=&quot;@android:drawable/ImageName&quot; 使用系统颜色123 java: android.R.color.redxml: &quot;@android:color/red&quot;getResources().getColor() dimen资源123java R.dimen.dimen_nameXML @dimen/dimen_nameResources.getDimension() 使用系统Style1android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; XML资源12java: R.xml.xml_nameResources.getXml() 使用系统隐藏资源Android中没有公开的资源，直接引用在编译时就会报错，需要使用特殊的方法。 123int lebId = Resources.getSystem().getIdentifier(&quot;permlab_accessNetworkState&quot;, &quot;string&quot;, &quot;android&quot;);String lab = getString(lebId); getIdentifier方法说明 1234567891011121314151617181920212223/** * Return a resource identifier for the given resource name. A fully * qualified resource name is of the form &quot;package:type/entry&quot;. The first * two components (package and type) are optional if defType and * defPackage, respectively, are specified here. * * &lt;p&gt;Note: use of this function is discouraged. It is much more * efficient to retrieve resources by identifier than by name. * * @param name The name of the desired resource. * @param defType Optional default resource type to find, if &quot;type/&quot; is * not included in the name. Can be null to require an * explicit type. * @param defPackage Optional default package to find, if &quot;package:&quot; is * not included in the name. Can be null to require an * explicit package. * * @return int The associated resource identifier. Returns 0 if no such * resource was found. (0 is not a valid resource ID.) */public int getIdentifier(String name, String defType, String defPackage) &#123; return mResourcesImpl.getIdentifier(name, defType, defPackage);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>res</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sqlite3 使用详解]]></title>
    <url>%2F2017%2F05%2F08%2Fsqlite3%2F</url>
    <content type="text"><![CDATA[SQLite命令SQL(Structured Query Language)是一种标准的数据库查询语言，即所有的关系型数据库都会支持它，只不过每种数据库对SQL语言的支持与标准存在着细微的不同。我们无须关心其它数据库对SQL语言的支持情况，这里我们只要把重点放在SQLite上就可以了。下面我将使用模拟器来对SQLite支持的各种命令进行演示，如果你想用手机的话也可以，但要确保你的手机已经Root，并且包含sqlite3这个命令文件。 首先确保模拟器已经连接上了电脑，然后在命令行输入adb shell进入控制台，如下图所示： 注意#符号表示我们当前已经是超级用户了，如果显示的是$符号，表示当前只是普通用户而已，这时还需要输入su命令切换一下用户身份才行。 有了超级用户权限之后，我们能做的事情就很多了，这里我们先查看一下系统自带的联系人表吧。进入到/data/data目录下，如下图所示： 所有应用程序的本地存储文件都是存放在这个目录下面的。为了要让不同应用程序之间的数据容易区别开来，Android是使用应用程序包名进行分开管理，也就是说每个应用程序的本地存储文件都会存放在自己应用程序包名的那个目录下，这里我们ls一下看看有多少子目录： OK，确实有很多，毕竟手机上所有的应用程序都在这里。其中，com.android.providers.contacts中存放的就是联系人的相关数据，我们进入到这个目录再ls一下： 可以看到，目前有databases、files、lib和shared_prefs这几个子目录。其中databases肯定是用于存放数据库文件的，files是用于存放普通文本文件的，lib是用于存放so库的，shared_prefs则是用于存放shared文件的。这是Android数据持久化的几种可选方式，对这部分内容不太了解的朋友可以参考《第一行代码——Android》的第六章。 接着进入到databases目录中，再ls： 其中后缀名为journal的文件是日志文件，我们不用管，contacts2.db和profile.db才是真正的数据库文件，可以使用sqlite3命令来打开数据库，如下图所示： 好的，数据库已经打开了，那么我们怎么才能知道当前数据库中有哪些表呢？很简单，.table命令就可以做到了： 哇，竟然有这么多张表！是的，联系人的数据结构非常复杂，很多的数据都是分表存储的。这里我们随便挑一张表，比如说accounts表，如果我想知道这张表中有哪些列应该怎么办呢？在MySQL中可以使用desc accounts这个命令，但SQLite却不认识这个命令，毕竟它们是有差异化的。SQLite中可以使用pragma table_info(TABLE_NAME)这个命令来查看表的数据结构，如下图所示： 可以看到，一共显示了三条结果，表示accounts表中共有三列。但是，所有的字段都缩在了一行里面，并用“|”符号分隔，这样我们很难看出每个字段的含义。很简单，只需要换一种显示模式就行了，比如说line模式就挺不错的。输入.mode line命令切换显示模式，然后重新运行pragma命令，结果如下图所示： 怎么样，这样就清晰多了吧？这三列的列名分别是account_name、account_type和data_set，数据类型都是TEXT(字符串)，允许为空，并且都不是主键。好，那我现在想查一查accounts表中的数据呢？这就太简单了，使用select语句就可以了，如下所示： 恩？怎么只有一条空数据啊。貌似模拟器上默认就是这样的，如果你用的是手机的话，这里应该就可以查到真正的数据了。不过没关系，我们可以在设置里面手动添加一个邮箱账户，如下图所示： 现在再来重新查询一遍accounts表，如下所示： OK，添加的新账户已经成功查出来了。 除了查询命令之外，还有其它的增删改命令都和标准的SQL语法是相同的，即insert、delete和update，由于比较简单，我就不再赘述了。比较值得一提的是，每个SQLite数据库中都还有一个隐藏的sqlite_master表，这里记载了当前数据库中所有表的建表语句，可以使用select * from sqlite_master命令进行查看： 结果太多了是不是？一屏根本就显示不下嘛。不要着急，别忘了我们使用的是select命令，可以使用where语句来过滤出我们想要查询的那部分内容，如下图所示： OK，CREATE TABLE accounts (account_name TEXT, account_type TEXT, data_set TEXT) 这就是accounts表的建表语句了，通过这种方式我们可以查询到任意一张表的建表语句，从而对我们学习和分析数据库表结构有所帮助。 有些朋友可能会觉得，每次都要输入select命令来查询表中的数据太麻烦了。没错，而且还要保证手机是连接在电脑上的时候才能查询，确实太不方便。幸运的是，有些手机软件已经提供了数据库表查询的功能，使得我们随时随地都可以方便地查看数据库中的数据，比如Root Explorer这款软件就不错。 仍然是确保你的手机已经Root，然后安装Root Explorer，打开软件之后按照我们前面介绍的路径，进入/data/data/com.android.providers.contacts/databases，点击contacts2.db数据库，选择内置数据库查看器，然后随便点击一张表就可以查看到里面的数据了，如下图所示： sqlite3的常用命令12345678910111213141516.tables 显示所有表.schema 显示数据库的schema.schema table_name 显示表的schema.headers on 显示标题栏，即字段名栏，如在查看数据中数据时，默认select * from table_name不显示字段名。alter table 修改表。改变表名 - ALTER TABLE 旧表名 RENAME TO 新表名；增加一列 - ALTER TABLE 表名 ADD COLUMN 列名 数据类型 限定符select * from sqlite_master where type=&quot;table&quot;; 显示所有表的结构select * from sqlite_master where type=&quot;table&quot; and name=&quot;table_name&quot;; 显示某个表的结构drop table table_name 删除表.quit 退出.read FileName 执行FileName中的sql标准的sql语句也可以用，但必须用分号结束，如下select语句;delete语句;update语句;insert语句; 触发器 sqlite3 操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 建表CREATE TABLE COMPANY(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL);// 插入数据INSERT INTO COMPANY (ID,NAME,AGE) VALUES (1, &apos;AAA&apos;, 31);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (2, &apos;BBB&apos;, 32);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (3, &apos;CCC&apos;, 33);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (4, &apos;DDD&apos;, 34);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (5, &apos;EEE&apos;, 35);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (6, &apos;FFF&apos;, 36);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (7, &apos;GGG&apos;, 37);// 查询1. select * from calls where type = 3 order by date desc;2. select count(*) from calls where type = 3 order by date desc; // 计算数目// 删除DELETE FROM COMPANY WHERE AGE = (SELECT AGE FROM COMPANY ORDER BY AGE DESC LIMIT 1 OFFSET 3);// 触发器// 删除第5条数据 ，同理 删除第21条数据则offset为20 limit为1 即限制条数为5条CREATE TRIGGER audit_log AFTER INSERT ON COMPANY BEGIN DELETE FROM COMPANY WHERE AGE = (SELECT AGE FROM COMPANY ORDER BY AGE DESC LIMIT 1 OFFSET 5); END;// 限制通话记录只保存最近 20 个未接电话,最近 20 个已接电话和最近 20 个呼出电话1. create trigger missed_call_count_limit after insert on Tables.CALLS begin delete from Tables.CALLS where Calls.DATE = (select Calls.DATE from Tables.CALLS where Calls.TYPE = MISSED_TYPE order by Calls.DATE desc limit 1 offset 5); end;&gt; 转换后的语句create trigger missed_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 3 order by date desc limit 1 offset 20); end;&gt; 去除换行的语句 // 1. 已接来电 create trigger incoming_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 1 order by date desc limit 1 offset 20); end;// 2.呼出电话 create trigger outgoing_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 2 order by date desc limit 1 offset 20); end; // 3. 未接来电 create trigger missed_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 3 order by date desc limit 1 offset 20); end; select count(*) from calls where type = 1 order by date desc; select count(*) from calls where type = 2 order by date desc; select count(*) from calls where type = 3 order by date desc; new&amp;&amp; old的问题 new是新插入的数据，old是原来的数据 insert只会有new，代表着要插入的新记录 delete只会有old，代表着要删除的记录 update由于执行的是先删除旧的记录，再插入新的记录，因此new和old都会有。 参考文档 http://www.yiibai.com/sqlite/sqlite_overview.html http://www.runoob.com/sqlite/sqlite-tutorial.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Toast源码解析]]></title>
    <url>%2F2017%2F03%2F08%2FToast%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Toast简介Toast是一种提供给用户简洁信息的视图，该视图已浮于应用程序之上的形式呈现给用户。Toast源码位于：frameworks\base\core\java\android\widget\Toast.java Toast使用Toast使用就一行代码：1Toast.makeText(ToastActivity.this,&quot;Toast源码解析&quot;,Toast.LENGTH_LONG).show(); Toast 提供了setView方法，可以自定义View：12345Toast toast=new Toast(ToastActivity.this);View view=View.inflate(ToastActivity.this,R.layout.toast_view,null);toast.setView(view);toast.setGravity(Gravity.CENTER,0,0);toast.show(); toast_view.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@mipmap/ic_launcher&quot; /&gt;&lt;/LinearLayout&gt; Toast源码分析Toast源码分析有两个目标，知道Toast源码在哪里体现了Toast显示，又在哪里体现了Toast消失。首先从Toast的基本使用，作为入口。1Toast.makeText(ToastActivity.this,&quot;Toast源码解析&quot;,Toast.LENGTH_LONG).show(); 1. makeText1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v;//传入下个view result.mDuration = duration;//Toast显示的时间长度 return result; &#125; makeText中的transient_notification.xml，源码位于：frameworks\base\core\res\layout\transient_notification.xml12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 从makeText方法看，就是Toast的自定义view的那部分代码。 2. show123456789101112131415161718public void show() &#123; //解释自定义view，需要先setView if (mNextView == null) &#123; throw new RuntimeException(&quot;setView must have been called&quot;); &#125; //得到INotificationManager服务 INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); //TN对象 TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; 看了show方法，发现涉及两个新的类，TN 和INotificationManager 。enqueueToast方法大概就是实现Toast显示和消失吧，让我们一步步探索。 2.1. TN123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141private static class TN extends ITransientNotification.Stub &#123; final Runnable mShow = new Runnable() &#123; @Override public void run() &#123; handleShow();//显示处理 &#125; &#125;; final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide();//消失处理 // Don&apos;t do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125; &#125;; //应用程序窗口 private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); final Handler mHandler = new Handler(); int mGravity;//出现在屏幕的位置 int mX, mY;//分别是出现在屏幕的X、Y方向偏移量 float mHorizontalMargin;//横向margin值 float mVerticalMargin;//竖向margin值 View mView;//当前view View mNextView;//下个Toast显示的view WindowManager mWM; //TN构造函数 TN() &#123; // XXX This should be changed to use a Dialog, with a Theme.Toast // defined that sets up the layout params appropriately. final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; // 不设置这个弹出框的透明遮罩显示为黑色 params.format = PixelFormat.TRANSLUCENT; // 动画 params.windowAnimations = com.android.internal.R.style.Animation_Toast; // 类型 params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle(&quot;Toast&quot;); // 设置flag params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; &#125; /** * schedule handleShow into the right thread */ @Override public void show() &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); &#125; //显示Toast public void handleShow() &#123; if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) &#123;//判断下个view是否一样 // remove the old view if necessary handleHide();//移除当前view mView = mNextView; Context context = mView.getContext().getApplicationContext();//获取当前view上下文 String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; //获得 WindowManager对象 mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); //获取绝对的Gravity final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView);//如果当前view存在，先移除 &#125; if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams);//通过WindowManager调用addView加载 trySendAccessibilityEvent(); &#125; &#125; private void trySendAccessibilityEvent() &#123; AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(mView.getContext()); if (!accessibilityManager.isEnabled()) &#123; return; &#125; // treat toasts as notifications since they are used to // announce a transient piece of information to the user AccessibilityEvent event = AccessibilityEvent.obtain( AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED); event.setClassName(getClass().getName()); event.setPackageName(mView.getContext().getPackageName()); mView.dispatchPopulateAccessibilityEvent(event); accessibilityManager.sendAccessibilityEvent(event); &#125; //WindowManager调用removeView方法来将Toast视图移除 public void handleHide() &#123; if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn&apos;t yet added, so let&apos;s try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); &#125; mView = null; &#125; &#125; &#125; TN类继承自ITransientNotification.Stub，ITransientNotification.aidl，用于进程间通信，源码位于frameworks\base\core\java\android\app\ITransientNotification.aidl12345/** @hide */oneway interface ITransientNotification &#123; void show(); void hide();&#125; 具体实现就在TN类，其他进程回调TN类，来操作Toast的显示和消失：1234567891011121314@Override public void show() &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow);//显示 &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide);//消失 &#125; 这里可以看出Toast显示和消失用的Handler机制实现的。 2.2. INotificationManager调用了getService，如下：123456789private static INotificationManager sService; static private INotificationManager getService() &#123; if (sService != null) &#123; return sService; &#125; sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; &#125; 得到INotificationManager服务，再调用enqueueToast方法，参数有三个，包名，TN，时间。INofiticationManager接口的具体实现类是NotificationManagerService类，源码位置：frameworks\base\services\core\java\com\android\server\notification\NotificationManagerService.java 2.3. enqueueToast1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) &#123; if (DBG) &#123; Slog.i(TAG, &quot;enqueueToast pkg=&quot; + pkg + &quot; callback=&quot; + callback + &quot; duration=&quot; + duration); &#125; if (pkg == null || callback == null) &#123; Slog.e(TAG, &quot;Not doing toast. pkg=&quot; + pkg + &quot; callback=&quot; + callback); return ; &#125; //(1)判断是否系统的Toast，如果当前包名是android则为系统 final boolean isSystemToast = isCallerSystem() || (&quot;android&quot;.equals(pkg)); //判断当前toast所属的pkg是不是所阻止的 if (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) &#123; if (!isSystemToast) &#123; Slog.e(TAG, &quot;Suppressing toast from package &quot; + pkg + &quot; by user request.&quot;); return; &#125; &#125; //入队列mToastQueue synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; //(2)判断Toast是否在队列当中 int index = indexOfToastLocked(pkg, callback); // If it&apos;s already in the queue, we update it in place, we don&apos;t // move it to the end of the queue. if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); &#125; else &#123; // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;//限制toasts数，最大50 Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; &#125; &#125; &#125; &#125; //获得ToastRecord对象 record = new ToastRecord(callingPid, pkg, callback, duration); //放入mToastQueue中 mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid);//(3)设置该Toast为前台进程 &#125; // If it&apos;s at index 0, it&apos;s the current toast. It doesn&apos;t matter if it&apos;s // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don&apos;t // assume that it&apos;s valid after this. if (index == 0) &#123; showNextToastLocked();//(4)直接显示Toast &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125; &#125; (1)判断是否系统的Toast，源码：12345678 private static boolean isCallerSystem() &#123; return isUidSystem(Binder.getCallingUid()); &#125;private static boolean isUidSystem(int uid) &#123; final int appid = UserHandle.getAppId(uid); //判断pid为系统进程使用的用户id，值为1000，或者为系统进程的手机的用户id，值为1001 return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID || uid == 0); &#125; (2)判断Toast是否在队列当中，源码：123456789101112131415// lock on mToastQueue int indexOfToastLocked(String pkg, ITransientNotification callback) &#123;// IBinder cbak = callback.asBinder(); ArrayList&lt;ToastRecord&gt; list = mToastQueue; int len = list.size(); for (int i=0; i&lt;len; i++) &#123; ToastRecord r = list.get(i); if (r.pkg.equals(pkg) &amp;&amp; r.callback.asBinder() == cbak) &#123; return i; &#125; &#125; return -1; &#125; (3)设置该Toast为前台进程，源码：12345678910111213141516171819// lock on mToastQueue void keepProcessAliveLocked(int pid) &#123; int toastCount = 0; // toasts from this pid ArrayList&lt;ToastRecord&gt; list = mToastQueue; int N = list.size(); for (int i=0; i&lt;N; i++) &#123; ToastRecord r = list.get(i); if (r.pid == pid) &#123; toastCount++; &#125; &#125; try &#123; //设置该Toast为前台进程 mAm.setProcessForeground(mForegroundToken, pid, toastCount &gt; 0); &#125; catch (RemoteException e) &#123; // Shouldn&apos;t happen. &#125; &#125; (4)直接显示Toast，源码：123456789101112131415161718192021222324252627282930313233343536void showNextToastLocked() &#123; //直接取第一个 ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try &#123; record.callback.show();//回调TN类，显示Toast scheduleTimeoutLocked(record);//设置消失 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) &#123; mToastQueue.remove(index); &#125; keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; record = mToastQueue.get(0); &#125; else &#123; record = null; &#125; &#125; &#125; &#125;private void scheduleTimeoutLocked(ToastRecord r) &#123; mHandler.removeCallbacksAndMessages(r);//移除ToastRecord Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); //static final int LONG_DELAY = 3500; // 3.5 seconds //static final int SHORT_DELAY = 2000; // 2 seconds long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; //发送Toast消失的message mHandler.sendMessageDelayed(m, delay); &#125; 从enqueueToast方法可知，先判断是不是系统和合法的Toast，然后判断是否在ToastQueue（这里解释了很多Toast，是一个个显示的），如果存在，只需要更新Toast显示的时间，如果不在，就直接显示，回调给TN类。到这里，知道了Toast是如何显示的。还没有结束，继续追踪mHandler，来到WorkerHandler ：123456789101112131415161718192021222324252627282930313233343536373839404142434445private final class WorkerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_TIMEOUT: handleTimeout((ToastRecord)msg.obj); break; …… &#125; &#125; &#125; private void handleTimeout(ToastRecord record) &#123; if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) &#123; //还是判断Toast是否在队列当中 int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) &#123; cancelToastLocked(index); &#125; &#125; &#125; void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide();//回调TN类，Toast消失 &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don&apos;t worry about this, we&apos;re about to remove it from // the list anyway &#125; mToastQueue.remove(index);//该ToastRecord对象从mToastQueue中移除 keepProcessAliveLocked(record.pid);//设置该Toast为前台进程 if (mToastQueue.size() &gt; 0) &#123; // Show the next one. If the callback fails, this will remove // it from the list, so don&apos;t assume that the list hasn&apos;t changed // after this point. showNextToastLocked();//继续show下个Toast &#125; &#125; 到这里，知道了Toast是如何消失的。Toast核心代码显示和消失源码分析完毕。 总结Toast代码调用只有一行，了解这行代码的背后，有个ToastQueue，进入队列之前，会做一些合法性判断，使用进程间通信进行回调，Handler机制显示和消失。自定义Toast时，需要调用setView，不然show会抛异常，这个从show方法就能得知。至此，Toast源码解析告一段落。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SoundPool使用详解]]></title>
    <url>%2F2017%2F02%2F08%2FSoundPool%2F</url>
    <content type="text"><![CDATA[概述SoundPool类管理和播放用于应用程序的音频资源。 SoundPool是一个示例集合，可以从APK或文件系统中的文件中加载到内存中。SoundPool库使用MediaPlayer服务将音频解码为原始的16位PCM mono或立体声流。这使得应用程序可以使用压缩流进行传输，而不必在回放期间承受CPU负载和解压的延迟。 除了低延迟回放，SoundPool还可以管理一次呈现的音频流的数量。当构造SoundPool对象时，maxStreams参数可以设置从这个单一的声音池中可以播放的最大的流数。SoundPool跟踪活动流的数量。如果超过了最大的流，SoundPool将自动停止先前播放的基于优先级的流，然后在此优先级按时间先后进行。限制最大数量的流有助于限制CPU的负载，降低音频混合将影响可视化或UI性能的可能性。 声音可以通过设置非零循环值来循环。-1会导致声音永远循环。在这种情况下，应用程序必须显式调用stop()函数来停止声音。任何其他非零值都会导致声音重复指定的次数，例如，值3使声音总共播放4次。 回放速率也可以改变。一个回放速率的1.0使声音在原来的频率播放(如果需要的话，重新采样，到硬件输出频率)。回放速率2.0使声音的播放频率是原来的两倍，而回放速率0.5使其播放的频率为原来的一半。回放速率范围是0.5到2.0。 按照优先级低至高，更大的数字即更高的优先级。当调用play()会导致将导致活动流的数量超过maxStreams参数所建立的值时，将会使用优先级。在这种情况下，流分配器将停止最低优先级流。如果有同样低优先级的多个流，它将选择最先播放的流停止。如果新流的优先级低于所有的活动流，那么新的声音将不会播放，play()函数将返回0。 让我们来看看一个典型的用例:一个游戏由几个级别的关卡组成。对于每一个关卡，都有一组独特的声音，只在这个关卡上使用。在这种情况下，当第一关加载时，游戏逻辑应该创建一个新的SoundPool对象。一个关卡的数据可能包含这个级别所使用的声音列表。加载逻辑通过调用适当的soundpool.load()函数列表来迭代。这通常应该在早期进行，以便在需要进行回放之前将音频压缩到原始的PCM格式load需要一定时间，load完成会回调SoundPool.OnLoadCompleteListener。 一旦声音加载并开始播放，应用程序就可以通过调用soundpool . play()触发声音。播放流可以暂停或恢复，应用程序也可以通过调整回放速率对多普勒或综合效果进行实时调整，从而改变音高。 注意，由于资源限制，流可以被停止，所以streamID是对流的一个特定实例的引用。如果一个流被停止以便更高的优先级流播放，这个流就不再有效。但是，应用程序调用方法操作这个streamID也不会报错。这可能有助于简化程序逻辑，因为应用程序不必关心流生命周期。 在我们的示例中，当玩家完成了这个关卡，游戏逻辑应该调用SoundPool.release()释放所有使用的本地资源，然后将SoundPool引用设置为null。如果播放器启动另一个级别，将创建一个新的SoundPool，加载声音，并播放resumes。 综上所述，可以归纳为一下几点： SoundPool使用音效池的概念来管理多个短促的音效 SoundPool主要用于播放一些较适合播放密集、急促而又短暂的声音片段（如游戏音效），与MediaPlayer相比，SoundPool的优势在于CPU资源占用量低和反应延迟小。 SoundPool还支持自行设置声音的品质、音量、 播放比率等参数。 构造方法12345678910111213141516added in API level 1SoundPool (int maxStreams, int streamType, int srcQuality)This constructor was deprecated in API level 21.use SoundPool.Builder instead to create and configure a SoundPool instanceConstructor. Constructs a SoundPool object with the following characteristics:ParametersmaxStreams int: the maximum number of simultaneous streams for this SoundPool objectstreamType int: the audio stream type as described in AudioManager For example, game applications will normally use STREAM_MUSIC.srcQuality int: the sample-rate converter quality. Currently has no effect. Use 0 for the default. 第一个参数maxStreams指定支持同时播放多少个声音；第二个参数streamType指定声音类型（一般为STREAM_MUSIC，参见AudioManager中的定义）：第三个参数srcQuality指定声音品质，暂时没用。现在官方推荐的是是Builder模式方式。 123456789101112Public constructorsSoundPool.Builder()Constructs a new Builder with the defaults format values.Public methodsSoundPool build()SoundPool.Builder setAudioAttributes(AudioAttributes attributes)Sets the AudioAttributes.SoundPool.Builder setMaxStreams(int maxStreams)Sets the maximum of number of simultaneous streams that can be played simultaneously. loadSoundPool提供了如下4个load方法：1234567int load(Context context, int resId, int priority) // Load the sound from the specified APK resource.int load(String path, int priority) //Load the sound from the specified path.int load(AssetFileDescriptor afd, int priority) // Load the sound from an asset file descriptor.int load(FileDescriptor fd, long offset, long length, int priority) // Load the sound from a FileDescriptor. int load(Context context, int resld, int priority)：从 resld 所对应的资源加载声音。一般我们将声音信息保存在res的raw文件夹下 int load(FileDescriptor fd, long offset, long length, int priority)：加载 fd 所对应的文件的offset开始、长度为length的声音。 int load(AssetFileDescriptor afd, int priority)：从afd 所对应的文件中加载声音。 int load(String path, int priority)：从path 对应的文件去加载声音。 上面4个方法中都有一个priority参数，该参数目前还没有任何作用，Android建议将该 参数设为1，保持和未来的兼容性。 上面4个方法加载声音之后，都会返回该声音的的ID，以后程序就可以通过该声音的ID 来播放指定声音。 play123456789101112131415161718192021222324252627playadded in API level 1int play (int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate)Play a sound from a sound ID. Play the sound specified by the soundID. This is the value returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don&apos;t loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.ParameterssoundID int: a soundID returned by the load() functionleftVolume float: left volume value (range = 0.0 to 1.0)rightVolume float: right volume value (range = 0.0 to 1.0)priority int: stream priority (0 = lowest priority)loop int: loop mode (0 = no loop, -1 = loop forever)rate float: playback rate (1.0 = normal playback, range 0.5 to 2.0)Returnsint non-zero streamID if successful, zero if failed 第一个参数为id，id即为放入到soundPool中的顺序。为load方法返回的streamID第二个和第三个参数为左右声道的音量控制。第四个参数为优先级，第五个参数为是否循环播放，0为不循环，-1为循环。最后一个参数为播放比率，从0.5到2，一般为1，表示正常播放。 返回非0的值说明播放成功，返回0说明播放失败。 onLoadComplete123456789101112onLoadCompletevoid onLoadComplete (SoundPool soundPool, int sampleId, int status)Called when a sound has completed loading.ParameterssoundPool SoundPool: SoundPool object from the load() methodsampleId int: the sample ID of the sound loaded.status int: the status of the load operation (0 = success) 第二个参数sampleId 和 SoundPool.load 返回的参数是一样的。 使用流程 创建SoundPool对象，目前官方推荐使用Build模式创建，但是Android源码中依然是之前的方式12private final SoundPool mSoundPool;mSoundPool = new SoundPool(1 /* max streams */,AudioSystem.STREAM_MUSIC /* audioType */, 0 /* quality */); 或者使用官方推荐的Builder模式，因为第三个参数quality实际不起作用，Builder中只有设置两个参数的方法。1234SoundPool soundPool = new SoundPool.Builder() .setMaxStreams(1) .setAudioAttributes(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); 加载音频文件如上面提到的，加载音频文件有四种方法，比较常用的是下面的指定资源id的方式，资源文件一般放在’/res/raw/‘目录下面 1234567private int loadSound(int resId, int priority) &#123; int id = mSoundPool.load(getApplicationContext(), resId, priority); if (id == 0) &#123; Log.e(LOG_TAG, &quot;Unable to open resource&quot;); &#125; return id;&#125; 一个SoundPool类实例能同时管理多个音频，所以可以通过多次调用load(…)方法来加载.如果加载成功则返回一个非0的soundID ，用于播放时指定具体的音频流。在实际应用中，若音频文件过多，那借助HashMap或者数组会方便很多。 12345678910``` soundPool musicId =new SoundPool(12, 0,5);//通过load方法加载指定音频流，并将返回的音频ID放入musicId中musicId.put(1, soundPool.load(this, R.raw.awooga, 1));musicId.put(2, soundPool.load(this, R.raw.evillaugh, 1));musicId.put(3, soundPool.load(this, R.raw.jackinthebox, 1)); 12 // load sounds synchronized(mSoundPool) { for (int index = 0; index &lt; numSounds; index++) { mSounds[index] = loadSound(mTestFiles[index], NORMAL_PRIORITY); mLastSample = mSounds[index]; } mSoundPool.wait(); } 123需要注意的是，流的加载过程是一个将音频解压为原始16位PCM数据，由一个后台线程通过异步处理的过程。因此，初始化后并不能立即播放，需要等待一点时间。加载完成后会回调setOnLoadCompleteListener，所以我们会在本地监听这个回调，在load完成后做相应的操作 mSoundPool.setOnLoadCompleteListener(new LoadCompleteCallback()); private final class LoadCompleteCallback implements android.media.SoundPool.OnLoadCompleteListener { public void onLoadComplete(SoundPool soundPool, int sampleId, int status) { synchronized(mSoundPool) { if (DEBUG) Log.d(LOG_TAG, &quot;Sample &quot; + sampleId + &quot; load status = &quot; + status); if (status != 0) { mLoadStatus = status; } if (sampleId == mLastSample) { mSoundPool.notify(); } } } } 123453. 播放控制资源加载完成后，我们就可以对生成的音频流进行播放控制，播放 int id = mSoundPool.play(mSounds[index], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); 12暂停(pause) mSoundPool.pause(id);12恢复(resume) mSoundPool.resume(id);12停止(stop) mSoundPool.stop(id);123456789101112131415164. 属性设置 通过独立的方法来设置传递给播放函数paly()的一些参数，主要是后面四个参数。 final void setLoop(int streamID, int loop)，设置指定播放流的循环； final void setVolume(int streamID, float leftVolume, float rightVolume)，设置指定播放流的音量； final void setPriority(int streamID, int priority)，设置指定播放流的优先级，上面已说明priority的作用； final void setRate(int streamID, float rate)，设置指定播放流的速率，0.5-2.0；5. 释放资源一般用到以下两个函数 final boolean unload(int soundID)，卸载一个指定的音频资源； final void release()，释放SoundPool中的所有音频资源；1234567891011121314151617181920212223242526272829## 使用心得1、pause()、resume()和stop()是针对播放流操作的，传递的是play()返回的streamID ;2、play()中的priority参数，只在同时播放的流的数量超过了预先设定的最大数量是起作用，管理器将自动终止优先级低的播放流。 如果存在多个同样优先级的流，再进一步根据其创建事件来处理，新创建的流的年龄是最小的，将被终止；3、同时播放多个音频，通过play()函数，成功则返回非0的streamID;4、当设置为无限循环时，需要手动调用stop()来终止播放;5、播放流的优先级(play()中的priority参数)，只在同时播放数超过设定的最大数时起作用;6、程序中不用考虑（play触发的）播放流的生命周期，无效的soundID/streamID不会导致程序错误。无论如何，程序退出时，手动终止播放并释放资源是必要的。 ## 注意事项1. 文件太大，导致加载失败，播放不生效，可以通过OnLoadCompleteListener回调方法的参数status确定是否加载成功，记载成功返回0，失败则返回其他错误码。2. SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此应该避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑使用SoundPool进行播放。3. 虽然SoundPool比MediaPlayer的效果好，但也不是绝对不存在延迟问题，尤其在那些性能不太好的手机中，SoundPool的延迟问题会更严重。## 与MediaPlayer对比响应速度文件大小适合场景SoundPool适合短且对反应速度比较高的情况（游戏音效或按键声等），文件大小一般控制在几十K到几百K，最好不超过1M，可以与MediaPlayer同时播放，SoundPool也可以同时播放多个声音；最终编解码实现与MediaPlayer相同；MediaPlayer只能同时播放一个声音，加载文件有一定的时间，适合文件比较大，响应时间要是不是非常高的场景； ## 实例代码 /* Copyright (c) 2009, Google Inc.* Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at* http://www.apache.org/licenses/LICENSE-2.0* Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.*/ package com.android.soundpooltest; import android.app.Activity;import android.widget.LinearLayout;import android.os.Bundle;import android.view.ViewGroup;import android.widget.Button;import android.view.View;import android.view.View.OnClickListener;import android.view.KeyEvent;import android.media.AudioSystem;import android.media.AudioManager;import android.media.SoundPool;import android.media.SoundPool.OnLoadCompleteListener;import android.util.Log;import java.util.HashMap;import java.lang.Math; import com.android.soundpooltest.R; public class SoundPoolTest extends Activity{ private static final String LOG_TAG = “SoundPoolTest”; private static final boolean DEBUG = true; private static final boolean VERBOSE = false; private TestThread mThread; private static final int[] mTestFiles = new int[] { R.raw.organ441, R.raw.sine441, R.raw.test1, R.raw.test2, R.raw.test3, R.raw.test4, R.raw.test5 }; private final static float SEMITONE = 1.059463094f; private final static float DEFAULT_VOLUME = 0.707f; private final static float MAX_VOLUME = 1.0f; private final static float MIN_VOLUME = 0.01f; private final static int LOW_PRIORITY = 1000; private final static int NORMAL_PRIORITY = 2000; private final static int HIGH_PRIORITY = 3000; private final static int DEFAULT_LOOP = -1; private final static int DEFAULT_SRC_QUALITY = 0; private final static double PI_OVER_2 = Math.PI / 2.0; public SoundPoolTest() {} private final class TestThread extends java.lang.Thread { private boolean mRunning; private SoundPool mSoundPool = null; private int mLastSample; private int mMaxStreams; private int mLoadStatus; private int[] mSounds; private float mScale[]; TestThread() { super(&quot;SoundPool.TestThread&quot;); } private final class LoadCompleteCallback implements android.media.SoundPool.OnLoadCompleteListener { public void onLoadComplete(SoundPool soundPool, int sampleId, int status) { synchronized(mSoundPool) { if (DEBUG) Log.d(LOG_TAG, &quot;Sample &quot; + sampleId + &quot; load status = &quot; + status); if (status != 0) { mLoadStatus = status; } if (sampleId == mLastSample) { mSoundPool.notify(); } } } } private int loadSound(int resId, int priority) { int id = mSoundPool.load(getApplicationContext(), resId, priority); if (id == 0) { Log.e(LOG_TAG, &quot;Unable to open resource&quot;); } return id; } private int initSoundPool(int numStreams) throws java.lang.InterruptedException { if (mSoundPool != null) { if ((mMaxStreams == numStreams) &amp;&amp; (mLoadStatus == 0)) return mLoadStatus; mSoundPool.release(); mSoundPool = null; } // create sound pool mLoadStatus = 0; mMaxStreams = numStreams; mSoundPool = new SoundPool(numStreams, AudioSystem.STREAM_MUSIC, 0); mSoundPool.setOnLoadCompleteListener(new LoadCompleteCallback()); int numSounds = mTestFiles.length; mSounds = new int[numSounds]; // load sounds synchronized(mSoundPool) { for (int index = 0; index &lt; numSounds; index++) { mSounds[index] = loadSound(mTestFiles[index], NORMAL_PRIORITY); mLastSample = mSounds[index]; } mSoundPool.wait(); } return mLoadStatus; } private boolean TestSounds() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin sounds test&quot;); int count = mSounds.length; for (int index = 0; index &lt; count; index++) { int id = mSoundPool.play(mSounds[index], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(450); mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); sleep(50); } if (DEBUG) Log.d(LOG_TAG, &quot;End sounds test&quot;); return true; } private boolean TestScales() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin scale test&quot;); // interate through pitch table int count = mScale.length; for (int step = 0; step &lt; count; step++) { int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[step]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(450); mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); sleep(50); } if (DEBUG) Log.d(LOG_TAG, &quot;End scale test&quot;); return true; } private boolean TestRates() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin rate test&quot;); // start the note int count = mScale.length; int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[0]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Test failed - exiting&quot;); return false; } // modify the pitch for (int step = 1; step &lt; count; step++) { sleep(250); mSoundPool.setRate(id, mScale[step]); if (DEBUG) Log.d(LOG_TAG, &quot;Change rate &quot; + mScale[step]); } mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); if (DEBUG) Log.d(LOG_TAG, &quot;End rate test&quot;); return true; } private boolean TestPriority() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin priority test&quot;); boolean result = true; // play a normal priority looping sound int normalId = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + normalId); if (normalId == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(1000); // play a low priority sound int id = mSoundPool.play(mSounds[1], DEFAULT_VOLUME, DEFAULT_VOLUME, LOW_PRIORITY, DEFAULT_LOOP, 1.0f); if (id != 0) { Log.e(LOG_TAG, &quot;Normal &gt; Low priority test failed&quot;); result = false; mSoundPool.stop(id); } else { sleep(1000); Log.i(LOG_TAG, &quot;Normal &gt; Low priority test passed&quot;); } // play a high priority sound id = mSoundPool.play(mSounds[2], DEFAULT_VOLUME, DEFAULT_VOLUME, HIGH_PRIORITY, DEFAULT_LOOP, 1.0f); if (id == 0) { Log.e(LOG_TAG, &quot;High &gt; Normal priority test failed&quot;); result = false; } else { sleep(1000); Log.i(LOG_TAG, &quot;Stopping high priority&quot;); mSoundPool.stop(id); sleep(1000); Log.i(LOG_TAG, &quot;High &gt; Normal priority test passed&quot;); } // stop normal note Log.i(LOG_TAG, &quot;Stopping normal priority&quot;); mSoundPool.stop(normalId); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;End priority test&quot;); return result; } private boolean TestPauseResume() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin pause/resume test&quot;); boolean result = true; // play a normal priority looping sound int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(2500); // pause and resume sound a few times for (int count = 0; count &lt; 5; count++) { if (DEBUG) Log.d(LOG_TAG, &quot;Pause note &quot; + id); mSoundPool.pause(id); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;Resume note &quot; + id); mSoundPool.resume(id); sleep(1000); } if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); mSoundPool.stop(id); sleep(1000); // play 5 sounds, forces one to be stolen int ids[] = new int[5]; for (int i = 0; i &lt; 5; i++) { ids[i] = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[i]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + ids[i]); if (ids[i] == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(1000); } // pause and resume sound a few times for (int count = 0; count &lt; 5; count++) { if (DEBUG) Log.d(LOG_TAG, &quot;autoPause&quot;); mSoundPool.autoPause(); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;autoResume&quot;); mSoundPool.autoResume(); sleep(1000); } for (int i = 0; i &lt; 5; i++) { if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + ids[i]); mSoundPool.stop(ids[i]); } if (DEBUG) Log.d(LOG_TAG, &quot;End pause/resume test&quot;); return result; } private boolean TestVolume() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin volume test&quot;); // start the note int id = mSoundPool.play(mSounds[0], 0.0f, 1.0f, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[0]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Test failed - exiting&quot;); return false; } // pan from right to left for (int count = 0; count &lt; 101; count++) { sleep(50); double radians = PI_OVER_2 * count / 100.0; float leftVolume = (float) Math.sin(radians); float rightVolume = (float) Math.cos(radians); mSoundPool.setVolume(id, leftVolume, rightVolume); if (DEBUG) Log.d(LOG_TAG, &quot;Change volume (&quot; + leftVolume + &quot;,&quot; + rightVolume + &quot;)&quot;); } mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;End volume test&quot;); return true; } public void run() { if (DEBUG) Log.d(LOG_TAG, &quot;Test thread running&quot;); // initialize mRunning = true; int failures = 0; // initialize pitch table float pitch = 0.5f; mScale = new float[13]; for (int i = 0; i &lt; 13; ++i) { mScale[i] = pitch; pitch *= SEMITONE; } try { // do single stream tests initSoundPool(1); if (!TestSounds()) failures = failures + 1; if (!TestScales()) failures = failures + 1; if (!TestRates()) failures = failures + 1; if (!TestPriority()) failures = failures + 1; if (!TestVolume()) failures = failures + 1; // do multiple stream tests initSoundPool(4); if (!TestPauseResume()) failures = failures + 1; } catch (java.lang.InterruptedException e) { if (DEBUG) Log.d(LOG_TAG, &quot;Test interrupted&quot;); failures = failures + 1; } finally { mRunning = false; } // release sound pool if (mSoundPool != null) { mSoundPool.release(); mSoundPool = null; } // output stats if (DEBUG) Log.d(LOG_TAG, &quot;Test thread exit&quot;); if (failures == 0) { Log.i(LOG_TAG, &quot;All tests passed&quot;); } else { Log.i(LOG_TAG, failures + &quot; tests failed&quot;); } } public void quit() { if (DEBUG) Log.d(LOG_TAG, &quot;interrupt&quot;); interrupt(); while (mRunning) { try { sleep(20); } catch (java.lang.InterruptedException e) { } } if (DEBUG) Log.d(LOG_TAG, &quot;quit&quot;); } } private void startTests() { mThread = new TestThread(); mThread.start(); } protected void onPause() { Log.v(LOG_TAG, &quot;onPause&quot;); super.onPause(); mThread.quit(); mThread = null; } protected void onResume() { Log.v(LOG_TAG, &quot;onResume&quot;); super.onResume(); startTests(); } public void onCreate(Bundle icicle) { super.onCreate(icicle); setVolumeControlStream(AudioManager.STREAM_MUSIC); } } ``` 参考文档 http://www.android-doc.com/reference/android/media/SoundPool.html http://www.cnblogs.com/tgyf/p/4740003.html http://gqdy365.iteye.com/blog/2247793]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SoundPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AAPT详解]]></title>
    <url>%2F2017%2F02%2F08%2Faapt%2F</url>
    <content type="text"><![CDATA[概述Android Asset Packaging Tool. 这两天处理的两个bug,都需要在device/sprd目录下配置不同board的资源文件定义。 这种修改后，一般需要自己verify一个版本，然后烧写版本确认修改是否生效。 但是因为iwhale2的烧机不稳定，我编译了好几个版本都不生效，遂放弃这种方式，打算另辟蹊径。 在肖韵涛的指点下，找到了一个简单的办法：通过verify生成的image进行解压，然后使用aapt命令查看资源文件的定义： 这个方案的两个关键点为解压image和查看apk中的资源文件中的定义 解包image方法1、在终端中进入存放XXX.img文件的目录中 2、输入sudo su，调用Linux的supre user权限，并按提示输入密码 3、建立新文件夹（这里用test）输入解包命令 12$ sudo mount -o rw,loop XXX.img test 4、解包完成 备注：使用上面的方案解压system.img成功，但是解压boot.image失败。 使用aapt工具使用下面的命令可以查看Dialer.apk中的资源文件定义 123aapt dump --values resources Dialer.apk &gt; dialer_dump // 获取Dialer.apk中的所有资源dumpgrep -rn config_voice_call_audiosource dialer_dump 更多使用方法 aapt l[ist] [-v] [-a] file.{zip,jar,apk}List contents of Zip-compatible archive.1.1 列出压缩文件目录aapt l 参数：-v:会以table的形式输出目录，table的表目有：Length、Method、Size、Ratio、Date、Time、CRC-32、Name。其中Method表示压缩形式，有：Deflate及Stored两种，即该Zip目录采用的算法是压缩模式还是存储模式；可以看出resources.arsc、*.png采用压缩模式，而其它采用压缩模式。Ratio表示压缩率。CRC-32未明其意，Sodino盼指教。 -a:会详细输出所有目录的内容。效果图：aapt_list.JPGlist aapt d[ump] [–values] WHAT file.{apk} [asset [asset …]]badging Print the label and icon for the app declared in APK.permissions Print the permissions from the APK.resources Print the resource table from the APK.configurations Print the configurations in the APK.xmltree Print the compiled xmls in the given assets.xmlstrings Print the strings of the given compiled xml assets. 2.1 查看apk包的packageName、versionCode、applicationLabel、launcherActivity、permission等各种详细信息aapt dump badging 效果图：aapt_dump_badging.JPGbadging 2.2 查看权限aapt dump permissions 效果图：aapt_dump_permissions.JPG permission 2.3 查看资源列表aapt dump resources 一般都会输出很多的信息，如要全部查看，请用下面这两句：aapt dump resources &gt; sodino.txtsodino.txt这样会把所有的信息通过重定向符”&gt;”输出到sodino.txt文件中，然后再打开该文件即可查看。 2.4 查看apk配置信息aapt dump configurations 2.5 查看指定apk的指定xml文件。aapt dump xmltree res/.xml以树形结构输出的xml信息。aapt dump xmlstrings res/.xml输出xml文件中所有的字符串信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// man aaptaapt(1) General Commands Manual aapt(1)NAME aapt - Android Asset Packaging ToolSYNOPSIS aapt command [ options ] files ... aapt l[ist] [-v] [-a] file.&#123;zip,jar,apk&#125; List contents of Zip-compatible archive. aapt d[ump] [--values] WHAT file.&#123;apk&#125; [asset [asset ...]] strings Print the contents of the resource table string pool in the APK. badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. aapt p[ackage] [-d] [-f] [-m] [-u] [-v] [-x] [-z] [-M AndroidManifest.xml] [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] [--debug-mode] [--min-sdk-version VAL] [--target-sdk-version VAL] [--app-version VAL] [--app-version-name TEXT] [--custom-package VAL] [--rename-manifest-package PACKAGE] [--rename-instrumentation-target-package PACKAGE] [--utf16] [--auto-add-overlay] [--max-res-version VAL] [-I base-package [-I base-package ...]] [-A asset-source-dir] [-G class-list-file] [-P public-definitions-file] [-S resource-sources [-S resource-sources ...]] [-F apk-file] [-J R-file-dir] [--product product1,product2,...] [-c CONFIGS] [--preferred-configurations CONFIGS] [raw-files-dir [raw-files-dir] ...] [--output-text-symbols DIR] Package the android resources. It will read assets and resources that are supplied with the -M -A -S or raw-files-dir arguments. The -J -P -F and -R options control which files are output. aapt r[emove] [-v] file.&#123;zip,jar,apk&#125; file1 [file2 ...] Delete specified files from Zip-compatible archive. aapt a[dd] [-v] file.&#123;zip,jar,apk&#125; file1 [file2 ...] Add specified files to Zip-compatible archive. aapt c[runch] [-v] -S resource-sources ... -C output-folder ... Do PNG preprocessing on one or several resource folders and store the results in the output folder. aapt s[ingleCrunch] [-v] -i input-file -o outputfile Do PNG preprocessing on a single file. aapt v[ersion] Print program version.DESCRIPTION The Android Asset Packaging Tool (aapt) takes your application resource files, such as the AndroidManifest.xml file and the XML files for your Activities, and compiles them. An R.java is also produced so you can reference your resources from your Java code.OPTIONS A summary of options is included below. -a print Android-specific data (resources, manifest) when listing -c specify which configurations to include. The default is all configurations. The value of the parameter should be a comma separated list of configuration values. Locales should be specified as either a language or language-region pair. Some examples: en port,en port,land,en_US If you put the special locale, zz_ZZ on the list, it will perform pseudolocalization on the default locale, modifying all of the strings so you can look for strings that missed the internationalization process. For example: port,land,zz_ZZ -d one or more device assets to include, separated by commas -f force overwrite of existing files -g specify a pixel tolerance to force images to grayscale, default 0 -j specify a jar or zip file containing classes to include -k junk path of file(s) added -m make package directories under location specified by -J -u update existing packages (add new, replace older, remove deleted files) -v verbose output -x create extending (non-application) resource IDs -z require localization of resource attributes marked with localization=&quot;suggested&quot; -A additional directory in which to find raw asset files -G A file to output proguard options into. -F specify the apk file to output -I add an existing package to base include set -J specify where to output R.java resource constant definitions -M specify full path to AndroidManifest.xml to include in zip -P specify where to output public resource definitions -S directory in which to find resources. Multiple directories will be scanned and the first match found (left to right) will take precedence. -0 specifies an additional extension for which such files will not be stored compressed in the .apk. An empty string means to not compress any files at all. --debug-mode inserts android:debuggable=&quot;true&quot; in to the application node of the manifest, making the application debuggable even on production devices. --min-sdk-version inserts android:minSdkVersion in to manifest. If the version is 7 or higher, the default encoding for resources will be in UTF-8. --target-sdk-version inserts android:targetSdkVersion in to manifest. --max-res-version ignores versioned resource directories above the given value. --values when used with &quot;dump resources&quot; also includes resource values. --version-code inserts android:versionCode in to manifest. --version-name inserts android:versionName in to manifest. --custom-package generates R.java into a different package. --extra-packages generate R.java for libraries. Separate libraries with &apos;:&apos;. --generate-dependencies generate dependency files in the same directories for R.java and resource package --auto-add-overlay Automatically add resources that are only in overlays. --preferred-configurations Like the -c option for filtering out unneeded configurations, but only expresses a preference. If there is no resource available with the preferred configuration then it will not be stripped. --rename-manifest-package Rewrite the manifest so that its package name is the package name given here. Relative class names (for example .Foo) will be changed to absolute names with the old package so that the code does not need to change. --rename-instrumentation-target-package Rewrite the manifest so that all of its instrumentation components target the given package. Useful when used in conjunction with --rename-manifest-package to fix tests against a package that has been renamed. --product Specifies which variant to choose for strings that have product variants --utf16 changes default encoding for resources to UTF-16. Only useful when API level is set to 7 or higher where the default encoding is UTF-8. --non-constant-id Make the resources ID non constant. This is required to make an R java class that does not contain the final value but is used to make reusable compiled libraries that need to access resources. --error-on-failed-insert Forces aapt to return an error if it fails to insert values into the manifest with --debug-mode, --min-sdk-version, --target-sdk-version --version-code and --version-name. Insertion typically fails if the manifest already defines the attribute. --output-text-symbols Generates a text file containing the resource symbols of the R class in the specified folder. --ignore-assets Assets to be ignored.AUTHOR aapt was written by The Android Open Source Project. October 15, 2014 aapt(1) Manual page aapt(1) line 127/185 (END) (press h for help or q to quit)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AAPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Markdown]]></title>
    <url>%2F2017%2F01%2F23%2Fmarkdown-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. 声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」–By @riku 注： 本项目托管于 GitCafe上，请通过”派生”和”合并请求”来帮忙改进本项目。 Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（` ），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android SharedPreferences 详解]]></title>
    <url>%2F2017%2F01%2F08%2FSharedPreferences%2F</url>
    <content type="text"><![CDATA[概述 Store private primitive data in key-value pairs. SharedPreferences是一种轻量级的数据存储方式。 用键值对的方式把简单数据类型（boolean、int、float、long和String）存储在应用程序的私有目录下(data/data/包名/shared_prefs/)自己定义的xml文件中。例如：1&lt;string name=&quot;voicemail_notification_ringtone_1&quot;&gt;content://media/internal/audio/media/14&lt;/string&gt; 接口SharedPreferences接口主要负责读取应用程序的Preferences数据 常用的属性和方法1234567public abstract boolean contains (String key) // 判断SharedPreferences是否包含特定key的数据public abstract SharedPreferences.Editor edit () // 返回一个Edit对象用于操作SharedPreferencespublic abstract Map&lt;String, ?&gt; getAll () // 获取SharedPreferences数据里全部的key-value对getXXX(String key,XXX defvlaue) //获取SharedPreferences数据指定key所对应的value，如果该key不存在，返回默认值defValue。其中XXX可以是boolean、float、int、long、String等基本类型的值 EditorSharedPreference是一个接口，而且在这个接口里并没有提供写入数据和读取数据的能力。但是在其内部有一个Editor内部的接口，Edit这个接口有一系列的方法用于操作SharedPreference。12345678public abstract SharedPreferences.Editor clear () // 清空SharedPreferences里所有的数据public abstract boolean commit () // 当Editor编辑完成后，调用该方法可以提交修改，而且必须要调用这个数据才修改public abstract SharedPreferences.Editor putXXX (String key, boolean XXX)// 向SharedPreferences存入指定的key对应的数据，其中XXX可以是boolean、float、int、long、String等基本类型的值public abstract SharedPreferences.Editor remove (String key) // 删除SharedPreferences里指定key对应的数据项 获取实例SharedPreferences是一个接口，程序是无法创建SharedPreferences实例的，可以通过123456Context.getSharedPreferences(String name,int mode) // 来得到一个SharedPreferences实例// name：是指文件名称，不需要加后缀.xml，系统会自动为我们添加上。一般这个文件存储在/data/data/&lt;package name&gt;/shared_prefs下// mode：是指定读写方式，其值有三种，分别为：// Context.MODE_PRIVATE：指定该SharedPreferences数据只能被本应用程序读、写// Context.MODE_WORLD_READABLE：指定该SharedPreferences数据能被其他应用程序读，但不能写// Context.MODE_WORLD_WRITEABLE：指定该SharedPreferences数据能被其他应用程序读写。 读写其他应用SharedPreferences要实现这样的功能，我们必须要保证要访问的那个应用程序的SharedPreferences的访问权限要是MODE_WORLD_READABLE，这表明该SharedPreferences可以被其他应用程序读取，如果指定的MODE_WORLD_WRITEABLE表明该SharedPreferences可以被其他应用程序读取写入实现思路如下：1、 获得其他应用程序对应的Context 2、 通过这个Context得到这个应用程序的SharedPreferences，然后再利用这个SharedPreferences读取内容以上一例的SharedPreference为例。12345678try &#123; othercontext = createPackageContext(&quot;com.learn.android&quot;, Context.CONTEXT_IGNORE_SECURITY); sp = othercontext.getSharedPreferences(&quot;preferences&quot;,othercontext.MODE_PRIVATE); &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 注意事项 编辑完SharedPreferences一定要记得调用Editor的commit()方法，否则不会将数据写入到文件里的。 关键点1、 如何得到SharedPreferences SharedPreferences preferences=getPreferences(“test”,MODE_PRIVATE); 2、 如何编辑SharedPreferences 得到Editor对象实例 SharedPreferences.Editor editor=preferences.editor(); 3、 SharedPreferences的存储位置 /data/data//shared_prefs 官方文档1234567891011121314The SharedPreferences class provides a general framework that allows you to save and retrieve persistent key-value pairs of primitive data types. You can use SharedPreferences to save any primitive data: booleans, floats, ints, longs, and strings. This data will persist across user sessions (even if your application is killed).To get a SharedPreferences object for your application, use one of two methods: getSharedPreferences() - Use this if you need multiple preferences files identified by name, which you specify with the first parameter. getPreferences() - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don&apos;t supply a name.To write values: Call edit() to get a SharedPreferences.Editor. Add values with methods such as putBoolean() and putString(). Commit the new values with commit()To read values, use SharedPreferences methods such as getBoolean() and getString(). Here is an example that saves a preference for silent keypress mode in a calculator:12345678910111213141516171819202122232425262728public class Calc extends Activity &#123; public static final String PREFS_NAME = &quot;MyPrefsFile&quot;; @Override protected void onCreate(Bundle state)&#123; super.onCreate(state); . . . // Restore preferences SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); boolean silent = settings.getBoolean(&quot;silentMode&quot;, false); setSilent(silent); &#125; @Override protected void onStop()&#123; super.onStop(); // We need an Editor object to make preference changes. // All objects are from android.context.Context SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); SharedPreferences.Editor editor = settings.edit(); editor.putBoolean(&quot;silentMode&quot;, mSilentMode); // Commit the edits! editor.commit(); &#125;&#125; 存储位置 data/date目录下的 data/user_de/0 目录下 比如telecom 1234567sp9832a_2h11_volte:/data/user_de/0/com.android.server.telecom/shared_prefs # cat com.android.server.telecom_preferences.xml &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;&lt;map&gt; &lt;boolean name=&quot;silent_call_by_flipping_key&quot; value=&quot;true&quot; /&gt; &lt;boolean name=&quot;fade_in_key&quot; value=&quot;false&quot; /&gt;&lt;/map&gt; /data/user/0 下 12345方法在ContextImpl中的getSharedPreferencesPath()09-07 15:49:41.750 1431 1431 D dhy : getSharedPreferencesPath == /data/user/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml09-07 15:49:41.750 1431 1431 D dhy : getSharedPreferencesPath == /data/user_de/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml09-07 15:49:41.751 1431 1431 D dhy : getSharedPreferencesPath == /data/user_de/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RegistrantList 详解]]></title>
    <url>%2F2016%2F12%2F18%2FRegistrantList%2F</url>
    <content type="text"><![CDATA[概述这其实是观察者模式的一种实现形式 先明确两个身份 1.RefistrantList 通知者 2.Registrant 观察者，这是一个一对多的关系，在有事件更新时，凡是在名单上登记过的对象，都会收到通知。RegistrantList通知者支持对通知者的增加（add/addUnique）删除（remove），并且能够发出通知（notifyRegitrants）；而Registrant作为观察者，响应通知者发出的notifyRegistrant通知，并由其internalNotifyRegistrants方法响应通知者发出的通知。整体上这个消息注册机制分为两部分，消息注册和消息通知。其总体思想是：一个对象中开辟一个空间用于存放Message，当调用regist方法时将Message存放进去，当其调用notify方法时将所有Message取出并发送到MessageQueue中等待处理。 下面我们以android 5.0上 来电流程为例讲一下RegistrantList机制的使用。 注册为观察者PstnIncomingCallNotifier这个类中调用mphoneBase中的registerForNewRingingConnection方法注册为观察者，android中的注册为观察者的方法通常写为registerFor***()形式，即为某事件注册消息通知。 PstnIncomingCallNotifier.java 12345678910111213141516private void registerForNotifications() &#123; Phone newPhone = mPhoneProxy.getActivePhone(); if (newPhone != mPhoneBase) &#123; unregisterForNotifications(); if (newPhone != null) &#123; Log.i(this, &quot;Registering: %s&quot;, newPhone); mPhoneBase = newPhone; mPhoneBase.registerForNewRingingConnection( mHandler, EVENT_NEW_RINGING_CONNECTION, null); mPhoneBase.registerForCallWaiting( mHandler, EVENT_CDMA_CALL_WAITING, null); mPhoneBase.registerForUnknownConnection(mHandler, EVENT_UNKNOWN_CONNECTION, null); &#125; &#125;&#125; 然后我们看注册为观察者具体是怎么实现的： 调用addUnique添加为观察者 phoneBase.java 1234567// Inherited documentation suffices.@Overridepublic void registerForNewRingingConnection( Handler h, int what, Object obj) &#123; checkCorrectThread(h); mNewRingingConnectionRegistrants.addUnique(h, what, obj);&#125; 而这个mNewRingingConnectionRegistrants是什么呢？ 1protected final RegistrantList mNewRingingConnectionRegistrants = new RegistrantList(); mNewRingingConnectionRegistrants是一个RegistrantList 。 添加到通知者列表。用传进来的三个参数新建一个观察者，然后将其添加到通知者所要通知对象的列表中 RefistrantList.java 1234567public synchronized voidaddUnique(Handler h, int what, Object obj)&#123; // if the handler is already in the registrant list, remove it remove(h); add(new Registrant(h, what, obj));&#125; 3.1新建一个Registrant观察者 1234567publicRegistrant(Handler h, int what, Object obj)&#123; refH = new WeakReference(h);//Handler 泛型WeakReference this.what = what;//消息类型 userObj = obj;//Object数据对象，用于封装传递的数据&#125; 3.2添加到通知者须通知的对象的列表中，用列表保存观察者。registrants对象就是一个ArrayList。到此我们看到，RegistrantList维护了一个Registrants对象，而Registrants管理了多个Registrant。 123456public synchronized voidadd(Registrant r)&#123; removeCleared(); registrants.add(r);&#125; 自此消息的注册完成。 发出通知1.handlePollCalls方法根据RIL发出的Call List对象判断Call的状态，并发出不同的通知，有新的来电将执行： phone.notifyNewRingingConnection; 123456789101112 Connection newRinging = null; //or waiting handlePollCalls()&#123; ... if (newRinging != null) &#123; mPhone.notifyNewRingingConnection(newRinging); &#125;2.GSMPhone.java public void notifyNewRingingConnection(Connection c) &#123; super.notifyNewRingingConnectionP(c); &#125; 调用父类 PhoneBase.java notifyNewRingingConnectionP()发出来电通知 mNewRingingConnectionRegistrants.notifyRegistrants(ar);前面有说过mNewRingingConnectionRegistrants是一个RegistrantList通知者 1234567891011/** * Notify registrants of a new ringing Connection. * Subclasses of Phone probably want to replace this with a * version scoped to their packages */public void notifyNewRingingConnectionP(Connection cn) &#123; if (!mIsVoiceCapable) return; AsyncResult ar = new AsyncResult(null, cn, null); mNewRingingConnectionRegistrants.notifyRegistrants(ar);&#125; 通知者RegistrantList.java通知者调用内部的通知观察者的方法 12345public /*synchronized*/ voidnotifyRegistrants(AsyncResult ar)&#123; internalNotifyRegistrants(ar.result, ar.exception);&#125; 一般来说观察者不止一个，所以用for循环遍历感兴趣的观察者，调用观察内部的internalNotifyRegistrant()响应通知 12345678private synchronized voidinternalNotifyRegistrants (Object result, Throwable exception)&#123; for (int i = 0, s = registrants.size(); i &lt; s ; i++) &#123; Registrant r = (Registrant) registrants.get(i); r.internalNotifyRegistrant(result, exception); &#125;&#125; s = registrants.size() 获得观察者数量。响应通知消息 Registrant.java响应通知 1234567891011121314151617/*package*/ voidinternalNotifyRegistrant (Object result, Throwable exception)&#123; Handler h = getHandler(); if (h == null) &#123; clear(); &#125; else &#123; Message msg = Message.obtain(); msg.what = what; msg.obj = new AsyncResult(userObj, result, exception); h.sendMessage(msg); &#125;&#125; 这个消息是一开始注册为观察者就携带进去的 12345678910111213141516171819 private final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case EVENT_NEW_RINGING_CONNECTION: handleNewRingingConnection((AsyncResult) msg.obj); break; case EVENT_CDMA_CALL_WAITING: handleCdmaCallWaiting((AsyncResult) msg.obj); break; case EVENT_UNKNOWN_CONNECTION: handleNewUnknownConnection((AsyncResult) msg.obj); break; default: break; &#125; &#125; &#125;;` 至于响应通知做了什么工作不是这次的重点。 补充Message msg = Message.obtain():Handler h = getHandler();h.sendMessage(msg); 从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool = null 的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 使用Handler中的sendMessage (Message msg)方式来发送消息. 我们可以知道android 中发送消息不管是Message中的几种重载的obtain()方式，还是Handler中的几种重载的sendMessage最终都是通过Handler.sendMessage来发送的,而Handler中的几种sendMessage()重载方法最终都会调用到sendMessageAtTime()方法来完成消息的入队操作。 发送一个消息到消息队列的对尾，它会在处理这个时间的线程中的handleMessage(Message),方法中被接受到并且处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RegistrantList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Proguard 注解]]></title>
    <url>%2F2016%2F11%2F18%2FProguard%2F</url>
    <content type="text"><![CDATA[[TOC] 使用proguard语法 之前大家在开发插件时可能会遇到调不到Dialer中的方法，之前的解决方案是去直接修改proguard.flags文件,这个需要大家去学习 proguard的声明语法，感兴趣的可以学习下。 例如防止DialerApplication中的所以方法被混淆，可以使用下面的语法声明 -keep class com.android.dialer.DialerApplication {*;} 如果是防止一个类中的某个方法不被混淆，可以使用下面的语法声明： -keepclasseswithmembers class com.android.incallui.CallCardFragment { public void setCallNumberAndLabel(java.lang.String , java.lang.String ); } 其中setCallNumberAndLabel是 我在CallCardFragment中新增的方法 public void setCallNumberAndLabel(String number, String label) 上面的去混淆方法都需要我们对proguard的语法有一定的了解，但是如果使用注解的话会更加简单，就不需要每一次去混淆都去修改 proguard.flags文件了。 使用注解 如果只是想一个方法不被混淆，可以直接在方法定义处加上注解@NeededForReflection即可，例如原生在DialpadFragment就 有用到的: @NeededForReflectionpublic void setYFraction(float yFraction) { setTranslationY(yFraction * getHeight());} 同样，不混淆一个属性，也是在其定义处加上@NeededForReflection注解即可。 但是这个注解只适用于不混淆方法和属性，而不能不混淆方法，原因就是在于proguard.flags文件中只声明不混淆类中的方法和属性，可能是原生不 想不混淆整个类（一般也没有这种需求），具体原因请看下面的NeededForReflection注解原理分析。 @NeededForReflection原理 实际上，@NeededForReflection这个注解的原理同样是使用proguard的语法声明的。具体的步骤如下： 1）. 先定义一个注解：./src/com/android/incallui/NeededForReflection.java @Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD})public @interface NeededForReflection {} 2）. 然后在proguard.flags文件中声明： Any class or method annotated with NeededForTesting or NeededForReflection.-keepclassmembers class {@com.android.contacts.common.test.NeededForTesting ;@com.android.incallui.NeededForReflection *;} 可以看到上面的声明语法只是不混淆类的成员，如果@NeededForReflection声明的类不被混淆的话，需要在 proguard.flags中添加如下声明： -keep @com.android.incallui.NeededForReflection class {;} 综上，建议之后在需要不混淆一个方法或者属性时使用@NeededForReflection 注解，如果需要不混淆整个类（一般用不到），再去在proguard.flags文件添加声明]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Preference 详解]]></title>
    <url>%2F2016%2F10%2F18%2FPreference%2F</url>
    <content type="text"><![CDATA[概述preference非常适合于参数设置功能。实际上，它也确实是干这个的，我们通过使用preference可以迅速的将某些值保存进xml文件中，然后我们可以读取这些设置信息进行相应的操作。为了简化与preference相关的应用开发，android为我们提供了一系列的api来帮助我们。主要有 PreferenceActivity，ListPreference,EditTextPreference,CheckBoxPreference,RingtonePreference CheckBoxPreference1234567891011121314151617private static final String BUTTON_AUTOMATIC_RECORDING = &quot;automatic_recording_key&quot;;mAutomaticRecording = (CheckBoxPreference) findPreference(BUTTON_AUTOMATIC_RECORDING); if (mAutomaticRecording != null) &#123; mAutomaticRecording.setOnPreferenceChangeListener(this); &#125; /** * Supports onPreferenceChangeListener to look for preference changes. * * @param preference The preference to be changed * @param objValue The value of the selection, NOT its localized display value. */ @Override public boolean onPreferenceChange(Preference preference, Object objValue) &#123; // if (preference == mVibrateWhenRinging) &#123; // 在这里加额外的判断去处理数据 return true; // true to update the state of the preference with the new value. &#125; 12345678910111213//xml: &lt;PreferenceCategory android:key=&quot;dialer_general_call_recording_settings_category_key&quot; android:title=&quot;@string/call_recording_setting_title&quot; android:persistent=&quot;false&quot; &gt; &lt;CheckBoxPreference android:key=&quot;automatic_recording_key&quot; android:title=&quot;@string/automatic_recording_title&quot; android:persistent=&quot;true&quot; android:defaultValue=&quot;false&quot; /&gt; &lt;/PreferenceCategory&gt; android:persistent=”true”Preference 可以自动保存状态值，保存是以 xml 文件形式保存的，保存路径在 /data/data/packageName/shared_prefs/×××.xml设置这个属性为 true，android 就会为你自动保存,否则，不保存 1onclick --&gt; setchecked(newvalue) --&gt; persistboolean(checked) --&gt; 然后调用 PreferenceManager 相关的方法获取 SharedPreference 来保存文件 如何动态获取 CheckBoxPreerence 的值–&gt; 实现 OnSharedPreferenceChangeListener 接口12 Preferencescreen Preferencescreen中启动activity 123456789101112例如general_setting.xml中有如下片段 &lt;PreferenceScreen android:enabled=&quot;true&quot; android:key=&quot;fast_dial_preference_key&quot; android:persistent=&quot;false&quot; android:title=&quot;@string/fast_dial_title&quot; &gt; &lt;intent android:action=&quot;android.intent.action.MAIN&quot; android:targetPackage=&quot;com.android.phone&quot; android:targetClass=&quot;com.sprd.phone.settings.fastdial.FastDialSettingActivity&quot; /&gt; &lt;/PreferenceScreen&gt; android:targetPackage=”com.android.phone” // 工程的包名 android:targetClass=”com.sprd.phone.settings.fastdial.FastDialSettingActivity” // 要启动的类 一般情况下，这样就ok了，点击对应的Preference就能够启动对应的activity，然而仅仅这样有时这样，并不一定能够启动对应的activity，因为它与回调函数onPreferenceTreeClick有关 12345678910111213141516171819202122/** * Click listener for toggle events. */@Overridepublic boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) &#123; /** SPRD: IP_DIAL&amp;FAST_DIAL_FEATURE BEGIN @&#123; */ String key = preference.getKey(); /** SPRD: END @&#125; */ if (preference == mPlayDtmfTone) &#123; Settings.System.putInt(mContext.getContentResolver(), Settings.System.DTMF_TONE_WHEN_DIALING, mPlayDtmfTone.isChecked() ? 1 : 0); &#125; else if (preference == mRespondViaSms) &#123; // Needs to return false for the intent to launch. return false; &#125; /** SPRD: IP_DIAL&amp;FAST_DIAL_FEATURE BEGIN @&#123; */ else if (BUTTON_IP_DIALING_KAY.equals(key) || BUTTON_FAST_DIAL_KAY.equals(key)) &#123; return false; &#125; /** SPRD: END @&#125; */ return true;&#125; 当返回值为true时,你怎么点击Preference都不会跳转到activity的，只有等到它的返回值为false的时候，才可以正常跳转，因为点击某一个Preference的真正实现在Preference.java的performClick函数中1234567891011121314151617181920212223242526272829303132333435/** * Called when a click should be performed. * * @param preferenceScreen A &#123;@link PreferenceScreen&#125; whose hierarchy click * listener should be called in the proper order (between other * processing). May be null. * @hide */public void performClick(PreferenceScreen preferenceScreen) &#123; if (!isEnabled()) &#123; return; &#125; onClick(); if (mOnClickListener != null &amp;&amp; mOnClickListener.onPreferenceClick(this)) &#123; return; &#125; PreferenceManager preferenceManager = getPreferenceManager(); if (preferenceManager != null) &#123; PreferenceManager.OnPreferenceTreeClickListener listener = preferenceManager .getOnPreferenceTreeClickListener(); if (preferenceScreen != null &amp;&amp; listener != null &amp;&amp; listener.onPreferenceTreeClick(preferenceScreen, this)) &#123; return; &#125; &#125; if (mIntent != null) &#123; Context context = getContext(); context.startActivity(mIntent); &#125;&#125; 当点击某个Preference时的调用流程是AdapterView.performItemClick –&gt; PreferenceScreen.onItemClick–&gt; Preference.performClick –&gt; PreferenceActivity.onPreferenceTreeClick当onPreferenceTreeClick返回true的时候就直接return了，没有走下面启动activity的地方了.因此要使一个Preference能够正常跳转到另外一个activity有两个条件，一是xml里面是否设置正确，第二是调用该xml的java类是否在onPreferenceTreeClick这个函数需要返回false。 PreferenceScreen监听子项的刷新有个PreferenceScreen，他有一些个子项目。它的Summary需要根据子项的设置来改变的，所以需要监听子项的刷新事件。preferenceScreen.setOnPreferenceChangeListener( ) 是不管用的。 不过，它的RootAdapter在子项更新时却能够收到事件，所以就直接上代码了123456789// Auto update Summary when related preference changed.preferenceScreen.getRootAdapter().registerDataSetObserver(new DataSetObserver() &#123; @Override public void onChanged() &#123; super.onChanged(); // Update Summary... &#125;&#125;); 收到这个事件的时候，Preference的Value已经改变了，所以就可以放心地读取新的值了。Tips：这时可以使用Handler.post()方法。 ListPreferencePreferenceActivity]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Preference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova原生插件之Android消息通知]]></title>
    <url>%2F2016%2F09%2F21%2FCordova%E6%8F%92%E4%BB%B6%E4%B9%8Bandroid%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[概述架构插件目录结构如下：notifyplugin * plugin.xml * www/notifysrv.js * src/android/NotifysrvPlugin.java * libs/android-support-v4.jar 这个需要自己手动添加到android的libs文件夹下、或者通过自定义hooks文件实现 plugin.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;plugin xmlns="http://apache.org/cordova/ns/plugins/1.0" id="com.dhyuestc.cordova.plugin" version="0.0.1"&gt; &lt;name&gt;NotifysrvPlugin&lt;/name&gt; &lt;description&gt;NotifysrvPlugin Description&lt;/description&gt; &lt;author&gt;dhyuestc&lt;/author&gt; &lt;license&gt;Apache 2.0 License&lt;/license&gt; &lt;engines&gt; &lt;engine name="cordova" version="&gt;=3.0.0" /&gt; &lt;/engines&gt; &lt;js-module src="www/notifysrv.js" name="notifysrv"&gt; &lt;clobbers target="Notify" /&gt; &lt;/js-module&gt; &lt;platform name="android"&gt; &lt;source-file src="src/android/NotifysrvPlugin.java" target-dir="src/com/dhyuestc/cordova/plugin" /&gt; &lt;config-file target="res/xml/config.xml" parent="/*"&gt; &lt;feature name="NotifysrvPlugin"&gt; &lt;param name="android-package" value="com.dhyuestc.cordova.plugin.NotifysrvPlugin"/&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file target="AndroidManifest.xml" parent="/*"&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;/config-file&gt; &lt;/platform&gt;&lt;/plugin&gt; NotifysrvPlugin.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.dhyuestc.cordova.plugin;import org.apache.cordova.CordovaPlugin;import org.apache.cordova.CallbackContext;import org.apache.cordova.CordovaWebView;import org.apache.cordova.CordovaInterface;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import android.content.Context;import android.support.v4.app.NotificationCompat;public class NotifysrvPlugin extends CordovaPlugin &#123; public static final String TAG = "NotifysrvPlugin"; public static final String iconname = "icon"; //icon res name public NotificationManager nm; public Context m_context; public void initialize(CordovaInterface cordova, CordovaWebView webView) &#123; super.initialize(cordova, webView); m_context = this.cordova.getActivity().getApplicationContext(); nm = (NotificationManager) m_context.getSystemService(android.content.Context.NOTIFICATION_SERVICE); // 首先要获得通知服务 &#125; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException &#123; if ("send".equals(action)) &#123; String title = args.getString(0); String text = args.getString(1); PendingIntent m_PendingIntent=PendingIntent.getActivity(this.cordova.getActivity(), 0, this.cordova.getActivity().getIntent(), 0); int iconResID = m_context.getResources().getIdentifier(iconname,"drawable", m_context.getPackageName()); Notification notification = new NotificationCompat.Builder(m_context) // 构造器 .setContentTitle(title) .setContentText(text) .setDefaults(Notification.DEFAULT_ALL) //设置默认铃声，震动等 .setSmallIcon(iconResID) .setContentIntent(m_PendingIntent) // Supply a PendingIntent to send when the notification is clicked. .setAutoCancel(true) // .setLargeIcon(aBitmap) .build(); // Combine all of the options that have been set and return a new Notification object. nm.notify(1, notification); // callbackContext.success(); return true; &#125; return false; &#125;&#125;/***public void notify (int id, Notification notification) * Post a notification to be shown in the status bar. * If a notification with the same id has already been posted by your application and has not yet been canceled, * it will be replaced by the updated information.**Parameters* id An identifier for this notification unique within your application. * notification A Notification object describing what to show the user. Must not be null. **/```bashvar argscheck = require('cordova/argscheck');var exec = require('cordova/exec');var Notify = function() &#123;&#125;;Notify.prototype.send = function(message, success, error) &#123; //argscheck.checkArgs('AFF', 'notify.send', arguments); console.log("send notification["+message[1]+"]"); if(!message) error &amp;&amp; error("please input message"); else exec(success, error, 'NotifysrvPlugin', 'send', message);&#125;;var notify = new Notify();module.exports = notify; 安装插件将插件加入cordova工程的办法进入CMD，进入cordova工程文件夹，然后输入如下命令1cordova plugin add [插件目录] 使用方法12345 Notify.send(msg,function()&#123; //success code &#125;,function(msg)&#123; // error &#125;); 注意问题 libs/android-support-v4.jar 这个需要自己手动添加到android的libs文件夹下、或者通过自定义hooks文件实现 参考文献]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2016%2F09%2F21%2Fgit%2F</url>
    <content type="text"><![CDATA[[TOC] 概述Git是目前世界上最先进的分布式版本控制系统。下面是对常用的git命令的总结归纳。基于ubuntu系统。 安装Debian/Ubuntu1$ sudo apt-get install git 其他平台详见官方Downloads地址 常用命令创建版本库123$ mkdir gitlibrary // 本地创建一个git目录$ cd gitlibrary$ git init 将文件添加到git库1$ git add readme.txt 将文件提交到仓库1$ git commit -m "wrote a readme file" // -m后面输入的是本次提交的说明内容 删除仓库中的文件1$ git rm 查看git库状态1$ git status 查看差异1$ git diff 显示从最近到最远的提交日志123$ git log$ git log --pretty=oneline // 简化输出信息$ git log --graph --pretty=oneline --abbrev-commit // 查看分支历史 回退修改在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上多个版本写多个^比较容易数不过来，所以写成HEAD~n,表示向上第n个版本 1$ git reset --hard HEAD^ 1--hard // 指定回到未来的某个版本1$ git reset --hard 3628164 // 3628164代表某次提交的commit id，也可以不写全，git会自动补全，当然，最好是写全，以免多个提交的前面数字一样git无法区分 查看使用过的每一次命令1git reflog 丢弃工作区的修改1git checkout -- file // 没有--，就变成了“切换到另一个分支”的命令.事实上不加-- 指定文件的路径话也是可以的。 关联一个远程库1234$ git remote add origin git@server-name:path/repo-name.git```bash关联后，使用下面的命令第一次推送master分支的所有内容； git push -u origin master12345### 将本地修改推送到远程库```bash$ git push origin master 其中远程库的地址信息master可以在本地库的.git/config文件中查看,例如 123[branch "m-android-dev"] remote = origin merge = android-m 上面的”m-android-dev”即为本地库所指向的远程库分支，”HEAD:android-m”对应的就是master,即可以使用下面的命令将代码提交到远程库 1$ git push origin HEAD:android-m 将远程库克隆到本地1$ git clone git@github.com:sunnycoder/Hello-World.git // 最后的是远程git库的SSH地址，此处使用的是我的github上的一个git库ssh地址 分支管理创建分支1$ git branch dev 切换分支1$ git checkout dev 创建并切换1$ git checkout -b dev 查看当前分支1$ git branch 合并分支git merge命令用于合并指定分支到当前分支，通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 123$ git merge dev // 把dev分支的工作成果合并到master分支上$ git merge --no-ff -m "merge with no-ff" dev // --no-ff参数，表示禁用Fast forward -m参数用于添加commit描述。 删除分支1$ git branch -d dev 存储现场1$ git stash 查看存储的信息1$ git stash list 恢复现场1234$ git stash apply // 恢复后，stash内容并不删除$ git stash drop$ git stash apply stash@&#123;0&#125; // stash list存在多个时，恢复指定的stash 另外一种方式： 1$ git stash pop // 恢复的同时把删除stash内容 查看远程库的信息12$ git remote$ git remote -v // 显示更详细的信息,会显示可以抓取和推送的地址 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 123456789101112$ git tag &lt;name&gt; // 添加名称为name的标签$ git tag // 查看所有标签$ git tag &lt;name&gt; &lt;commit_id&gt; // 对某一次提交打标签$ git tag -d &lt;name&gt; // 删除一个本地标签$ git push origin &lt;tagname&gt; // 推送某个标签到远程库$ git push origin --tags // 一次性推送全部尚未推送到远程的本地标签$ git push origin :refs/tags/&lt;tagname&gt; 删除一个远程标签 自定义git让Git显示颜色1$ git config --global color.ui true 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 例如，下面就是一个.gitignore文件的内容 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后需要把.gitignore也提交到Git 12$ git add -f App.class // 强制添加到Git$ git check-ignore -v App.class // 检测规则 配置别名12345678$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch$ git config --global alias.last 'log -1' // 显示最后一次提交信息$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 配置文件配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 每个仓库的Git配置文件都放在.git/config文件中 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig Git全局配置和单个仓库的用户名邮箱配置学习git的时候, 大家刚开始使用之前都配置了一个全局的用户名和邮箱 $ git config –global user.name “github’s Name” $ git config –global user.email “github@xx.com” $ git config –list 如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置 $ git config user.name “gitlab’s Name” $ git config user.email “gitlab@xx.com” $ git config –list git config –list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置 repo google提供的git集成工具 总结### 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作. &lt; 事实上直接reset掉提交就可以了。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 参考资料 官方文档 廖雪峰的Git教程]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android M Permission 详解]]></title>
    <url>%2F2016%2F09%2F18%2FPermission%2F</url>
    <content type="text"><![CDATA[[TOC] Android M新增运行时申请权限的机制， 如果是在M上的应用，不需要在安装时申请权限，而是在应用运行时动态的申请权限，系统会弹出一个对话框向用户请求权限。 支持动态申请权限机制的应用安装在之前的版本，依然采用过去的权限机制：安装时申请权限。 概述(Overview)下面是运行时权限机制的关键部分的简要概述 声明权限(Declaring Permissions): 应用需要在manifest文件中申请它所需要的所以权限，这一点和之前一样 权限组(Permission Groups): 权限被划分为一些权限组(permission group) 例如存储的权限组包含读取存储和写存储的权限 存储貌似只要申请READ_EXTERNAL_STORAGE就可以了android.permission-group.STORAGE ： android.permission.READ_EXTERNAL_STORAGE 和android.permission.WRITE_EXTERNAL_STORAGE 有限制的安装时赋予权限(Limited Permissions Granted at Install Time): 当安装或者升级应用时，系统会赋予应用manifest中所有的PROTECTION_NORMAL类型的权限，详见 PROTECTION_NORMAL列表 运行时用户赋予权限(User Grants Permissions at Run-Time): 当用户请求权限时，系统弹出一个选择框供用户选择，然后通过回调机制判断用户的选择 总是检测权限 (Always Check for Permission): 当一个应用执行一些权限时，每一次运行时都需要检查应用是否已经具备了相应的权限，如果没有，需要被赋予权限，对应PROTECTION_NORMAL类型的权限，不需要动态的检测申请 优雅的处理缺少权限的情况 (Handle Lack of Permissions Gracefully) : 如果一个应用没有被赋予需要的权限，需要处理权限申请失败的情况。 如果这个权限影响一个功能，没有权限时可以使得权限不生效 如果一个权限是应用必备的，需要使得整个应用不可用，并提示用户赋予权限才能运行 权限是可以取消的(Permissions are Revocable) : 用户可以在任何时候取消权限，如果用户在设置中取消应用的权限，不会通知应用，需要应用在执行一些需要运行时权限的动作时确保具备相应的权限 权限组(Permission groups)一些相关的权限被划分为一个组，这样用户在赋予权限时可以一次操作赋予一个权限组内的多个权限.如果一个应用随后又请求同一个组内权限，系统默认给予权限而不需要用户操作。系统会回调onRequestPermissionsResult()方法，好像用户在权限选择框中选择允许权限一样。 关键点在于第一次会记录用户的一个选择？ 例如： 系统应用和签名类型的权限(System components and signature permissions )正常的，当安装一个应用时，系统会赋予应用manifest中所有的PROTECTION_NORMAL类型的权限，但是在一些特殊的情况下，系统会允许应用更多的权限： １． 系统应用自动获取manifest中声明的所有权限２． 如果应用申请在manifest文件中声明的PROTECTION_SIGNATURE类型的权限，同时应用具备和声明这个权限的应用一样的证书时，系统会在应用安装时赋予这些权限。应用是不能在运行时申请PROTECTION_SIGNATURE类型的权限的。 兼容旧版本 (Forwards and backwards compatibility) 如果一个应用不打算运行在Android M上，还是使用之前的权限机制即可：安装时赋予manifest中声明的权限 使用运行时权限机制的应用运行在非M版本上，依然采取之前的权限机制。 权限 VS 意图 (Permissions versus intents)在很多情况下，你有两种选择让你的应用去执行一个任务： 让你的应用去申请执行相应操作所需要的权限 通过intents让其他应用去执行相应的操作 例如：拨打一路电话，查看联系人等，应用可以自己申请权限，调用API去执行相应的操作，也可以选择发送Intents到拨号应用或者联系人应用去执行相应的操作，然后在onActivityResult() 中获取返回的结果 优劣对比： 1.使用权限 应用可以完整的控制执行功能时的用户体验，当然如果你需要设计一个合适的UI的话，这样全局的控制可能会增加任务的复杂性 第一次执行任务时，需要用户赋予应用对应的权限，之前运行就不需要用户再赋予权限，如果用户拒接权限或者之后在设置中关闭权限，应用就无法执行相应的操作。 2.使用Intents 无需设计这部分操作的UI体验，但这也就意味着应用失去对这一部分用户体验的控制，用户可能会与一个你从未见过的应用进行交互。 如果系统没有默认的应用处理对应的操作，系统会弹出一个选择框让用户选择使用哪一个应用去执行操作。如果此时用户没有选择一个默认的应用，每次执行这个操作时都需要弹出对话框 运行时权限机制相关代码(Coding for Runtime Permissions) 使新的权限机制可用 (Enabling the new permissions model) 应用想要使用M的权限机制，你需要首先设置uses-sdk12345678&lt;uses-sdktargetSdkVersion = &quot;MNC&quot;compileSdkVersion = &quot;android-MNC&quot; /&gt;// Dialer应用 &lt;uses-sdk android:minSdkVersion=&quot;23&quot; android:targetSdkVersion=&quot;23&quot; /&gt; 设计Android M专属权限 (Designating a permission for the M only) 你可以使用元素来表明这个权限只在Android M上需要。如果你这么做的话，当应用安装在旧版本上时，系统不会让用户赋予应用相应的权限。通过使用元素你可以添加新的权限去更新你的版本而不需要强制用户在安装或者更新时赋予相应的权限 如果应用安装运行在M上，和 是一样的效果 权限提示 (Prompting for permissions ) 检测app所运行的平台版本 (Check what platform the app is running on) 新的权限机制只在M上支持，在执行对应的方法时需要判断当前运行的系统版本应用可用使用Build.VERSION.CODENAME来获取当前运行的平台，如果是运行在M上，CODENAME对应的是”MNC” 检测应用是否拥有需要的权限(Check if the app has the needed permission) 当用户执行一些需要权限的操作时，应用应该首先检查当前是否已经拥有权限去执行操作，使用下面的方法 123Context.checkSelfPermission(permission_name)// for exampleContext.checkSelfPermission(android.permission.WRITE_EXTERNAL_STORAGE) 即可应用知道用户已经赋予过权限，也需要每次都去检查，因为用户可能在任何时候撤销权限 说明为什么需要权限(Explain why the app needs permissions) 在一些情况下，你可能希望帮忙用户理解为什么应用需要权限，例如： 一些情况需要提供额外的解释，可以使用下面的方法，返回true的话意味着你需要提供额外的信息解释应用为什么需要权限1234Activity.shouldShowRequestPermissionRationale(String)// true ：app has requested this permission previously and the user denied the request.If the user turned down the permission request in the past and chose the Don&apos;t ask again option in the permission request system dialog, this method returns false. The method also returns false if the device policy prohibits the app from having that permission. 如果用户拒接权限同时选择不再询问，这个方法返回false. 这种情况下应用不需要再弹任何提示 请求权限 (Request permissions if necessary) 如果应用不具备相应的权限，可以调用下面的方法去申请权限12345@param permissions The requested permissions.@param requestCode Application specific request code to match with a result reported to &#123;@link #onRequestPermissionsResult(int, String[], int[])&#125;.Should be &gt;= 0.Activity.(@NonNull String[] permissions, int requestCode) 当用户在弹出的对话框中做出选择后，系统会回调onRequestPermissionsResult方法来处理用户的选择 请求权限的代码示例1234567891011121314151617if (checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (shouldShowRequestPermissionRationale( Manifest.permission.READ_CONTACTS)) &#123; // Explain to the user why we need to read the contacts &#125; requestPermissions(new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant return;&#125; 处理权限请求响应 (Handle the permissions request response) 当一个应用请求权限时，系统会显示一个对话框给用户，当用户做出选择后，系统会回调下面的方法并传入用户的选择应用需要重写这方法， 12345678 * @param requestCode The request code passed in &#123;@link #requestPermissions(String[], int)&#125;. * @param permissions The requested permissions. Never null. * @param grantResults The grant results for the corresponding permissions * which is either &#123;@link android.content.pm.PackageManager#PERMISSION_GRANTED&#125; * or &#123;@link android.content.pm.PackageManager#PERMISSION_DENIED&#125;. Never null.Activity.onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; 代码示例，请求READ_CONTACTS权限的代码回调：12345678910111213141516171819202122@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! do the // calendar task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other &apos;switch&apos; lines to check for other // permissions this app might request &#125;&#125; 如果用户拒接了申请的权限，应用需要做出处理，例如弹出一个dialog解释为什么无法执行相应的操作 当系统向用户询问权限申请时，用户可以选择不再询问，在这种情况下，应用再去调用requestPermissions方法时，系统会立即拒绝这个请求这种情况下，系统在回调onRequestPermissionsResult()方法时的结果和用户再次拒绝请求一样因此，你的应用无法确保任何与用户直接交互的操作的执行 (这句话没看懂) Testing Runtime Permissions如果你的应用是想运行在Android M平台，你必须验证你的应用可以很好的处理权限问题Android M SDK新提供了一个adb命令，使得你可以测试你想设置的任何权限 New adb commands and options Install with permissions 安装应用并赋予manifest文件中的所有权限 1$ adb install -g &lt;path_to_apk&gt; Grant and revoke permissions 1234$ adb pm grant &lt;package_name&gt; &lt;permission_name&gt;$ adb pm grant com.example.myapp android.permission.RECORD_AUDIO$ adb pm revoke &lt;package_name&gt; &lt;permission_name&gt; Best Practices and Usage Notes Only ask for permissions you need Don’t overwhelm the user Explain why you need permissions Normal Permissions android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.ACCESS_WIMAX_STATE android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_MULTICAST_STATE android.permission.CHANGE_WIFI_STATE android.permission.DISABLE_KEYGUARD android.permission.EXPAND_STATUS_BAR android.permission.FLASHLIGHT android.permission.GET_ACCOUNTS android.permission.GET_PACKAGE_SIZE android.permission.INTERNET android.permission.KILL_BACKGROUND_PROCESSES android.permission.MODIFY_AUDIO_SETTINGS android.permission.NFC android.permission.PERSISTENT_ACTIVITY android.permission.READ_SYNC_SETTINGS android.permission.READ_SYNC_STATS android.permission.READ_USER_DICTIONARY android.permission.RECEIVE_BOOT_COMPLETED android.permission.REORDER_TASKS android.permission.SET_TIME_ZONE android.permission.SET_WALLPAPER android.permission.SET_WALLPAPER_HINTS android.permission.SUBSCRIBED_FEEDS_READ android.permission.TRANSMIT_IR android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_SETTINGS android.permission.WRITE_SYNC_SETTINGS android.permission.WRITE_USER_DICTIONARY com.android.alarm.permission.SET_ALARM com.android.launcher.permission.INSTALL_SHORTCUT ## 案例分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Notifications 详解]]></title>
    <url>%2F2016%2F08%2F18%2FNotification%2F</url>
    <content type="text"><![CDATA[[TOC] 概述A notification is a message you can display to the user outside of your application’s normal UI. When you tell the system to issue a notification, it first appears as an icon in the notification area. To see the details of the notification, the user opens the notification drawer. Both the notification area and the notification drawer are system-controlled areas that the user can view at any time. Design Considerations 设计注意事项Notifications, as an important part of the Android user interface, have their own design guidelines. The material design changes introduced in Android 5.0 (API level 21) are of particular importance, and you should review the Material Design training for more information. To learn how to design notifications and their interactions, read the Notifications design guide. 通知是android用户界面的一个重要组成部分 需要使用Material Design来说设计通知 特殊说明 除非特别注明，否则本指南均引用版本 4 支持库中的 NotificationCompat.Builder 类。 Android 3.0（API 级别 11）中已添加类 Notification.Builder。 &lt;&lt;&lt; 现在都是用这个 Creating a Notification 创建通知You specify the UI information and actions for a notification in a NotificationCompat.Builder object. To create the notification itself, you call NotificationCompat.Builder.build(), which returns a Notification object containing your specifications. To issue the notification, you pass the Notification object to the system by calling NotificationManager.notify(). 使用NotificationCompat.Builder创建一个Notification对象 (Notification.Builder) 调用NotificationManager.notify()发出一个通知 必要的通知内容 Required notification contents一个Notification 对象必须包含以下内容： 小图标 A small icon, set by setSmallIcon() 显示在通知的左边的图标部分的右下角，其余部分显示的是largeIcon, 例如来电通知，头像是大图标，call状态是小图标：普通情况是电话图标，电话被保持是暂停图标 1234567891011if (mLargeIcon != null) &#123; contentView.setImageViewIcon(R.id.icon, mLargeIcon); processLargeLegacyIcon(mLargeIcon, contentView); contentView.setImageViewIcon(R.id.right_icon, mSmallIcon); contentView.setViewVisibility(R.id.right_icon, View.VISIBLE); processSmallRightIcon(mSmallIcon, contentView);&#125; else &#123; // small icon at left contentView.setImageViewIcon(R.id.icon, mSmallIcon); contentView.setViewVisibility(R.id.icon, View.VISIBLE); processSmallIconAsLarge(mSmallIcon, contentView);&#125; 标题 A title, set by setContentTitle() 详细文本 Detail text, set by setContentText() 可选通知内容和设置 Optional notification contents and settings请参阅 NotificationCompat.Builder 参考文档。 http://developer.android.com/intl/zh-cn/reference/android/support/v4/app/NotificationCompat.Builder.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364* setOngoing(boolean ongoing) // true:正在进行中，常驻通知，无法通过左右滑动的方式清除 ，只有发起者调用cancle才能取消 通常是用来表示一个后台任务,* setWhen(long when) // 设置右上角的通知时间，如果不设置则使用默认使用当前系统时间* setUsesChronometer(boolean b) // Show the when field as a stopwatch. // 设置是否在通知时间的地方显示自动计时的时间。设置true后一般也会setwhen,不然也是使用默认的发起时间* setAutoCancel(boolean autoCancel) // true: 点击自动取消通知* setDeleteIntent(PendingIntent intent) // 清除通知时启动 Activity* setContentIntent(PendingIntent intent) // 点击通知时启动 Activity 最常见的场景* setPriority(int pri) // 设置优先级* setCategory(String category) // 设置类别* setColor(int argb) // 设置颜色 : 进度条的颜色；小图标的颜色？* setContent(RemoteViews views) // 设置自定义布局* setContentInfo(CharSequence info) // A small piece of additional information pertaining to this notification. * setDefaults(int defaults) // 使用默认属性 例如 .setDefaults(Notification.DEFAULT_SOUND) // 设置默认铃声* setExtras(Bundle extras) Set metadata for this notification. * setFullScreenIntent(PendingIntent intent, boolean highPriority) // An intent to launch instead of posting the notification to the status bar. 悬挂式通知* setGroup(String groupKey) // Set this notification to be part of a group of notifications sharing the same key. * setGroupSummary(boolean isGroupSummary) // Set this notification to be the group summary for a group of notifications. * setLargeIcon(Icon icon) setLargeIcon(Bitmap b) // Add a large icon to the notification content view. * setLights(int argb, int onMs, int offMs) // 设置三色灯* setLocalOnly(boolean localOnly) // Set whether or not this notification should not bridge to other devices. * setNumber(int number) // Set the large number at the right-hand side of the notification. 在右下角显示数字* setOnlyAlertOnce(boolean onlyAlertOnce) // et this flag if you would only like the sound, vibrate and ticker to be played if the notification is not already showing. * setProgress(int max, int progress, boolean indeterminate) // 设置进度条* setShowWhen(boolean show) // Control whether the timestamp set with setWhen is shown in the content view. * setSound(Uri sound, AudioAttributes audioAttributes) setSound(Uri sound) // setSound(Uri.parse(&quot;file:///sdcard/xx/xx.mp3&quot;)) setSound(Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, &quot;5&quot;)) * setStyle(Notification.Style style)* setSubText(CharSequence text) // Set the third line of text in the platform notification template. 通知的右侧正文内容一共有三行，第一行标题，第二行主要内容，第三行次要内容* setTicker(CharSequence tickerText) // Set the &quot;ticker&quot; text which is sent to accessibility services. 设置发出通知时在status bar进行提醒 旧版本使用，新版本已无用* setVibrate(long[] pattern) // Set the vibration pattern to use. builder.setVibrate(new long[]&#123;2000,1000,4000&#125;);* addAction(Notification.Action action) // 添加动作* addExtras(Bundle extras) // Merge additional metadata into this notification. getExtras()* addPerson(String uri) // 关联一个person 传入的参数必现是一个联系人uri Notification actions 通知操作 通知操作都是可选的，但是您至少应向通知添加一个操作 一个通知可以提供多个操作 始终定义一个当用户点击通知时会触发的操作；通常，此操作会在应用中打开 Activity。 也可以向通知添加按钮来执行其他操作，例如，暂停闹铃或立即答复短信 点击通知时启动 Activity 是最常见的操作场景,对应的接口为setContentIntent 还可以在用户清除通知时启动 Activity.对应的接口为setDeleteIntent 优先级 Notification priority NotificationCompat.Builder.setPriority() 您可以根据需要设置通知的优先级,范围从 PRIORITY_MIN (-2) 到 PRIORITY_MAX (2)；如果未设置，则优先级默认为 PRIORITY_DEFAULT (0) 12345PRIORITY_DEFAULT : 0 PRIORITY_LOW : -1PRIORITY_MIN : -2PRIORITY_HIGH : 1PRIORITY_MAX : 2 创建一个简单的通知 Creating a simple notification12345678910111213141516171819202122232425262728293031NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;);// Creates an explicit intent for an Activity in your appIntent resultIntent = new Intent(this, ResultActivity.class);// The stack builder object will contain an artificial back stack for the started Activity.// This ensures that navigating backward from the Activity leads out of your application to the Home screen.TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);// Adds the back stack for the Intent (but not the Intent itself)stackBuilder.addParentStack(ResultActivity.class);// Adds the Intent that starts the Activity to the top of the stackstackBuilder.addNextIntent(resultIntent);PendingIntent resultPendingIntent = stackBuilder.getPendingIntent( 0, PendingIntent.FLAG_UPDATE_CURRENT );mBuilder.setContentIntent(resultPendingIntent);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// mId allows you to update the notification later on. mId唯一标示通知，用于之后对通知对象的操作mNotificationManager.notify(mId, mBuilder.build()); Applying an expanded layout to a notification 将拓展布局应用于通知 折叠通知 NotificationCompat.Builder.setStyle() 扩展通知在 Android 4.1 之前的平台上不可用 注意处理兼容性 使用扩展布局示例 1234567891011121314151617181920NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;Event tracker&quot;) .setContentText(&quot;Events received&quot;)NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle();String[] events = new String[6];// Sets a title for the Inbox in expanded layoutinboxStyle.setBigContentTitle(&quot;Event tracker details:&quot;);...// Moves events into the expanded layoutfor (int i=0; i &lt; events.length; i++) &#123; inboxStyle.addLine(events[i]);&#125;// Moves the expanded layout object into the notification object.mBuilder.setStyle(inBoxStyle); // 关键方法...// Issue the notification here. Handling compatibility 处理兼容性 使用NotificationCompat 及其子类（特别是 NotificationCompat.Builder）创建通知 为所有用户提供通知的全部功能，无论他们使用何种版本的 Android 系统 确保所有用户均可通过点击通知启动 Activity 来获得该Activity中的功能 将要使用的扩展通知功能添加到通知。 Managing Notifications 管理通知 当您需要为同一类型的事件多次发出同一通知时，应避免创建全新的通知， 而是应考虑通过更改之前通知的某些值和/或为其添加某些值来更新通知。 “stacking” the notification; it’s described in more detail in the Notifications Design guide. Gmail 通过增加未读消息计数并将每封电子邮件的摘要添加到通知，通知用户收到了新的电子邮件。 这称为“堆叠”通知； Updating notifications 更新通知* 12345678910111213141516171819mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// Sets an ID for the notification, so it can be updatedint notifyID = 1;mNotifyBuilder = new NotificationCompat.Builder(this) .setContentTitle(&quot;New Message&quot;) .setContentText(&quot;You&apos;ve received new messages.&quot;) .setSmallIcon(R.drawable.ic_notify_status)numMessages = 0;// Start of a loop that processes data and then notifies the user... mNotifyBuilder.setContentText(currentText) .setNumber(++numMessages); // Because the ID remains unchanged, the existing notification is // updated. mNotificationManager.notify( notifyID, mNotifyBuilder.build()); //如果之前的通知依然可见，则更新，如果已经销毁，则重新创建... Removing notifications 删除通知 用户单独或通过使用“全部清除”清除了该通知（如果通知可以清除）。 用户点击通知，且您在创建通知时调用了 setAutoCancel() 您针对特定的通知 ID 调用了 cancel()。此方法还会删除当前通知。 您调用了 cancelAll() 方法，该方法将删除之前发出的所有通知。 Preserving Navigation when Starting an Activity 启动 Activity 时保留导航设置常规 Activity PendingIntent &lt;不设置好像也可以返回&gt; 123456789101112131415Intent resultIntent = new Intent(this, ResultActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);// Adds the back stackstackBuilder.addParentStack(ResultActivity.class);// Adds the Intent to the top of the stackstackBuilder.addNextIntent(resultIntent);// Gets a PendingIntent containing the entire back stackPendingIntent resultPendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);...NotificationCompat.Builder builder = new NotificationCompat.Builder(this);builder.setContentIntent(resultPendingIntent);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mNotificationManager.notify(id, builder.build()); 设置特殊 Activity PendingIntent1234567891011121314151617181920212223242526// Instantiate a Builder object.NotificationCompat.Builder builder = new NotificationCompat.Builder(this);// Creates an Intent for the ActivityIntent notifyIntent = new Intent(this, ResultActivity.class);// Sets the Activity to start in a new, empty tasknotifyIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);// Creates the PendingIntentPendingIntent notifyPendingIntent = PendingIntent.getActivity( this, 0, notifyIntent, PendingIntent.FLAG_UPDATE_CURRENT);// Puts the PendingIntent into the notification builderbuilder.setContentIntent(notifyPendingIntent);// Notifications are issued by sending them to the// NotificationManager system service.NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// Builds an anonymous Notification object from the builder, and// passes it to the NotificationManagermNotificationManager.notify(id, builder.build()); 在通知中显示进度 setProgress() 12 显示持续时间固定的进度指示器 要删除进度栏，请调用 setProgress(0, 0, false) 1234567891011121314151617181920212223242526272829303132333435363738mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mBuilder = new NotificationCompat.Builder(this);mBuilder.setContentTitle(&quot;Picture Download&quot;) .setContentText(&quot;Download in progress&quot;) .setSmallIcon(R.drawable.ic_notification);// Start a lengthy operation in a background threadnew Thread( new Runnable() &#123; @Override public void run() &#123; int incr; // Do the &quot;lengthy&quot; operation 20 times for (incr = 0; incr &lt;= 100; incr+=5) &#123; // Sets the progress indicator to a max value, the // current completion percentage, and &quot;determinate&quot; // state mBuilder.setProgress(100, incr, false); // Displays the progress bar for the first time. mNotifyManager.notify(0, mBuilder.build()); // Sleeps the thread, simulating an operation // that takes time try &#123; // Sleep for 5 seconds Thread.sleep(5*1000); &#125; catch (InterruptedException e) &#123; Log.d(TAG, &quot;sleep failure&quot;); &#125; &#125; // When the loop is finished, updates the notification mBuilder.setContentText(&quot;Download complete&quot;) // Removes the progress bar .setProgress(0,0,false); mNotifyManager.notify(ID, mBuilder.build()); &#125; &#125;// Starts the thread by calling the run() method in its Runnable).start(); 显示持续 Activity 指示器通知元数据 Notification Metadata 当设备处于“优先”模式时，setCategory() 会告知系统如何处理应用通知（例如，通知代表传入呼叫、即时消息还是闹铃）。 如果优先级字段设置为 PRIORITY_MAX 或 PRIORITY_HIGH 的通知还有声音或振动，则 setPriority() 会将其显示在小型浮动窗口中。 addPerson() 允许您向通知添加人员名单。您的应用可以使用此名单指示系统将指定人员发出的通知归成一组，或者将这些人员发出的通知视为更重要的通知。 浮动通知 Heads-up Notifications对于 Android 5.0（API 级别 21），当设备处于活动状态时（即，设备未锁定且其屏幕已打开），通知可以显示在小型浮动窗口中（也称为“浮动通知”）。 用户的 Activity 处于全屏模式中（应用使用 fullScreenIntent） 通知具有较高的优先级并使用铃声或振动 锁定屏幕通知随着 Android 5.0（API 级别 21）的发布，通知现在还可显示在锁定屏幕上 用户可以通过“设置”选择是否将通知显示在锁定屏幕上，并且您可以指定您应用中的通知在锁定屏幕上是否可见。(设定为图案，pin锁，密码) 设置可见性您的应用可以控制在安全锁定屏幕上显示的通知中可见的详细级别。 调用 setVisibility()并指定以下值之一： VISIBILITY_PUBLIC 显示通知的完整内容。VISIBILITY_SECRET 不会在锁定屏幕上显示此通知的任何部分。VISIBILITY_PRIVATE 显示通知图标和内容标题等基本信息，但是隐藏通知的完整内容。 设置 VISIBILITY_PRIVATE 后，您还可以提供其中隐藏了某些详细信息的替换版本通知内容。 在锁定屏幕上控制媒体播放自定义通知布局可以利用通知框架定义自定义通知布局，由该布局定义通知在 RemoteViews 对象中的外观。 自定义通知布局的可用高度取决于通知视图。普通视图布局限制为 64 dp，扩展视图布局限制为 256 dp。 要定义自定义通知布局，请首先实例化 RemoteViews 对象来扩充 XML 布局文件。然后，调用 setContent()，而不是调用 setContentTitle() 等方法。 要在自定义通知中设置内容详细信息，请使用 RemoteViews 中的方法设置视图子项的值： 在单独的文件中为通知创建 XML 布局。 在您的应用中，使用 RemoteViews 方法定义通知的图标和文本。 通过调用 setContent() 将此 RemoteViews 对象放入 Notification.Builder 中 ### 标准布局 12345678910111213141516171819202122232425262728 private int getBaseLayoutResource() &#123; return R.layout.notification_template_material_base; &#125;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/status_bar_latest_event_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;64dp&quot; android:tag=&quot;base&quot; &gt; &lt;include layout=&quot;@layout/notification_template_icon_group&quot; android:layout_width=&quot;@dimen/notification_large_icon_width&quot; android:layout_height=&quot;@dimen/notification_large_icon_height&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/notification_main_column&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;top&quot; android:layout_marginStart=&quot;@dimen/notification_large_icon_width&quot; android:minHeight=&quot;@dimen/notification_large_icon_height&quot; android:orientation=&quot;vertical&quot; &gt; &lt;include layout=&quot;@layout/notification_template_part_line1&quot; /&gt; &lt;include layout=&quot;@layout/notification_template_part_line2&quot; /&gt; &lt;include layout=&quot;@layout/notification_template_part_line3&quot; /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; pengdingIntent pendingIntent 主要的区别在于Intent的执行立刻的，而pendingIntent的执行不是立刻的.使用pendingIntent的目的在于它所包含的Intent的操作的执行是需要满足某些条件的。 主要的使用的地方和例子：通知Notificatio的发送，短消息SmsManager的发送和警报器AlarmManager的执行等等。 获取方法1234567891011PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, mIntent, 0);* 第四个参数可以设置不同的flag,0表示没有flag FLAG_ONE_SHOT 表示返回的PendingIntent仅能执行一次，执行完后自动取消FLAG_NO_CREATE 表示如果描述的PendingIntent不存在，并不创建相应的PendingIntent，而是返回NULLFLAG_CANCEL_CURRENT 表示相应的PendingIntent已经存在，则取消前者，然后创建新的PendingIntent，这个有利于数据保持为最新的，可以用于即时通信的通信场景FLAG_UPDATE_CURRENT 表示更新的PendingIntent Intent和PendingIntent的区别 a. Intent是立即使用的，而PendingIntent可以等到事件发生后触发，PendingIntent可以cancelb. Intent在程序结束后即终止，而PendingIntent在程序结束后依然有效c. PendingIntent自带Context，而Intent需要在某个Context内运行d. Intent在原task中运行，PendingIntent在新的task中运行 通过getActivity(Context context, int requestCode, Intent intent, int flags)系列方法从系统取得一个用于启动一个Activity的PendingIntent对象,通过getService(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于启动一个Service的PendingIntent对象通过getBroadcast(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于向BroadcastReceiver的Intent广播的PendingIntent对象 contentIntent：在通知窗口区域，Notification被单击时的响应事件由该intent触发； deleteIntent：当用户点击全部清除按钮时，响应该清除事件的Intent； fullScreenIntent：响应紧急状态的全屏事件（例如来电事件），也就是说通知来的时候，跳过在通知区域点击通知这一步，直接执行fullScreenIntent代表的事件 NotificationManagerService详解设计规范 http://developer.android.com/intl/zh-cn/design/patterns/notifications.html 参考资料 http://developer.android.com/intl/zh-cn/guide/topics/ui/notifiers/notifications.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Notifications</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Monkey详解]]></title>
    <url>%2F2016%2F07%2F18%2FMonkey%2F</url>
    <content type="text"><![CDATA[Monkey命令行可用的全部选项常规 –help 列出简单的用法。 -v 命令行的每一个-v将增加反馈信息的级别。 Level 0(缺省值)除启动提示、测试完成和最终结果之外，提供较少信息。 Level 1提供较为详细的测试信息，如逐个发送到Activity的事件。 Level 2提供更加详细的设置信息，如测试中被选中的或未被选中的Activity。 日志级别 Level 0 *示例 adbshell monkey -p com.htc.Weather –v 100 说明缺省值，仅提供启动提示、测试完成和最终结果等少量信息 日志级别 Level 1 *示例 adbshell monkey -p com.htc.Weather –v -v 100 说明 提供较为详细的日志，包括每个发送到Activity的事件信息 日志级别 Level 2 *示例 adbshell monkey -p com.htc.Weather –v -v –v 100 说明 最详细的日志，包括了测试中选中/未选中的Activity信息 事件 -s 用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。 示例： Monkey测试1：adb shellmonkey -p com.htc.Weather –s 10 100 Monkey 测试2：adb shellmonkey -p com.htc.Weather –s 10 100 两次测试的效果是相同的，因为模拟的用户操作序列（每次操作按照一定的先后顺序所组成的一系列操作，即一个序列）是一样的。操作序列虽 然是随机生成的，但是只要我们指定了相同的Seed值，就可以保证两次测试产生的随机操作序列是完全相同的，所以这个操作序列伪随机的； –throttle 在事件之间插入固定延迟。通过这个选项可以减缓Monkey的执行速度。如果不指定该选项，Monkey将不会被延迟，事件将尽可能快地被产成。 示例：adb shellmonkey -p com.htc.Weather –throttle 3000 100 –pct-touch 调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)。 示例：adb shellmonkey -p com.htc.Weather –pct-touch 10 1000 –pct-motion调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)。 示例：adb shellmonkey -p com.htc.Weather –pct-motion 20 1000 –pct-trackball 调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)。 示例：adb shellmonkey -p com.htc.Weather –pct-trackball 30 1000 –pct-nav 调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)。 示例：adb shellmonkey -p com.htc.Weather –pct-nav 40 1000 –pct-majornav 调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键) 示例：adb shellmonkey -p com.htc.Weather –pct-majornav 50 1000 –pct-syskeys调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)。 示例：adb shellmonkey -p com.htc.Weather –pct-syskeys 60 1000 –pct-appswitch调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。 示例：adb shellmonkey -p com.htc.Weather –pct-appswitch 70 1000 –pct-anyevent调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。* 示例：adb shell monkey -p com.htc.Weather –pct -anyevent 1001000* 指定多个类型事件的百分比： adb shell monkey -pcom.htc.Weather –pct-anyevent 50 –pct-appswitch 50 1000注意：各事件类型的百分比总数不能超过100%； 约束限制 -p 如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。如果你的应用程序还需要访问其它包里的Activity(如选择取一个联系人)，那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。要指定多个包，需要使用多个 -p选项，每个-p选项只能用于一个包。 指定一个包： adb shell monkey -p com.htc.Weather 100 说明：com.htc.Weather为包名，100是事件计数（即让Monkey程序模拟100次随机用户事件）。 指定多个包：adb shell monkey -p com.htc.Weather –pcom.htc.pdfreader -p com.htc.photo.widgets 100 不指定包：adb shell monkey 100 说明：Monkey随机启动APP并发送100个随机事件。 要查看设备中所有的包，在CMD窗口中执行以下命令： adb shell #cd data/data #ls -c 如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任何类别，Monkey将选 择下列类别中列出的Activity： Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。要指定多个类别，需要使用多个-c选项，每个-c选 项只能用于一个类别。 调试–dbg-no-events设置此选项，Monkey将执行初始启动，进入到一个测试Activity，然后不会再进一步生成事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换。 –hprof设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要小心使用它。 –ignore-crashes通常，当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 示例1：adb shellmonkey -p com.htc.Weather –ignore-crashes 1000测试过程中即使Weather程序崩溃，Monkey依然会继续发送事件直到事件数目达到1000为止； 示例2：adb shell monkey -p com.htc.Weather 1000测试过程中，如果Weather程序崩溃，Monkey将会停止运行。 –ignore-timeouts通常，当应用程序发生任何超时错误(如“Application Not Responding”对话框)时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions通常，当应用程序发生许可错误(如启动一个需要某些许可的Activity)时，Monkey将停止运行。如果设置了此选项，Monkey将继续向系统发送事件，直到计数完成。 –kill-process-after-error通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发生错误的进程。注意，正常的(成功的)结束，并没有停止启动的进程，设备只是在结束事件之后，简单地保持在最后的状态。 –monitor-native-crashes监视并报告Android系统中本地代码的崩溃事件。如果设置了–kill-process-after-error，系统将停止运行。 –wait-dbg停止执行中的Monkey，直到有调试器和它相连接。 参考文档 http://www.cnblogs.com/xiwix/archive/2012/04/15/2450976.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Monkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android LruCache 源码解析]]></title>
    <url>%2F2016%2F06%2F18%2FLruCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 简介 Lru 是 Least Recently Used 最近最少使用算法。 曾经，在各大缓存图片的框架没流行的时候。有一种很常用的内存缓存技术：SoftReference 和 WeakReference（软引用和弱引用）。但是走到了 Android 2.3（Level 9）时代，垃圾回收机制更倾向于回收 SoftReference 或 WeakReference 的对象。后来，又来到了 Android3.0，图片缓存在内容中，因为不知道要在是什么时候释放内存，没有策略，没用一种可以预见的场合去将其释放。这就造成了内存溢出。 2. 使用方法当成一个 Map 用就可以了，只不过实现了 Lru 缓存策略 使用的时候记住几点即可： 1.（必填）你需要提供一个缓存容量作为构造参数 2.（个人认为必填） 覆写 sizeOf 方法 ，自定义设计一条数据放进来的容量计算。 2.（选填） 覆写 entryRemoved 方法 ，你可以知道最少使用的缓存被清除时的数据（ evicted, key, oldValue, newVaule ） 3.（记住）LruCache是线程安全的，在内部的 get、put、remove 包括 trimToSize 都是安全的（因为都上锁了）。 4.（选填） 还有就是覆写 create 方法 一般做到 1、2、3就足够了，4可以无视 。 以下是 一个 LruCache 实现 Bitmap 小缓存的案例, entryRemoved 里的自定义逻辑可以无视，这里是我的展示 demo 里的自定义 entryRemoved 逻辑(｡&gt;﹏&lt;｡)1234567891011121314151617181920212223242526272829303132333435363738394041private static final float ONE_MIB = 1024 * 1024;// 7MBprivate static final int CACHE_SIZE = (int) (7 * ONE_MIB);private LruCache&lt;String, Bitmap&gt; bitmapCache;this.bitmapCache = new LruCache&lt;String, Bitmap&gt;(CACHE_SIZE) &#123; protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount(); &#125; /** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 导致 * 4.newValue!=null，那么则被put()或get()调用。 */ @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; mEntryRemovedInfoText.setText( String.format(Locale.getDefault(), LRU_CACHE_ENTRY_REMOVED_INFO_FORMAT, evicted, key, oldValue != null ? oldValue.hashCode() : "null", newValue != null ? newValue.hashCode() : "null")); // 见上述 3. if (evicted) &#123; // 进行了trimToSize or remove (一般是溢出了 或 key-value被删除了 ) if (recentList.contains(key)) &#123; recentList.remove(key); refreshText(mRecentInfoText, LRU_CACHE_RECENT_FORMAT, recentList); &#125; &#125; else &#123; // put冲突后 或 get里成功create 后 recentList.remove(key); refreshText(mRecentInfoText, LRU_CACHE_RECENT_FORMAT, recentList); &#125; if (cacheList.contains(key)) &#123; cacheList.remove(key); refreshText(mCacheDataText, LRU_CACHE_CACHE_DATA_FORMAT, cacheList); &#125; &#125;&#125;; 3. 效果展示3.1 效果一（验证 Lru，最近没访问的，在溢出时优先被清理） 前提： 设置 LruCache 最大容量为 7MB，把图1、2、3放入了，此时占用容量为：1.87+0.38+2.47=4.47MB。 执行操作： 1.然后点 get 图3一共16次（证明访问次数和Lru没关系，只有访问顺序有关系）。Recent visit显示了图3 2.先 get 图2，再 get 图1，制造最近访问顺序为： 3. put 图4，预算容量需要4.47+2.47=7.19MB。会溢出。 4.溢出了，删除最近没访问的图3。 5.观察 entryRemoved 数据 图三被移除了（对照hashcode） 3.2 效果二（验证 entryRemoved 的 evicted=false，可以验证冲突） 前提：执行了效果一，put 了图4，删除了最近没访问的图3。 执行操作：再一次 put 图4，发生冲突，拿到 key、冲突 value 以及 put 的 value，这里我放到是同一个 hashcode 的 bitmap，所以 hashcode 一样，但是无关紧要吧。 4. 源码分析LruCache 就是 利用 LinkedHashMap 的一个特性再加上对 LinkedHashMap 的数据操作上锁实现的缓存策略。 4.1 LruCache 的唯一构造方法1234567891011121314151617/** * LruCache的构造方法：需要传入最大缓存个数 */public LruCache(int maxSize) &#123; // 最大缓存个数小于0，会抛出IllegalArgumentException if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; /* * 初始化LinkedHashMap * 第一个参数：initialCapacity，初始大小 * 第二个参数：loadFactor，负载因子=0.75f * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 */ this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 第一个参数 initialCapacity 用于初始化该 LinkedHashMap 的大小。 先简单介绍一下 第二个参数 loadFactor，这个其实的 HashMap 里的构造参数，涉及到扩容问题，比如 HashMap 的最大容量是100，那么这里设置0.75f的话，到75容量的时候就会扩容。 主要是第三个参数 accessOrder=true ，这样的话 LinkedHashMap 数据排序就会基于数据的访问顺序，从而实现了 LruCache 核心工作原理。 4.2 LruCache.get(K key)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 根据 key 查询缓存，如果存在于缓存或者被 create 方法创建了。 * 如果值返回了，那么它将被移动到队列的头部。 * 如果如果没有缓存的值，则返回 null。 */public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序 mapValue = map.get(key); // 计算 命中次数 if (mapValue != null) &#123; hitCount++; return mapValue; &#125; // 计算 丢失次数 missCount++; &#125; /* * 官方解释： * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时 * 候，一个冲突的值被添加到Map，我们在Map中删除这个值，释放被创造的值。 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; /*************************** * 不覆写create方法走不到下面 * ***************************/ /* * 正常情况走不到这里 * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑 * 因为默认的 create(K key) 逻辑为null */ synchronized (this) &#123; // 记录 create 的次数 createCount++; // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值 mapValue = map.put(key, createdValue); // 如果之前存在相同key的value，即有冲突。 if (mapValue != null) &#123; /* * 有冲突 * 所以 撤销 刚才的 操作 * 将 之前相同key 的值 重新放回去 */ map.put(key, mapValue); &#125; else &#123; // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, createdValue); &#125; &#125; // 如果上面 判断出了 将要放入的值发生冲突 if (mapValue != null) &#123; /* * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了 * 告诉 自定义 的 entryRemoved 方法 */ entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; // 上面 进行了 size += 操作 所以这里要重整长度 trimToSize(maxSize); return createdValue; &#125;&#125; 上述的 get 方法表面并没有看出哪里有实现了Lru的缓存策略。主要在 mapValue = map.get(key);里，调用了 LinkedHashMap 的 get 方法，再加上 LruCache 构造里默认设置 LinkedHashMap 的 accessOrder=true。 4.3 LinkedHashMap.get(Object key)1234567891011121314151617181920212223242526272829303132333435/** * Returns the value of the mapping with the specified key. * * @param key * the key. * @return the value of the mapping with the specified key, or &#123;@code null&#125; * if no mapping for the specified key is found. */@Override public V get(Object key) &#123; /* * This method is overridden to eliminate the need for a polymorphic * invocation in superclass at the expense of code duplication. */ if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; if (e == null) return null; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; &#125; return null;&#125; 其实仔细看 if (accessOrder) 的逻辑即可，如果 accessOrder=true 那么每次 get 都会执行 N 次 makeTail(LinkedEntry&lt;K, V&gt; e) 。 接下来看看 4.4 LinkedHashMap.makeTail(LinkedEntry e)123456789101112131415161718/** * Relinks the given entry to the tail of the list. Under access ordering, * this method is invoked whenever the value of a pre-existing entry is * read by Map.get or modified by Map.put. */private void makeTail(LinkedEntry&lt;K, V&gt; e) &#123; // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;&#125; // Unlink e // Relink e as tail LinkedHashMap是双向循环链表，然后此次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 以上就是 LruCache 核心工作原理(｡&gt;﹏&lt;｡) 接下来介绍 LruCache 的容量溢出策略 上述展示场景中，7M的容量，我添加三张图后，不会溢出，put后必然会超过7MB。 4.5 LruCache.put(K key, V value)123456789101112public final V put(K key, V value) &#123; ... synchronized (this) &#123; ... // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, value); ... &#125; ... trimToSize(maxSize); return previous;&#125; 记住几点： 1.put 开始的时候确实是把值放入 LinkedHashMap 了，不管超不超过你设定的缓存容量。 2.然后根据 safeSizeOf 方法计算 此次添加数据的容量是多少，并且加到 size 里 。 3.说到 safeSizeOf 就要讲到 sizeOf(K key, V value) 会计算出此次添加数据的大小 （像上面的 Demo，我的容量是7MB，我每次添加进来的 Bitmap 要是不覆写 sizeOf 方法的话，会视为该 bitmap 的容量计算为默认的容量计算 return 1。如此一来，这样的话 7MB 的 LruCache 容量可以放7x1024x1024张图片？明显这样的逻辑是不对的！） 4.直到 put 要结束时，进行了 trimToSize 才判断 size 是否 大于 maxSize 然后进行最近很少访问数据的移除 4.6 LruCache.trimToSize(int maxSize)1234567891011121314151617181920212223242526272829303132333435public void trimToSize(int maxSize) &#123; /* * 这是一个死循环， * 1.只有 扩容 的情况下能立即跳出 * 2.非扩容的情况下，map的数据会一个一个删除，直到map里没有值了，就会跳出 */ while (true) &#123; K key; V value; synchronized (this) &#123; // 在重新调整容量大小前，本身容量就为空的话，会出异常的。 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException( getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; // 如果是 扩容 或者 map为空了，就会中断，因为扩容不会涉及到丢弃数据的情况 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); // 拿到键值对，计算出在容量中的相对长度，然后减去。 size -= safeSizeOf(key, value); // 添加一次收回次数 evictionCount++; &#125; /* * 将最后一次删除的最少访问数据回调出去 */ entryRemoved(true, key, value, null); &#125;&#125; 简单描述：会判断之前 size 是否大于 maxSize 。是的话，直接跳出后什么也不做。不是的话，证明已经溢出容量了。由 makeTail 图已知，最近经常访问的数据在最末尾。拿到一个存放 key 的 Set，然后一直一直从头开始删除，删一个判断是否溢出，直到没有溢出。 最后看看 4.7 覆写 entryRemoved 的作用entryRemoved被LruCache调用的场景： 1.（put） put 发生 key 冲突时被调用，evicted=false，key=此次 put 的 key，oldValue=被覆盖的冲突 value，newValue=此次 put 的 value 2.（trimToSize） trimToSize 的时候，只会被调用一次，就是最后一次被删除的最少访问数据带回来。evicted=true，key=最后一次被删除的 key，oldValue=最后一次被删除的 value，newValue=null（此次没有冲突，只是 remove） 3.（remove） remove的时候，存在对应 key，并且被成功删除后被调用。evicted=false，key=此次 put的 key，oldValue=此次删除的 value，newValue=null（此次没有冲突，只是 remove） 4.（get后半段，查询丢失后处理情景，不过建议忽略） get 的时候，正常的话不实现自定义 create 的话，代码上看 get 方法只会走一半，如果你实现了自定义的 create(K key) 方法，并且在 你 create 后的值放入 LruCache 中发生 key 冲突时被调用，evicted=false，key=此次 get 的 key，oldValue=被你自定义 create(key)后的 value，newValue=原本存在 map 里的 key-value。 解释一下第四点吧：.第四点是这样的，先 get(key)，然后没拿到，丢失。.如果你提供了 自定义的 create(key) 方法，那么 LruCache 会根据你的逻辑自造一个 value，但是当放入的时候发现冲突了，但是已经放入了。.此时，会将那个冲突的值再让回去覆盖，此时调用上述4.的 entryRemoved。 因为 HashMap 在数据量大情况下，拿数据可能造成丢失，导致前半段查不到，你自定义的 create(key) 放入的时候发现又查到了（有冲突）。然后又急忙把原来的值放回去，此时你就白白create一趟，无所作为，还要走一遍entryRemoved。 综上就如同注释写的一样：12345678910/** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 * 导致 * 4.newValue!=null，那么则被put()或get()调用。 */protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; 可以参考我的 demo 里的 entryRemoved (｡&gt;﹏&lt;｡) 5. 开源项目中的使用square/picasso 6. 总结LruCache重要的几点： 1.LruCache 是通过 LinkedHashMap 构造方法的第三个参数的 accessOrder=true 实现了 Lru 算法缓存机制。 2.LruCache 在内部的get、put、remove包括 trimToSize 都是安全的（因为都上锁了）。 3.覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突。 4.maxSize 和 sizeOf(K key, V value) 方法的覆写息息相关，必须相同单位。（ 比如 maxSize 是7MB，自定义的 sizeOf 计算每个数据大小的时候必须能算出与MB之间有联系的单位 ） 5.LruCache 自身并没有释放内存，将 LinkedHashMap 的数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存。 7. 资源LruCacheActivity LruCache注释源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>LruCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android logcat详解]]></title>
    <url>%2F2016%2F05%2F18%2Flogcat%2F</url>
    <content type="text"><![CDATA[[TOC] logcat123456789101112131415161718192021222324252627282930313233343536371.logcat -c 清除已有log信息2.logcat -b main 显示主缓冲区的log logcat -b radio 显示无线缓冲区的log logcat -b events 显示事件缓冲区的log3.logcat -f [filename] 将log保存到指定的文件中，例如 logcat -b radio -f /data/radio.log4.logcat -v 设置logcat输出的格式 主要有7种: 1&gt; brief — Display priority/tag and PID of originating process (the default format). 2&gt; process — Display PID only. 3&gt; tag — Display the priority/tag only. 4&gt; thread — Display process:thread and priority/tag only. 5&gt; raw — Display the raw log message, with no other metadata fields. 6&gt; time — Display the date, invocation time, priority/tag, and PID of the originating process. 7&gt; long — Display all metadata fields and separate messages with a blank lines. 比较常用的是显示时间:logcat -v time &amp; 5.logcat -g 查看缓冲区的大小 * logcat -g main * logcat -g radio * logcat -g events]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>logcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Application详解]]></title>
    <url>%2F2016%2F05%2F08%2FApplication%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述先看看官方是怎么描述的 Base class for maintaining global application state.You can provide your own implementation by creating a subclass and specifying the fully-qualified name of this subclassas the “android:name” attribute in your AndroidManifest.xml’s tag.The Application class, or your subclass of the Application class, is instantiated before any other class when the processfor your application/package is created. Note: There is normally no need to subclass Application.In most situations, static singletons can provide the same functionality in a more modular way.If your singleton needs a global context (for example to register broadcast receivers),include Context.getApplicationContext() as a Context argument when invoking your singleton’s getInstance() method. Application和Activity,Service一样,是android框架的一个系统组件。当android程序启动时系统会创建一个 application对象，用来存储系统的一些信息。通常我们是不需要指定一个Application的，这时系统会自动帮我们创建。如果需要创建自己 的Application，需要创建一个类继承 Application并在manifest的application标签中进行注册。 android系统会为每个程序运行时创建一个Application类的对象且仅创建一个，所以Application可以说是单例 (singleton)模式的一个类.且application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局的单例的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以通过Application来进行一些，数据传递，数据共享 等,数据缓存等操作。 我们可以通过下面的方式在Manifest文件中来定义一个Application，下面是Android源码中Phone应用的Application定义： 123456789&lt;application android:name=&quot;PhoneApp&quot; android:persistent=&quot;true&quot; android:label=&quot;@string/phoneAppLabel&quot; android:icon=&quot;@mipmap/ic_launcher_phone&quot; android:allowBackup=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:usesCleartextTraffic=&quot;true&quot; android:defaultToDeviceProtectedStorage=&quot;true&quot; android:directBootAware=&quot;true&quot;&gt; 其中比较特殊的是android:persistent=”true” 标示该应用为永久应用，persistent应用开机时会被AMS自动加载，异常出现时，自动重新启动相应的，在代码中定义一个继承Application的类PhoneApp： 1234567891011121314151617181920public class PhoneApp extends Application &#123; PhoneGlobals mPhoneGlobals; TelephonyGlobals mTelephonyGlobals; public PhoneApp() &#123; &#125; @Override public void onCreate() &#123; if (UserHandle.myUserId() == 0) &#123; // We are running as the primary user, so should bring up the // global phone state. mPhoneGlobals = new PhoneGlobals(this); mPhoneGlobals.onCreate(); mTelephonyGlobals = new TelephonyGlobals(this); mTelephonyGlobals.onCreate(); &#125; &#125;&#125; Application的作用 维护全局应用程序状态的基类,Android程序的入口点,作为应用程序的全局唯一单例。我们可以在里面定义全局属性和全局方法 通过Application传递数据假如有一个Activity A, 跳转到 Activity B ,并需要传递一些数据。通常的作法是Intent.putExtra() 让Intent携带，或者有一个Bundle把信息加入Bundle让Intent推荐Bundle对象，实现传递。但这样作有一个问题在于，Intent和Bundle所能携带的数据类型都是一些基本的数据类型，如果想实现复杂的数据传递就比较麻烦了，通常需要实现 Serializable或者Parcellable接口。这其实是Android的一种IPC数据传递的方法。如果我们的两个Activity在同一个进程当中为什么还要这么麻烦呢，只要把需要传递的对象的引用传递过去就可以了。 基本思路是这样的。在Application中创建一个HashMap ，以字符串为索引，Object为value这样我们的HashMap就可以存储任何类型的对象了。在Activity A中把需要传递的对象放入这个HashMap，然后通过Intent或者其它途经再把这索引的字符串传递给ActivityB ,Activity B 就可以根据这个字符串在HashMap中取出这个对象了。只要再向下转个型 ，就实现了对象的传递。 Application数据缓存 我一般会习惯在application中建立两个HashMap一个用于数据的传递，一个用于缓 存一些数据。比如有一个Activity需要从网站获取一些数据，获取完之后我们就可以把这个数据cache到Application 当中，当页面设置到其它Activity再回来的时候，就可以直接使用缓存好的数据了。但如果需要cache一些大量的数据，最好是cache一些 (软引用)SoftReference ，并把这些数据cache到本地rom上或者sd卡上。如果在application中的缓存不存在，从本地缓存查找，如果本地缓存的数据也不存在再从网络上获取。 生命周期12345void onConfigurationChanged(Configuration newConfig) // Called by the system when the device configuration changes while your component is running.void onCreate() // Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created.void onLowMemory() // This is called when the overall system is running low on memory, and actively running processes should trim their memory usage.void onTerminate() // This method is for use in emulated process environments.void onTrimMemory(int level) // Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. onCreate1234567891011void onCreate ()Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created. Implementations should be as quick as possible (for example using lazy initialization of state) since the time spent in this function directlyimpacts the performance of starting the first activity, service, or receiver in a process. If you override this method, be sure to call super.onCreate().If you override this method you must call through to the superclass implementation. 在创建应用程序的时候调用。可以使用方法去初始化一些全局属性。 onLowMemory123456789void onLowMemory ()This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing.You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method.Preferably, you should implement onTrimMemory(int) from ComponentCallbacks2 to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this onLowMemory() method as a fallback for older versions, which can be treated the same as onTrimMemory(int) with the TRIM_MEMORY_COMPLETE level.If you override this method you must call through to the superclass implementation. 这个方法一般只会在后台进程已经终止，前台应用程序仍然缺少内存时调用。可以在这个方法内清空缓存或者释放不必要的资源。 onTerminate12345void onTerminate ()This method is for use in emulated process environments. It will never be called on a production Android device, where processes are removed by simply killing them; no user code (including this callback) is executed when doing so.If you override this method you must call through to the superclass implementation. 在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程。 onTrimMemory123456789101112void onTrimMemory (int level)Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.This will happen for example when it goes in the background and there is not enough memory to keep as many background processesrunning as desired. You should never compare to exact values of the level, since new intermediate values may be added-- you will typically want to compare if the value is greater or equal to a level you are interested in.To retrieve the processes current trim level at any point, you can use ActivityManager.getMyMemoryState(RunningAppProcessInfo).If you override this method you must call through to the superclass implementation.Parameterslevel int: The context of the trim, giving a hint of the amount of trimming the application may like to perform. 程序在进行内存清理时执行 其中参数level的选项定义在ComponentCallbacks2中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is nearing the end * of the background LRU list, and if more memory isn&apos;t found soon it will * be killed. */ static final int TRIM_MEMORY_COMPLETE = 80; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is around the middle * of the background LRU list; freeing memory can help the system keep * other processes running later in the list for better overall performance. */ static final int TRIM_MEMORY_MODERATE = 60; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process has gone on to the * LRU list. This is a good opportunity to clean up resources that can * efficiently and quickly be re-built if the user returns to the app. */ static final int TRIM_MEMORY_BACKGROUND = 40; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process had been showing * a user interface, and is no longer doing so. Large allocations with * the UI should be released at this point to allow memory to be better * managed. */ static final int TRIM_MEMORY_UI_HIDDEN = 20; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running extremely low on memory * and is about to not be able to keep any background processes running. * Your running process should free up as many non-critical resources as it * can to allow that memory to be used elsewhere. The next thing that * will happen after this is &#123;@link #onLowMemory()&#125; called to report that * nothing at all can be kept in the background, a situation that can start * to notably impact the user. */ static final int TRIM_MEMORY_RUNNING_CRITICAL = 15; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running low on memory. * Your running process should free up unneeded resources to allow that * memory to be used elsewhere. */ static final int TRIM_MEMORY_RUNNING_LOW = 10; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running moderately low on memory. * Your running process may want to release some unneeded resources for * use elsewhere. */ static final int TRIM_MEMORY_RUNNING_MODERATE = 5; TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理 TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。 TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。 TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。 TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存 TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存 TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存 不单单是Application具有这个回调。我们看Application的源码，可以发现其内部也调用Activity、Service的onLowMemory方法 123456789101112@CallSuperpublic void onTrimMemory(int level) &#123; Object[] callbacks = collectComponentCallbacks(); if (callbacks != null) &#123; for (int i=0; i&lt;callbacks.length; i++) &#123; Object c = callbacks[i]; if (c instanceof ComponentCallbacks2) &#123; ((ComponentCallbacks2)c).onTrimMemory(level); &#125; &#125; &#125;&#125; 其中@CallSuper说明所有重写onTrimMemory()方法的方法都要有super.onTrimMemory(); 可以实现OnTrimMemory回调的组件 12345Application.onTrimMemory()Activity.onTrimMemory()Fragement.OnTrimMemory()Service.onTrimMemory()ContentProvider.OnTrimMemory() OnTrimMemory和onStop的关系onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。需要注意的是，onTrimMemory的TRIM_MEMORY_UI_HIDDEN 等级是在onStop方法之前调用的． OnTrimMemory和OnLowMemory的关系？ 在引入OnTrimMemory之前都是使用OnLowMemory回调，需要知道的是，OnLowMemory大概和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同.如果你想兼容api&lt;14的机器，那么可以用OnLowMemory来实现，否则你可以忽略OnLowMemory，直接使用OnTrimMemory即可． 为什么要调用OnTrimMemory？ 尽管系统在内存不足的时候杀进程的顺序是按照LRU Cache中从低到高来的，但是它同时也会考虑杀掉那些占用内存较高的应用来让系统更快地获得更多的内存。所以如果你的应用占用内存较小，就可以增加不被杀掉的几率，从而快速地恢复（如果不被杀掉，启动的时候就是热启动，否则就是冷启动，其速度差在2~3倍）。所以说在几个不同的OnTrimMemory回调中释放自己的UI资源，可以有效地提高用户体验。 OnTrimMemory回调中可以释放哪些资源 有哪些典型的使用场景？ 常驻内存的应用一些常驻内存的应用，比如Launcher、安全中心、电话等，在用户使用过要退出的时候，需要调用OnTrimMemory来及时释放用户使用的时候所产生的多余的内存资源：比如动态生成的View、图片缓存、Fragment等。 有后台Service运行的应用 这些应用不是常驻内存的，意味着可以被任务管理器杀掉，但是在某些场景下用户不会去杀。这类应用包括：音乐、下载等。用户退出UI界面后，音乐还在继续播放，下载程序还在运行。这时候音乐应该释放部分UI资源和Cache。 一个比较实际的例子：用户打开登录页面，输入了用户名和密码，但是这时候按下了home键，几个小时后，系统内存不足将要啥事我们此时在后台存在的App进程，而我们想要用户再次打开这个app的登录页面时，能够保存用户已经输入的用户名和密码，这时候我们就可以回调登录Activity的onTrimMemory()方法，并保存输入的信息，待下次打开时重新回调显示。 onConfigurationChanged1234567891011void onConfigurationChanged (Configuration newConfig)Called by the system when the device configuration changes while your component is running. Note that, unlike activities, other components are never restarted when a configuration changes: they must always deal with the results of the change, such as by re-retrieving resources.At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.For more information, read Handling Runtime Changes.If you override this method you must call through to the superclass implementation.ParametersnewConfig Configuration: The new device configuration. 与activity不同，在配置改变时，应用程序对象不会被终止或重启。 如果应用程序使用的值依赖于特定的配置，则重写这个方法来重新加载这些值或者在应用程序级别处理配置改变。 注意事项 内存泄露 使用Application如果保存了一些不该保存的对象很容易导致内存泄漏。 如果在Application的oncreate中执行比较 耗时的操作，将直接影响的程序的启动时间。 不些清理工作不能依靠onTerminate完成，因为android会尽量让你的程序一直运行，所以很有可能 onTerminate不会被调用。 参考文档 官方API Android Application之onLowMemory与omTrimMemory Android代码内存优化建议-OnTrimMemory优化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的Parcel机制]]></title>
    <url>%2F2016%2F04%2F08%2FAndroid%E4%B8%AD%E7%9A%84Parcel%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述在Android系统中，定位为针对内存受限的设备，因此对性能要求更高，另外系统中采用了新的IPC（进程间通信）机制，必然要求使用性能更出色的对象传输方式。在这样的环境下， Parcel被设计出来，其定位就是轻量级的高效的对象序列化和反序列化机制。 Android中序列化有以下几个特征： 1. 整个读写全是在内存中进行，所以效率比JAVA序列化中使用外部存储器会高很多； 2. 读写时是4字节对齐的 3. 如果预分配的空间不够时，会一次多分配50%； 4. 对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。 Android序列化对象主要有两种方法，实现Serializable接口、或者实现Parcelable接口。实现Serializable接口是Java SE本身就支持的，而Parcelable是Android特有的功能，效率比实现Serializable接口高，而且还可以用在IPC中。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。下面就介绍一下实现Parcelable接口的方法 通过实现Parcelable接口序列化对象的步骤： 1、声明实现接口Parcelable 2、实现Parcelable的方法writeToParcel，将你的对象序列化为一个Parcel对象 3、实例化静态内部对象CREATOR实现接口Parcelable.Creator： 4、完成CREATOR的代码，实现方法createFromParcel，将Parcel对象反序列化为你的对象 简而言之：通过writeToParcel将你的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成你的对象。也可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面，在通过createFromParcel从流里读取对象，只不过这个过程需要你来实现，因此写的顺序和读的顺序必须一致。 实现了Bundle传递对象使用Bundle传递对象，首先要将其序列化，但是，在Android中要使用这种传递对象的方式需要用到Android Parcel机制，即，Android实现的轻量级的高效的对象序列化和反序列化机制。 JAVA中的Serialize机制，译成串行化、序列化……，其作用是能将数据对象存入字节流当中，在需要时重新生成对象。主要应用是利用外部存储设备保存对象状态，以及通过网络传输对象等 Parcel对象可以通过以下方法写入或读取byte, double, float, int, long, String这6种类型变量。123456writeByte(byte), readByte() writeDouble(double), readDouble() writeFloat(float), readFloat() writeInt(int), readInt() writeLong(long), readLong() writeString(String), readString() 也可以读取或写入他们的数组123456789101112 writeBooleanArray(boolean[]), readBooleanArray(boolean[]), createBooleanArray() writeByteArray(byte[]), writeByteArray(byte[], int, int), readByteArray(byte[]), createByteArray() writeCharArray(char[]), readCharArray(char[]), createCharArray() writeDoubleArray(double[]), readDoubleArray(double[]), createDoubleArray() writeFloatArray(float[]), readFloatArray(float[]), createFloatArray() writeIntArray(int[]), readIntArray(int[]), createIntArray() writeLongArray(long[]), readLongArray(long[]), createLongArray() writeStringArray(String[]), readStringArray(String[]), createStringArray() writeSparseBooleanArray(SparseBooleanArray), readSparseBooleanArray() ``` ## 更多操作可以参阅：http://developer.android.com/reference/android/os/Parcel.html package com.ipjmc.demo.parcelable; import java.util.Date; import android.os.Parcel; import android.os.Parcelable; public class ParcelableDate implements Parcelable { //声明实现接口Parcelable //这里定义了两个变量来说明读和写的顺序要一致 public long mId; public Date mDate; public ParcelableDate(long id, long time) { mId = id; mDate = new Date(time); } public ParcelableDate(Parcel source) { //先读取mId，再读取mDate mId = source.readLong(); mDate = new Date(source.readLong()); } @Override public int describeContents() { return 0; } //实现Parcelable的方法writeToParcel，将ParcelableDate序列化为一个Parcel对象 @Override public void writeToParcel(Parcel dest, int flags) { //先写入mId，再写入mDate dest.writeLong(mId); dest.writeLong(mDate.getTime()); } //实例化静态内部对象CREATOR实现接口Parcelable.Creator public static final Parcelable.Creator&lt;ParcelableDate&gt; CREATOR = new Creator&lt;ParcelableDate&gt;() { @Override public ParcelableDate[] newArray(int size) { return new ParcelableDate[size]; } //将Parcel对象反序列化为ParcelableDate @Override public ParcelableDate createFromParcel(Parcel source) { return new ParcelableDate(source); } }; } ```]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB使用详解]]></title>
    <url>%2F2016%2F03%2F08%2Fadb%2F</url>
    <content type="text"><![CDATA[说明Android Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components: A client, which runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as the ADT plugin and DDMS also create adb clients. A server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device. A daemon, which runs as a background process on each emulator or device instance. You can find the adb tool in /platform-tools/. When you start an adb client, the client first checks whether there is an adb server process already running. If there isn’t, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from adb clients—all adb clients use port 5037 to communicate with the adb server. The server then sets up connections to all running emulator/device instances. It locates emulator/device instances by scanning odd-numbered ports in the range 5555 to 5585, the range used by emulators/devices. Where the server finds an adb daemon, it sets up a connection to that port. Note that each emulator/device instance acquires a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for adb connections. For example: Emulator 1, console: 5554Emulator 1, adb: 5555Emulator 2, console: 5556Emulator 2, adb: 5557and so on… As shown, the emulator instance connected to adb on port 5555 is the same as the instance whose console listens on port 5554. Once the server has set up connections to all emulator instances, you can use adb commands to access those instances. Because the server manages connections to emulator/device instances and handles commands from multiple adb clients, you can control any emulator/device instance from any client (or from a script). 配置手机设置 -&gt; 版本 -&gt; 多次点击版本号（7次） -&gt; 退出进入开发者选项 -&gt; usb调试 语法adb [-d|-e|-s ] // use the -d, -e, or -s option to specify the target device to which the command should be directed. 常用命令 adb help adb devices adb root remount reboot adb shell 1234567adb shell input keyevent // 模拟键盘输入adb shell input touchscreen // 模拟滑动输入adb shell dumpsys //查看系统运行状态adb shell am start -n + 包名/包名+类名 // 启动一个activityadb shell screenrecord path // 录制屏幕 adb start-server/kill-server adb logcat adb push/pull adb install/unintall adb shell pm list packages // adb shell input keyevent x // 模拟屏幕点击事件 x为按键对应的数值 adb shell am start -n 进程/包名 adb shell inputusage: input … input text input keyevent input tap input swipe keyevent指的是Android对应的keycode，比如home键的keycode=3，back键的keycode=4. 具体请查阅 http://blog.csdn.net/huiguixian/article/details/8550170 然后使用的话比较简单，比如想模拟home按键： adb shell input keyevent 3 请查阅上述文章，根据具体keycode编辑即可。 关于tap的话，他模拟的是touch屏幕的事件，只需给出x、y坐标即可。 此x、y坐标对应的是真实的屏幕分辨率，所以要根据具体手机具体看，比如你想点击屏幕(x, y) = (250, 250)位置： adb shell input tap 250 250 关于swipe同tap是一样的，只是他是模拟滑动的事件，给出起点和终点的坐标即可。例如从屏幕(250, 250), 到屏幕(300, 300)即 adb shell input swipe 250 250 300 300 来源 /system/core/toolbox frameworks/base/cmds]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova插件开发之Toast]]></title>
    <url>%2F2015%2F02%2F08%2FCordova%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8BToast%2F</url>
    <content type="text"><![CDATA[概述Toast是Android中用来显示显示信息的一种机制，和Dialog不一样的是，Toast是没有焦点的，而且Toast显示的时间有限，过一定的时间就会自动消失。Toast可以有五种实现方式，这里只实现最简单的一种。 结构插件的文件结构如下，与官方的插件相比，省略了一些与实现功能无关的部分123456|- plugin.xml |- www | +- ToastPlugin.js +- src |- android | | - ToastPlugin.java 代码 src/android/ToastPlugin.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.dhyuestc.cordova.toast;import org.apache.cordova.CordovaPlugin;import org.apache.cordova.CallbackContext;import org.apache.cordova.CordovaInterface;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import android.widget.Toast;/***@author:dhyuestc*@date:2015-1-30*/public class ToastPlugin extends CordovaPlugin &#123; public ToastPlugin() &#123; &#125; @Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException &#123; if (this.cordova.getActivity().isFinishing()) return true; // 如果当前Activity关闭，则不显示Toast if (action.equals("show")) &#123; this.show(args.getString(0)); &#125; else if (action.equals("showlong")) &#123; this.showlong(args.getString(0)); &#125; else &#123; return false; &#125; callbackContext.success(); return true; &#125; public void show(String message) &#123; Toast.makeText(this.cordova.getActivity(),message,Toast.LENGTH_SHORT).show(); // 显示2s &#125; public void showlong(String message) &#123; Toast.makeText(this.cordova.getActivity(),message,Toast.LENGTH_LONG).show(); // 显示3.5s &#125;&#125;``` - www/ToastPlugin.js```bash/***ToastPlugin.js*@author:dhyuestc*@date:2015-1-30*/var exec = require('cordova/exec');var Toast = function () &#123;&#125;;/*** show*/Toast.prototype.show = function (message) &#123; var LocalMessage = (message || "Toast"); // exec(null,null,"ToastPlugin","show",[LocalMessage]); // console.log("Toast Message:" + message); // &#125;/*** showlong*/Toast.prototype.showlong = function (message) &#123; var LocalMessage = (message || "ToastLong"); exec(null,null,"ToastPlugin","showlong",[LocalMessage]); console.log("Long Toast Message:" + message);&#125;var toast = new Toast(); module.exports = toast; // plugin.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;plugin xmlns="http://apache.org/cordova/ns/plugins/1.0" id="com.dhyuestc.cordova.toast" version="0.0.1"&gt; &lt;name&gt;Toast&lt;/name&gt; &lt;description&gt;Cordova Toast Plugin&lt;/description&gt; &lt;license&gt;Apache 2.0&lt;/license&gt; &lt;keywords&gt;cordova,toast&lt;/keywords&gt; &lt;js-module src="www/ToastPlugin.js" name="toast"&gt; &lt;!-- src指向的js文件的路径 name自定义，无影响 --&gt; &lt;clobbers target="Toast" /&gt; &lt;!-- clobbers 代表我们在客户端调用的时候的实例名 --&gt; &lt;/js-module&gt; &lt;platform name="android"&gt; &lt;source-file src="src/android/ToastPlugin.java" target-dir="src/com/dhyuestc/cordova/toast" /&gt; &lt;!-- src 代表 Java 源文件的地址， target-dir 代表你要拷贝到项目中的地址 --&gt; &lt;config-file target="res/xml/config.xml" parent="/*"&gt; &lt;feature name="ToastPlugin"&gt; &lt;param name="android-package" value="com.dhyuestc.cordova.toast.ToastPlugin"/&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file target="AndroidManifest.xml" parent="/*"&gt; &lt;/config-file&gt; &lt;/platform&gt; &lt;/plugin&gt; 使用方法12$ Toast.show("显示2s");$ Toast.showlong("显示3.5s"); 注意问题参考文献Cordova：Toast浮动提示插件Plugin Development Guide 联系我如果你阅读完这篇文章，发现有任何问题或者建议，请及时反馈给我，多谢。]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ssh 配置出错，运行ssh -T git@github.com时 Permission denied(publickey)]]></title>
    <url>%2F2015%2F01%2F13%2Fgit%E9%85%8D%E7%BD%AESSH%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题概述 git 配置ssh Keys时，根据官方的步骤Generating SSH keys，生成的key配置后总是无效。 找错记录首先查看了官方的错误的解决提示:Error: Permission denied (publickey)运行下面的命令，运行结果如下图： 12345678 ssh -vT git@github.com ``` &lt;img src=&quot;/img/git_ssh_vt.jpg&quot; alt=&quot;&quot;&gt; 通过上面的信息，我们发现这里请求的是identity file /.ssh/id_rsa 但是，我之前保存的Key名称并不是id_rsa!到这里，大概就找到了解决办法。 ## 解决办法将我们生成的SSH文件改名为id_rsa。再次运行 &quot;ssh -T git@github.com&quot; 成功输出官方配置步骤上的结果 Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. ``` 联系我上面是我在配置git SSH时遇到的问题及解决问题的过程记录，希望对看到这篇文章的你有帮助，如果你发现这篇文章中有什么问题，或者你有其他的见解，请留言告知，多谢。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门之安装配置]]></title>
    <url>%2F2015%2F01%2F11%2Fnodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[官网地址node.js官方网址node.js官方下载地址 安装流程环境：Window 在官网下载到适合系统的最新的软件后，点击安装。windows的安装msi文件在过程中会直接添加path的系统变量。 安装过程比较简单，选择自己的安装路径（例如“D:\Program Files\nodejs”。）后一直NEXT就可以了。 安装完成后可以使用cmd测试下是否安装成功。方法：在cmd下输入 1node -v 出现下类似下图版本提示即为成功安装。 npm(the package manager for javascript.)的安装。新版的NodeJS已经集成了npm，可以使用cmd命令行输入 1npm -v 来测试是否成功安装,出现版本提示便OK了。 虽然npm已经安装好，但是为了更好的使用npm和node.js,有必要配置一番。 我们要先配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立”node_global”及”node_cache”两个文件夹。如下图： 启动cmd，分别输入下面两条命令（安装路径要改成你自己的），注意顺序，注意文件名和第一步新建的一致。 npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot; ``npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; `` 关闭cmd，修改环境变量，在系统变量*下新建”NODE_PATH”，内容为：D:\ProgramFiles\nodejs\node_global\node_modules 路径要确保是你自己的安装路径。同时，由于改变了module的默认地址，所以上面的用户变量（不是系统path）都要跟着改变一下（用户变量”PATH”修改为“D:\Program Files\nodejs\node_global\”）。 *以后使用npm安装常用的模块时加速参数 -g 这样这下模块就可以在全局使用了！ 现在，一个基本的NodeJS的环境搭建已经完成了，接下来就是我们喜闻乐见的hello，world信息的输出了。你可以在”cmd“输入”node“进入node开发模式下，输入你的NodeJS第一条命令语句：console.log(‘hello world’)。怎么样？看到熟悉的hello，world了没？ 常见模块的安装 express(Fast, unopinionated, minimalist web framework for Node.js):最常用的node.js web开发框架 1npm install express -g nodemon(nodemon reload, automatically.): 使用nodemon 运行node.js程序时，当变更内容时，会自动重启运行程序。也可以使用 1npm install -g nodemon 常见问题 运行”node -v”时如果提示’node’不是内部或者外部命令，也不是可以运行的程序，或者批处理文件，尝试重新打开cmd,或者重启电脑，这样环境变量才能生效。 使用module的时候出现输入命令出现“xxx不是内部或外部命令，也不是可运行的程序或批处理文件”这个错误。参考第5步，确保正确配置npm的路径。 Contact me如果你在阅读本文中发现任何问题，请留言告知我，多谢。 参考文章NodeJS、NPM安装配置步骤(windows版本) - 逍遥仔的日志 - 网易博客]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Hexo]]></title>
    <url>%2F2015%2F01%2F08%2Fhexo-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Clean1hexo clean Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
