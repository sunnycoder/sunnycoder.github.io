<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用android系统自带资源]]></title>
    <url>%2F2017%2F06%2F08%2F%E4%BD%BF%E7%94%A8android%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E8%B5%84%E6%BA%90%20%2F</url>
    <content type="text"><![CDATA[概述Android系统本身有很多的资源，包括各种各样的字符串、图片、动画、样式和布局等等，这些都可以在应用程序中直接使用。这样做的好处很多，既可以减少内存的使用，又可以减少部分工作量，也可以缩减程序安装包的大小。 Android各种资源123R.anim、R.animator、R.array、R.attr、R.bool、R.color、R.dimen、R.drawable、R.fractionR.id、R.integer、R.interpolator、R.layout、R.menu、R.mipmap、R.plurals、R.rawR.string、R.style、R.styleable、R.transition、R.xml 使用系统公开资源调用系统的样式，主题，动画资源等一般以@开头 使用@符号, 就可以在一个资源中引用另一个资源,使用android.R类中可用的系统的Android资源类, 则需要指定android作为包的名称, 使用”@android:”, 而不是”@”; 123android:theme=&quot;@android:style/Theme.Dialog&quot;android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; 调用attr下的资源设置view的属性，一般以?开头，比如： 123android:textColor=&quot;?android:attr/textColorPrimary&quot;style=&quot;?android:attr/progressBarStyleLarge&quot; @id和@+id区别@+id 新增一个资源id＠id和android：id，引用现有的资源id Android中的组件需要用一个int类型的值来表示，这个值就是组件标签中的id属性值。 id属性只能接受资源类型的值，也就是必须以@开头的值，例如，@id/abc、@+id/xyz等。 如果在@后面使用“+”，表示当修改完某个布局文件并保存后，系统会自动在R.java文件中生成相应的int类型变量。变量名就是“/”后面的值，例如，@+id/xyz会在R.java文件中生成int xyz = value，其中value是一个十六进制的数。如果xyz在R.java中已经存在同名的变量，就不再生成新的变量，而该组件会使用这个已存在的变量的值。 既然组件的id属性是一个资源id就可以，那么自然可以设置任何已经存在的资源id值，例如，@drawable/icon、@string/ok、@+string/you等。也可以设置android系统中已存在的资源id，例如@id/android:list，那么，这个android是什么意思呢，实际上，这个android就是系统的R类（在R.java文件中）所在的package。 我们可以在Java代码编辑区输入android.R.id.，就会列出相应的资源id，例如，也可以设置id属性值为@id/android:message。 利用系统定义的字符串资源123456 java: android.R.string.string_name XML: @string/string_name Resources.getString();``` ### 利用系统的图片资源 java: android.R.drawable.ImageName xml: android:icon=”@android:drawable/ImageName”12### 使用系统颜色 java: android.R.color.red xml: “@android:color/red” getResources().getColor()12### dimen资源 java R.dimen.dimen_name XML @dimen/dimen_name Resources.getDimension() 12### 使用系统Style android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; 12### XML资源 java: R.xml.xml_name Resources.getXml() 123## 使用系统隐藏资源Android中没有公开的资源，直接引用在编译时就会报错，需要使用特殊的方法。 int lebId = Resources.getSystem() .getIdentifier(&quot;permlab_accessNetworkState&quot;, &quot;string&quot;, &quot;android&quot;); String lab = getString(lebId); 12getIdentifier方法说明 /** * Return a resource identifier for the given resource name. A fully * qualified resource name is of the form &quot;package:type/entry&quot;. The first * two components (package and type) are optional if defType and * defPackage, respectively, are specified here. * * &lt;p&gt;Note: use of this function is discouraged. It is much more * efficient to retrieve resources by identifier than by name. * * @param name The name of the desired resource. * @param defType Optional default resource type to find, if &quot;type/&quot; is * not included in the name. Can be null to require an * explicit type. * @param defPackage Optional default package to find, if &quot;package:&quot; is * not included in the name. Can be null to require an * explicit package. * * @return int The associated resource identifier. Returns 0 if no such * resource was found. (0 is not a valid resource ID.) */ public int getIdentifier(String name, String defType, String defPackage) { return mResourcesImpl.getIdentifier(name, defType, defPackage); } ```]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>res</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sqlite3 使用详解]]></title>
    <url>%2F2017%2F05%2F08%2Fsqlite3%2F</url>
    <content type="text"><![CDATA[SQLite命令SQL(Structured Query Language)是一种标准的数据库查询语言，即所有的关系型数据库都会支持它，只不过每种数据库对SQL语言的支持与标准存在着细微的不同。我们无须关心其它数据库对SQL语言的支持情况，这里我们只要把重点放在SQLite上就可以了。下面我将使用模拟器来对SQLite支持的各种命令进行演示，如果你想用手机的话也可以，但要确保你的手机已经Root，并且包含sqlite3这个命令文件。 首先确保模拟器已经连接上了电脑，然后在命令行输入adb shell进入控制台，如下图所示： 注意#符号表示我们当前已经是超级用户了，如果显示的是$符号，表示当前只是普通用户而已，这时还需要输入su命令切换一下用户身份才行。 有了超级用户权限之后，我们能做的事情就很多了，这里我们先查看一下系统自带的联系人表吧。进入到/data/data目录下，如下图所示： 所有应用程序的本地存储文件都是存放在这个目录下面的。为了要让不同应用程序之间的数据容易区别开来，Android是使用应用程序包名进行分开管理，也就是说每个应用程序的本地存储文件都会存放在自己应用程序包名的那个目录下，这里我们ls一下看看有多少子目录： OK，确实有很多，毕竟手机上所有的应用程序都在这里。其中，com.android.providers.contacts中存放的就是联系人的相关数据，我们进入到这个目录再ls一下： 可以看到，目前有databases、files、lib和shared_prefs这几个子目录。其中databases肯定是用于存放数据库文件的，files是用于存放普通文本文件的，lib是用于存放so库的，shared_prefs则是用于存放shared文件的。这是Android数据持久化的几种可选方式，对这部分内容不太了解的朋友可以参考《第一行代码——Android》的第六章。 接着进入到databases目录中，再ls： 其中后缀名为journal的文件是日志文件，我们不用管，contacts2.db和profile.db才是真正的数据库文件，可以使用sqlite3命令来打开数据库，如下图所示： 好的，数据库已经打开了，那么我们怎么才能知道当前数据库中有哪些表呢？很简单，.table命令就可以做到了： 哇，竟然有这么多张表！是的，联系人的数据结构非常复杂，很多的数据都是分表存储的。这里我们随便挑一张表，比如说accounts表，如果我想知道这张表中有哪些列应该怎么办呢？在MySQL中可以使用desc accounts这个命令，但SQLite却不认识这个命令，毕竟它们是有差异化的。SQLite中可以使用pragma table_info(TABLE_NAME)这个命令来查看表的数据结构，如下图所示： 可以看到，一共显示了三条结果，表示accounts表中共有三列。但是，所有的字段都缩在了一行里面，并用“|”符号分隔，这样我们很难看出每个字段的含义。很简单，只需要换一种显示模式就行了，比如说line模式就挺不错的。输入.mode line命令切换显示模式，然后重新运行pragma命令，结果如下图所示： 怎么样，这样就清晰多了吧？这三列的列名分别是account_name、account_type和data_set，数据类型都是TEXT(字符串)，允许为空，并且都不是主键。好，那我现在想查一查accounts表中的数据呢？这就太简单了，使用select语句就可以了，如下所示： 恩？怎么只有一条空数据啊。貌似模拟器上默认就是这样的，如果你用的是手机的话，这里应该就可以查到真正的数据了。不过没关系，我们可以在设置里面手动添加一个邮箱账户，如下图所示： 现在再来重新查询一遍accounts表，如下所示： OK，添加的新账户已经成功查出来了。 除了查询命令之外，还有其它的增删改命令都和标准的SQL语法是相同的，即insert、delete和update，由于比较简单，我就不再赘述了。比较值得一提的是，每个SQLite数据库中都还有一个隐藏的sqlite_master表，这里记载了当前数据库中所有表的建表语句，可以使用select * from sqlite_master命令进行查看： 结果太多了是不是？一屏根本就显示不下嘛。不要着急，别忘了我们使用的是select命令，可以使用where语句来过滤出我们想要查询的那部分内容，如下图所示： OK，CREATE TABLE accounts (account_name TEXT, account_type TEXT, data_set TEXT) 这就是accounts表的建表语句了，通过这种方式我们可以查询到任意一张表的建表语句，从而对我们学习和分析数据库表结构有所帮助。 有些朋友可能会觉得，每次都要输入select命令来查询表中的数据太麻烦了。没错，而且还要保证手机是连接在电脑上的时候才能查询，确实太不方便。幸运的是，有些手机软件已经提供了数据库表查询的功能，使得我们随时随地都可以方便地查看数据库中的数据，比如Root Explorer这款软件就不错。 仍然是确保你的手机已经Root，然后安装Root Explorer，打开软件之后按照我们前面介绍的路径，进入/data/data/com.android.providers.contacts/databases，点击contacts2.db数据库，选择内置数据库查看器，然后随便点击一张表就可以查看到里面的数据了，如下图所示： sqlite3的常用命令12345678910111213141516.tables 显示所有表.schema 显示数据库的schema.schema table_name 显示表的schema.headers on 显示标题栏，即字段名栏，如在查看数据中数据时，默认select * from table_name不显示字段名。alter table 修改表。改变表名 - ALTER TABLE 旧表名 RENAME TO 新表名；增加一列 - ALTER TABLE 表名 ADD COLUMN 列名 数据类型 限定符select * from sqlite_master where type=&quot;table&quot;; 显示所有表的结构select * from sqlite_master where type=&quot;table&quot; and name=&quot;table_name&quot;; 显示某个表的结构drop table table_name 删除表.quit 退出.read FileName 执行FileName中的sql标准的sql语句也可以用，但必须用分号结束，如下select语句;delete语句;update语句;insert语句; 触发器 sqlite3 操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 建表CREATE TABLE COMPANY(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL);// 插入数据INSERT INTO COMPANY (ID,NAME,AGE) VALUES (1, &apos;AAA&apos;, 31);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (2, &apos;BBB&apos;, 32);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (3, &apos;CCC&apos;, 33);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (4, &apos;DDD&apos;, 34);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (5, &apos;EEE&apos;, 35);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (6, &apos;FFF&apos;, 36);INSERT INTO COMPANY (ID,NAME,AGE) VALUES (7, &apos;GGG&apos;, 37);// 查询1. select * from calls where type = 3 order by date desc;2. select count(*) from calls where type = 3 order by date desc; // 计算数目// 删除DELETE FROM COMPANY WHERE AGE = (SELECT AGE FROM COMPANY ORDER BY AGE DESC LIMIT 1 OFFSET 3);// 触发器// 删除第5条数据 ，同理 删除第21条数据则offset为20 limit为1 即限制条数为5条CREATE TRIGGER audit_log AFTER INSERT ON COMPANY BEGIN DELETE FROM COMPANY WHERE AGE = (SELECT AGE FROM COMPANY ORDER BY AGE DESC LIMIT 1 OFFSET 5); END;// 限制通话记录只保存最近 20 个未接电话,最近 20 个已接电话和最近 20 个呼出电话1. create trigger missed_call_count_limit after insert on Tables.CALLS begin delete from Tables.CALLS where Calls.DATE = (select Calls.DATE from Tables.CALLS where Calls.TYPE = MISSED_TYPE order by Calls.DATE desc limit 1 offset 5); end;&gt; 转换后的语句create trigger missed_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 3 order by date desc limit 1 offset 20); end;&gt; 去除换行的语句 // 1. 已接来电 create trigger incoming_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 1 order by date desc limit 1 offset 20); end;// 2.呼出电话 create trigger outgoing_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 2 order by date desc limit 1 offset 20); end; // 3. 未接来电 create trigger missed_call_count_limit after insert on calls begin delete from calls where date = (select date from calls where type = 3 order by date desc limit 1 offset 20); end; select count(*) from calls where type = 1 order by date desc; select count(*) from calls where type = 2 order by date desc; select count(*) from calls where type = 3 order by date desc; new&amp;&amp; old的问题 new是新插入的数据，old是原来的数据 insert只会有new，代表着要插入的新记录 delete只会有old，代表着要删除的记录 update由于执行的是先删除旧的记录，再插入新的记录，因此new和old都会有。 参考文档 http://www.yiibai.com/sqlite/sqlite_overview.html http://www.runoob.com/sqlite/sqlite-tutorial.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Toast源码解析]]></title>
    <url>%2F2017%2F03%2F08%2FToast%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Toast简介Toast是一种提供给用户简洁信息的视图，该视图已浮于应用程序之上的形式呈现给用户。Toast源码位于：frameworks\base\core\java\android\widget\Toast.java Toast使用Toast使用就一行代码：1Toast.makeText(ToastActivity.this,&quot;Toast源码解析&quot;,Toast.LENGTH_LONG).show(); Toast 提供了setView方法，可以自定义View：12345Toast toast=new Toast(ToastActivity.this);View view=View.inflate(ToastActivity.this,R.layout.toast_view,null);toast.setView(view);toast.setGravity(Gravity.CENTER,0,0);toast.show(); toast_view.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@mipmap/ic_launcher&quot; /&gt;&lt;/LinearLayout&gt; Toast源码分析Toast源码分析有两个目标，知道Toast源码在哪里体现了Toast显示，又在哪里体现了Toast消失。首先从Toast的基本使用，作为入口。1Toast.makeText(ToastActivity.this,&quot;Toast源码解析&quot;,Toast.LENGTH_LONG).show(); 1. makeText1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v;//传入下个view result.mDuration = duration;//Toast显示的时间长度 return result; &#125; makeText中的transient_notification.xml，源码位于：frameworks\base\core\res\layout\transient_notification.xml12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 从makeText方法看，就是Toast的自定义view的那部分代码。 2. show123456789101112131415161718public void show() &#123; //解释自定义view，需要先setView if (mNextView == null) &#123; throw new RuntimeException(&quot;setView must have been called&quot;); &#125; //得到INotificationManager服务 INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); //TN对象 TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; 看了show方法，发现涉及两个新的类，TN 和INotificationManager 。enqueueToast方法大概就是实现Toast显示和消失吧，让我们一步步探索。 2.1. TN123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141private static class TN extends ITransientNotification.Stub &#123; final Runnable mShow = new Runnable() &#123; @Override public void run() &#123; handleShow();//显示处理 &#125; &#125;; final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide();//消失处理 // Don&apos;t do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125; &#125;; //应用程序窗口 private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); final Handler mHandler = new Handler(); int mGravity;//出现在屏幕的位置 int mX, mY;//分别是出现在屏幕的X、Y方向偏移量 float mHorizontalMargin;//横向margin值 float mVerticalMargin;//竖向margin值 View mView;//当前view View mNextView;//下个Toast显示的view WindowManager mWM; //TN构造函数 TN() &#123; // XXX This should be changed to use a Dialog, with a Theme.Toast // defined that sets up the layout params appropriately. final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; // 不设置这个弹出框的透明遮罩显示为黑色 params.format = PixelFormat.TRANSLUCENT; // 动画 params.windowAnimations = com.android.internal.R.style.Animation_Toast; // 类型 params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle(&quot;Toast&quot;); // 设置flag params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; &#125; /** * schedule handleShow into the right thread */ @Override public void show() &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); &#125; //显示Toast public void handleShow() &#123; if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) &#123;//判断下个view是否一样 // remove the old view if necessary handleHide();//移除当前view mView = mNextView; Context context = mView.getContext().getApplicationContext();//获取当前view上下文 String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; //获得 WindowManager对象 mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); //获取绝对的Gravity final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView);//如果当前view存在，先移除 &#125; if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams);//通过WindowManager调用addView加载 trySendAccessibilityEvent(); &#125; &#125; private void trySendAccessibilityEvent() &#123; AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(mView.getContext()); if (!accessibilityManager.isEnabled()) &#123; return; &#125; // treat toasts as notifications since they are used to // announce a transient piece of information to the user AccessibilityEvent event = AccessibilityEvent.obtain( AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED); event.setClassName(getClass().getName()); event.setPackageName(mView.getContext().getPackageName()); mView.dispatchPopulateAccessibilityEvent(event); accessibilityManager.sendAccessibilityEvent(event); &#125; //WindowManager调用removeView方法来将Toast视图移除 public void handleHide() &#123; if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn&apos;t yet added, so let&apos;s try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); &#125; mView = null; &#125; &#125; &#125; TN类继承自ITransientNotification.Stub，ITransientNotification.aidl，用于进程间通信，源码位于frameworks\base\core\java\android\app\ITransientNotification.aidl12345/** @hide */oneway interface ITransientNotification &#123; void show(); void hide();&#125; 具体实现就在TN类，其他进程回调TN类，来操作Toast的显示和消失：1234567891011121314@Override public void show() &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow);//显示 &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide);//消失 &#125; 这里可以看出Toast显示和消失用的Handler机制实现的。 2.2. INotificationManager调用了getService，如下：123456789private static INotificationManager sService; static private INotificationManager getService() &#123; if (sService != null) &#123; return sService; &#125; sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; &#125; 得到INotificationManager服务，再调用enqueueToast方法，参数有三个，包名，TN，时间。INofiticationManager接口的具体实现类是NotificationManagerService类，源码位置：frameworks\base\services\core\java\com\android\server\notification\NotificationManagerService.java 2.3. enqueueToast1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) &#123; if (DBG) &#123; Slog.i(TAG, &quot;enqueueToast pkg=&quot; + pkg + &quot; callback=&quot; + callback + &quot; duration=&quot; + duration); &#125; if (pkg == null || callback == null) &#123; Slog.e(TAG, &quot;Not doing toast. pkg=&quot; + pkg + &quot; callback=&quot; + callback); return ; &#125; //(1)判断是否系统的Toast，如果当前包名是android则为系统 final boolean isSystemToast = isCallerSystem() || (&quot;android&quot;.equals(pkg)); //判断当前toast所属的pkg是不是所阻止的 if (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) &#123; if (!isSystemToast) &#123; Slog.e(TAG, &quot;Suppressing toast from package &quot; + pkg + &quot; by user request.&quot;); return; &#125; &#125; //入队列mToastQueue synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; //(2)判断Toast是否在队列当中 int index = indexOfToastLocked(pkg, callback); // If it&apos;s already in the queue, we update it in place, we don&apos;t // move it to the end of the queue. if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); &#125; else &#123; // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;//限制toasts数，最大50 Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; &#125; &#125; &#125; &#125; //获得ToastRecord对象 record = new ToastRecord(callingPid, pkg, callback, duration); //放入mToastQueue中 mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid);//(3)设置该Toast为前台进程 &#125; // If it&apos;s at index 0, it&apos;s the current toast. It doesn&apos;t matter if it&apos;s // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don&apos;t // assume that it&apos;s valid after this. if (index == 0) &#123; showNextToastLocked();//(4)直接显示Toast &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125; &#125; (1)判断是否系统的Toast，源码：12345678 private static boolean isCallerSystem() &#123; return isUidSystem(Binder.getCallingUid()); &#125;private static boolean isUidSystem(int uid) &#123; final int appid = UserHandle.getAppId(uid); //判断pid为系统进程使用的用户id，值为1000，或者为系统进程的手机的用户id，值为1001 return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID || uid == 0); &#125; (2)判断Toast是否在队列当中，源码：123456789101112131415// lock on mToastQueue int indexOfToastLocked(String pkg, ITransientNotification callback) &#123;// IBinder cbak = callback.asBinder(); ArrayList&lt;ToastRecord&gt; list = mToastQueue; int len = list.size(); for (int i=0; i&lt;len; i++) &#123; ToastRecord r = list.get(i); if (r.pkg.equals(pkg) &amp;&amp; r.callback.asBinder() == cbak) &#123; return i; &#125; &#125; return -1; &#125; (3)设置该Toast为前台进程，源码：12345678910111213141516171819// lock on mToastQueue void keepProcessAliveLocked(int pid) &#123; int toastCount = 0; // toasts from this pid ArrayList&lt;ToastRecord&gt; list = mToastQueue; int N = list.size(); for (int i=0; i&lt;N; i++) &#123; ToastRecord r = list.get(i); if (r.pid == pid) &#123; toastCount++; &#125; &#125; try &#123; //设置该Toast为前台进程 mAm.setProcessForeground(mForegroundToken, pid, toastCount &gt; 0); &#125; catch (RemoteException e) &#123; // Shouldn&apos;t happen. &#125; &#125; (4)直接显示Toast，源码：123456789101112131415161718192021222324252627282930313233343536void showNextToastLocked() &#123; //直接取第一个 ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try &#123; record.callback.show();//回调TN类，显示Toast scheduleTimeoutLocked(record);//设置消失 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) &#123; mToastQueue.remove(index); &#125; keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; record = mToastQueue.get(0); &#125; else &#123; record = null; &#125; &#125; &#125; &#125;private void scheduleTimeoutLocked(ToastRecord r) &#123; mHandler.removeCallbacksAndMessages(r);//移除ToastRecord Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); //static final int LONG_DELAY = 3500; // 3.5 seconds //static final int SHORT_DELAY = 2000; // 2 seconds long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; //发送Toast消失的message mHandler.sendMessageDelayed(m, delay); &#125; 从enqueueToast方法可知，先判断是不是系统和合法的Toast，然后判断是否在ToastQueue（这里解释了很多Toast，是一个个显示的），如果存在，只需要更新Toast显示的时间，如果不在，就直接显示，回调给TN类。到这里，知道了Toast是如何显示的。还没有结束，继续追踪mHandler，来到WorkerHandler ：123456789101112131415161718192021222324252627282930313233343536373839404142434445private final class WorkerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_TIMEOUT: handleTimeout((ToastRecord)msg.obj); break; …… &#125; &#125; &#125; private void handleTimeout(ToastRecord record) &#123; if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) &#123; //还是判断Toast是否在队列当中 int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) &#123; cancelToastLocked(index); &#125; &#125; &#125; void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide();//回调TN类，Toast消失 &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don&apos;t worry about this, we&apos;re about to remove it from // the list anyway &#125; mToastQueue.remove(index);//该ToastRecord对象从mToastQueue中移除 keepProcessAliveLocked(record.pid);//设置该Toast为前台进程 if (mToastQueue.size() &gt; 0) &#123; // Show the next one. If the callback fails, this will remove // it from the list, so don&apos;t assume that the list hasn&apos;t changed // after this point. showNextToastLocked();//继续show下个Toast &#125; &#125; 到这里，知道了Toast是如何消失的。Toast核心代码显示和消失源码分析完毕。 总结Toast代码调用只有一行，了解这行代码的背后，有个ToastQueue，进入队列之前，会做一些合法性判断，使用进程间通信进行回调，Handler机制显示和消失。自定义Toast时，需要调用setView，不然show会抛异常，这个从show方法就能得知。至此，Toast源码解析告一段落。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AAPT详解]]></title>
    <url>%2F2017%2F02%2F08%2Faapt%2F</url>
    <content type="text"><![CDATA[概述Android Asset Packaging Tool. 这两天处理的两个bug,都需要在device/sprd目录下配置不同board的资源文件定义。 这种修改后，一般需要自己verify一个版本，然后烧写版本确认修改是否生效。 但是因为iwhale2的烧机不稳定，我编译了好几个版本都不生效，遂放弃这种方式，打算另辟蹊径。 在肖韵涛的指点下，找到了一个简单的办法：通过verify生成的image进行解压，然后使用aapt命令查看资源文件的定义： 这个方案的两个关键点为解压image和查看apk中的资源文件中的定义 解包image方法1、在终端中进入存放XXX.img文件的目录中 2、输入sudo su，调用Linux的supre user权限，并按提示输入密码 3、建立新文件夹（这里用test）输入解包命令 12$ sudo mount -o rw,loop XXX.img test 4、解包完成 备注：使用上面的方案解压system.img成功，但是解压boot.image失败。 使用aapt工具使用下面的命令可以查看Dialer.apk中的资源文件定义 123aapt dump --values resources Dialer.apk &gt; dialer_dump // 获取Dialer.apk中的所有资源dumpgrep -rn config_voice_call_audiosource dialer_dump 更多使用方法 aapt l[ist] [-v] [-a] file.{zip,jar,apk}List contents of Zip-compatible archive.1.1 列出压缩文件目录aapt l 参数：-v:会以table的形式输出目录，table的表目有：Length、Method、Size、Ratio、Date、Time、CRC-32、Name。其中Method表示压缩形式，有：Deflate及Stored两种，即该Zip目录采用的算法是压缩模式还是存储模式；可以看出resources.arsc、*.png采用压缩模式，而其它采用压缩模式。Ratio表示压缩率。CRC-32未明其意，Sodino盼指教。 -a:会详细输出所有目录的内容。效果图：aapt_list.JPGlist aapt d[ump] [–values] WHAT file.{apk} [asset [asset …]]badging Print the label and icon for the app declared in APK.permissions Print the permissions from the APK.resources Print the resource table from the APK.configurations Print the configurations in the APK.xmltree Print the compiled xmls in the given assets.xmlstrings Print the strings of the given compiled xml assets. 2.1 查看apk包的packageName、versionCode、applicationLabel、launcherActivity、permission等各种详细信息aapt dump badging 效果图：aapt_dump_badging.JPGbadging 2.2 查看权限aapt dump permissions 效果图：aapt_dump_permissions.JPG permission 2.3 查看资源列表aapt dump resources 一般都会输出很多的信息，如要全部查看，请用下面这两句：aapt dump resources &gt; sodino.txtsodino.txt这样会把所有的信息通过重定向符”&gt;”输出到sodino.txt文件中，然后再打开该文件即可查看。 2.4 查看apk配置信息aapt dump configurations 2.5 查看指定apk的指定xml文件。aapt dump xmltree res/.xml以树形结构输出的xml信息。aapt dump xmlstrings res/.xml输出xml文件中所有的字符串信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// man aaptaapt(1) General Commands Manual aapt(1)NAME aapt - Android Asset Packaging ToolSYNOPSIS aapt command [ options ] files ... aapt l[ist] [-v] [-a] file.&#123;zip,jar,apk&#125; List contents of Zip-compatible archive. aapt d[ump] [--values] WHAT file.&#123;apk&#125; [asset [asset ...]] strings Print the contents of the resource table string pool in the APK. badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. aapt p[ackage] [-d] [-f] [-m] [-u] [-v] [-x] [-z] [-M AndroidManifest.xml] [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] [--debug-mode] [--min-sdk-version VAL] [--target-sdk-version VAL] [--app-version VAL] [--app-version-name TEXT] [--custom-package VAL] [--rename-manifest-package PACKAGE] [--rename-instrumentation-target-package PACKAGE] [--utf16] [--auto-add-overlay] [--max-res-version VAL] [-I base-package [-I base-package ...]] [-A asset-source-dir] [-G class-list-file] [-P public-definitions-file] [-S resource-sources [-S resource-sources ...]] [-F apk-file] [-J R-file-dir] [--product product1,product2,...] [-c CONFIGS] [--preferred-configurations CONFIGS] [raw-files-dir [raw-files-dir] ...] [--output-text-symbols DIR] Package the android resources. It will read assets and resources that are supplied with the -M -A -S or raw-files-dir arguments. The -J -P -F and -R options control which files are output. aapt r[emove] [-v] file.&#123;zip,jar,apk&#125; file1 [file2 ...] Delete specified files from Zip-compatible archive. aapt a[dd] [-v] file.&#123;zip,jar,apk&#125; file1 [file2 ...] Add specified files to Zip-compatible archive. aapt c[runch] [-v] -S resource-sources ... -C output-folder ... Do PNG preprocessing on one or several resource folders and store the results in the output folder. aapt s[ingleCrunch] [-v] -i input-file -o outputfile Do PNG preprocessing on a single file. aapt v[ersion] Print program version.DESCRIPTION The Android Asset Packaging Tool (aapt) takes your application resource files, such as the AndroidManifest.xml file and the XML files for your Activities, and compiles them. An R.java is also produced so you can reference your resources from your Java code.OPTIONS A summary of options is included below. -a print Android-specific data (resources, manifest) when listing -c specify which configurations to include. The default is all configurations. The value of the parameter should be a comma separated list of configuration values. Locales should be specified as either a language or language-region pair. Some examples: en port,en port,land,en_US If you put the special locale, zz_ZZ on the list, it will perform pseudolocalization on the default locale, modifying all of the strings so you can look for strings that missed the internationalization process. For example: port,land,zz_ZZ -d one or more device assets to include, separated by commas -f force overwrite of existing files -g specify a pixel tolerance to force images to grayscale, default 0 -j specify a jar or zip file containing classes to include -k junk path of file(s) added -m make package directories under location specified by -J -u update existing packages (add new, replace older, remove deleted files) -v verbose output -x create extending (non-application) resource IDs -z require localization of resource attributes marked with localization=&quot;suggested&quot; -A additional directory in which to find raw asset files -G A file to output proguard options into. -F specify the apk file to output -I add an existing package to base include set -J specify where to output R.java resource constant definitions -M specify full path to AndroidManifest.xml to include in zip -P specify where to output public resource definitions -S directory in which to find resources. Multiple directories will be scanned and the first match found (left to right) will take precedence. -0 specifies an additional extension for which such files will not be stored compressed in the .apk. An empty string means to not compress any files at all. --debug-mode inserts android:debuggable=&quot;true&quot; in to the application node of the manifest, making the application debuggable even on production devices. --min-sdk-version inserts android:minSdkVersion in to manifest. If the version is 7 or higher, the default encoding for resources will be in UTF-8. --target-sdk-version inserts android:targetSdkVersion in to manifest. --max-res-version ignores versioned resource directories above the given value. --values when used with &quot;dump resources&quot; also includes resource values. --version-code inserts android:versionCode in to manifest. --version-name inserts android:versionName in to manifest. --custom-package generates R.java into a different package. --extra-packages generate R.java for libraries. Separate libraries with &apos;:&apos;. --generate-dependencies generate dependency files in the same directories for R.java and resource package --auto-add-overlay Automatically add resources that are only in overlays. --preferred-configurations Like the -c option for filtering out unneeded configurations, but only expresses a preference. If there is no resource available with the preferred configuration then it will not be stripped. --rename-manifest-package Rewrite the manifest so that its package name is the package name given here. Relative class names (for example .Foo) will be changed to absolute names with the old package so that the code does not need to change. --rename-instrumentation-target-package Rewrite the manifest so that all of its instrumentation components target the given package. Useful when used in conjunction with --rename-manifest-package to fix tests against a package that has been renamed. --product Specifies which variant to choose for strings that have product variants --utf16 changes default encoding for resources to UTF-16. Only useful when API level is set to 7 or higher where the default encoding is UTF-8. --non-constant-id Make the resources ID non constant. This is required to make an R java class that does not contain the final value but is used to make reusable compiled libraries that need to access resources. --error-on-failed-insert Forces aapt to return an error if it fails to insert values into the manifest with --debug-mode, --min-sdk-version, --target-sdk-version --version-code and --version-name. Insertion typically fails if the manifest already defines the attribute. --output-text-symbols Generates a text file containing the resource symbols of the R class in the specified folder. --ignore-assets Assets to be ignored.AUTHOR aapt was written by The Android Open Source Project. October 15, 2014 aapt(1) Manual page aapt(1) line 127/185 (END) (press h for help or q to quit)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AAPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SoundPool使用详解]]></title>
    <url>%2F2017%2F02%2F08%2FSoundPool%2F</url>
    <content type="text"><![CDATA[概述SoundPool类管理和播放用于应用程序的音频资源。 SoundPool是一个示例集合，可以从APK或文件系统中的文件中加载到内存中。SoundPool库使用MediaPlayer服务将音频解码为原始的16位PCM mono或立体声流。这使得应用程序可以使用压缩流进行传输，而不必在回放期间承受CPU负载和解压的延迟。 除了低延迟回放，SoundPool还可以管理一次呈现的音频流的数量。当构造SoundPool对象时，maxStreams参数可以设置从这个单一的声音池中可以播放的最大的流数。SoundPool跟踪活动流的数量。如果超过了最大的流，SoundPool将自动停止先前播放的基于优先级的流，然后在此优先级按时间先后进行。限制最大数量的流有助于限制CPU的负载，降低音频混合将影响可视化或UI性能的可能性。 声音可以通过设置非零循环值来循环。-1会导致声音永远循环。在这种情况下，应用程序必须显式调用stop()函数来停止声音。任何其他非零值都会导致声音重复指定的次数，例如，值3使声音总共播放4次。 回放速率也可以改变。一个回放速率的1.0使声音在原来的频率播放(如果需要的话，重新采样，到硬件输出频率)。回放速率2.0使声音的播放频率是原来的两倍，而回放速率0.5使其播放的频率为原来的一半。回放速率范围是0.5到2.0。 按照优先级低至高，更大的数字即更高的优先级。当调用play()会导致将导致活动流的数量超过maxStreams参数所建立的值时，将会使用优先级。在这种情况下，流分配器将停止最低优先级流。如果有同样低优先级的多个流，它将选择最先播放的流停止。如果新流的优先级低于所有的活动流，那么新的声音将不会播放，play()函数将返回0。 让我们来看看一个典型的用例:一个游戏由几个级别的关卡组成。对于每一个关卡，都有一组独特的声音，只在这个关卡上使用。在这种情况下，当第一关加载时，游戏逻辑应该创建一个新的SoundPool对象。一个关卡的数据可能包含这个级别所使用的声音列表。加载逻辑通过调用适当的soundpool.load()函数列表来迭代。这通常应该在早期进行，以便在需要进行回放之前将音频压缩到原始的PCM格式load需要一定时间，load完成会回调SoundPool.OnLoadCompleteListener。 一旦声音加载并开始播放，应用程序就可以通过调用soundpool . play()触发声音。播放流可以暂停或恢复，应用程序也可以通过调整回放速率对多普勒或综合效果进行实时调整，从而改变音高。 注意，由于资源限制，流可以被停止，所以streamID是对流的一个特定实例的引用。如果一个流被停止以便更高的优先级流播放，这个流就不再有效。但是，应用程序调用方法操作这个streamID也不会报错。这可能有助于简化程序逻辑，因为应用程序不必关心流生命周期。 在我们的示例中，当玩家完成了这个关卡，游戏逻辑应该调用SoundPool.release()释放所有使用的本地资源，然后将SoundPool引用设置为null。如果播放器启动另一个级别，将创建一个新的SoundPool，加载声音，并播放resumes。 综上所述，可以归纳为一下几点： SoundPool使用音效池的概念来管理多个短促的音效 SoundPool主要用于播放一些较适合播放密集、急促而又短暂的声音片段（如游戏音效），与MediaPlayer相比，SoundPool的优势在于CPU资源占用量低和反应延迟小。 SoundPool还支持自行设置声音的品质、音量、 播放比率等参数。 构造方法12345678910111213141516added in API level 1SoundPool (int maxStreams, int streamType, int srcQuality)This constructor was deprecated in API level 21.use SoundPool.Builder instead to create and configure a SoundPool instanceConstructor. Constructs a SoundPool object with the following characteristics:ParametersmaxStreams int: the maximum number of simultaneous streams for this SoundPool objectstreamType int: the audio stream type as described in AudioManager For example, game applications will normally use STREAM_MUSIC.srcQuality int: the sample-rate converter quality. Currently has no effect. Use 0 for the default. 第一个参数maxStreams指定支持同时播放多少个声音；第二个参数streamType指定声音类型（一般为STREAM_MUSIC，参见AudioManager中的定义）：第三个参数srcQuality指定声音品质，暂时没用。现在官方推荐的是是Builder模式方式。 123456789101112Public constructorsSoundPool.Builder()Constructs a new Builder with the defaults format values.Public methodsSoundPool build()SoundPool.Builder setAudioAttributes(AudioAttributes attributes)Sets the AudioAttributes.SoundPool.Builder setMaxStreams(int maxStreams)Sets the maximum of number of simultaneous streams that can be played simultaneously. loadSoundPool提供了如下4个load方法：1234567int load(Context context, int resId, int priority) // Load the sound from the specified APK resource.int load(String path, int priority) //Load the sound from the specified path.int load(AssetFileDescriptor afd, int priority) // Load the sound from an asset file descriptor.int load(FileDescriptor fd, long offset, long length, int priority) // Load the sound from a FileDescriptor. int load(Context context, int resld, int priority)：从 resld 所对应的资源加载声音。一般我们将声音信息保存在res的raw文件夹下 int load(FileDescriptor fd, long offset, long length, int priority)：加载 fd 所对应的文件的offset开始、长度为length的声音。 int load(AssetFileDescriptor afd, int priority)：从afd 所对应的文件中加载声音。 int load(String path, int priority)：从path 对应的文件去加载声音。 上面4个方法中都有一个priority参数，该参数目前还没有任何作用，Android建议将该 参数设为1，保持和未来的兼容性。 上面4个方法加载声音之后，都会返回该声音的的ID，以后程序就可以通过该声音的ID 来播放指定声音。 play123456789101112131415161718192021222324252627playadded in API level 1int play (int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate)Play a sound from a sound ID. Play the sound specified by the soundID. This is the value returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don&apos;t loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.ParameterssoundID int: a soundID returned by the load() functionleftVolume float: left volume value (range = 0.0 to 1.0)rightVolume float: right volume value (range = 0.0 to 1.0)priority int: stream priority (0 = lowest priority)loop int: loop mode (0 = no loop, -1 = loop forever)rate float: playback rate (1.0 = normal playback, range 0.5 to 2.0)Returnsint non-zero streamID if successful, zero if failed 第一个参数为id，id即为放入到soundPool中的顺序。为load方法返回的streamID第二个和第三个参数为左右声道的音量控制。第四个参数为优先级，第五个参数为是否循环播放，0为不循环，-1为循环。最后一个参数为播放比率，从0.5到2，一般为1，表示正常播放。 返回非0的值说明播放成功，返回0说明播放失败。 onLoadComplete123456789101112onLoadCompletevoid onLoadComplete (SoundPool soundPool, int sampleId, int status)Called when a sound has completed loading.ParameterssoundPool SoundPool: SoundPool object from the load() methodsampleId int: the sample ID of the sound loaded.status int: the status of the load operation (0 = success) 第二个参数sampleId 和 SoundPool.load 返回的参数是一样的。 使用流程 创建SoundPool对象，目前官方推荐使用Build模式创建，但是Android源码中依然是之前的方式12private final SoundPool mSoundPool;mSoundPool = new SoundPool(1 /* max streams */,AudioSystem.STREAM_MUSIC /* audioType */, 0 /* quality */); 或者使用官方推荐的Builder模式，因为第三个参数quality实际不起作用，Builder中只有设置两个参数的方法。1234SoundPool soundPool = new SoundPool.Builder() .setMaxStreams(1) .setAudioAttributes(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); 加载音频文件如上面提到的，加载音频文件有四种方法，比较常用的是下面的指定资源id的方式，资源文件一般放在’/res/raw/‘目录下面 1234567private int loadSound(int resId, int priority) &#123; int id = mSoundPool.load(getApplicationContext(), resId, priority); if (id == 0) &#123; Log.e(LOG_TAG, &quot;Unable to open resource&quot;); &#125; return id;&#125; 一个SoundPool类实例能同时管理多个音频，所以可以通过多次调用load(…)方法来加载.如果加载成功则返回一个非0的soundID ，用于播放时指定具体的音频流。在实际应用中，若音频文件过多，那借助HashMap或者数组会方便很多。 12345678910``` soundPool musicId =new SoundPool(12, 0,5);//通过load方法加载指定音频流，并将返回的音频ID放入musicId中musicId.put(1, soundPool.load(this, R.raw.awooga, 1));musicId.put(2, soundPool.load(this, R.raw.evillaugh, 1));musicId.put(3, soundPool.load(this, R.raw.jackinthebox, 1)); 12 // load sounds synchronized(mSoundPool) { for (int index = 0; index &lt; numSounds; index++) { mSounds[index] = loadSound(mTestFiles[index], NORMAL_PRIORITY); mLastSample = mSounds[index]; } mSoundPool.wait(); } 123需要注意的是，流的加载过程是一个将音频解压为原始16位PCM数据，由一个后台线程通过异步处理的过程。因此，初始化后并不能立即播放，需要等待一点时间。加载完成后会回调setOnLoadCompleteListener，所以我们会在本地监听这个回调，在load完成后做相应的操作 mSoundPool.setOnLoadCompleteListener(new LoadCompleteCallback()); private final class LoadCompleteCallback implements android.media.SoundPool.OnLoadCompleteListener { public void onLoadComplete(SoundPool soundPool, int sampleId, int status) { synchronized(mSoundPool) { if (DEBUG) Log.d(LOG_TAG, &quot;Sample &quot; + sampleId + &quot; load status = &quot; + status); if (status != 0) { mLoadStatus = status; } if (sampleId == mLastSample) { mSoundPool.notify(); } } } } 123453. 播放控制资源加载完成后，我们就可以对生成的音频流进行播放控制，播放 int id = mSoundPool.play(mSounds[index], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); 12暂停(pause) mSoundPool.pause(id);12恢复(resume) mSoundPool.resume(id);12停止(stop) mSoundPool.stop(id);123456789101112131415164. 属性设置 通过独立的方法来设置传递给播放函数paly()的一些参数，主要是后面四个参数。 final void setLoop(int streamID, int loop)，设置指定播放流的循环； final void setVolume(int streamID, float leftVolume, float rightVolume)，设置指定播放流的音量； final void setPriority(int streamID, int priority)，设置指定播放流的优先级，上面已说明priority的作用； final void setRate(int streamID, float rate)，设置指定播放流的速率，0.5-2.0；5. 释放资源一般用到以下两个函数 final boolean unload(int soundID)，卸载一个指定的音频资源； final void release()，释放SoundPool中的所有音频资源；1234567891011121314151617181920212223242526272829## 使用心得1、pause()、resume()和stop()是针对播放流操作的，传递的是play()返回的streamID ;2、play()中的priority参数，只在同时播放的流的数量超过了预先设定的最大数量是起作用，管理器将自动终止优先级低的播放流。 如果存在多个同样优先级的流，再进一步根据其创建事件来处理，新创建的流的年龄是最小的，将被终止；3、同时播放多个音频，通过play()函数，成功则返回非0的streamID;4、当设置为无限循环时，需要手动调用stop()来终止播放;5、播放流的优先级(play()中的priority参数)，只在同时播放数超过设定的最大数时起作用;6、程序中不用考虑（play触发的）播放流的生命周期，无效的soundID/streamID不会导致程序错误。无论如何，程序退出时，手动终止播放并释放资源是必要的。 ## 注意事项1. 文件太大，导致加载失败，播放不生效，可以通过OnLoadCompleteListener回调方法的参数status确定是否加载成功，记载成功返回0，失败则返回其他错误码。2. SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此应该避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑使用SoundPool进行播放。3. 虽然SoundPool比MediaPlayer的效果好，但也不是绝对不存在延迟问题，尤其在那些性能不太好的手机中，SoundPool的延迟问题会更严重。## 与MediaPlayer对比响应速度文件大小适合场景SoundPool适合短且对反应速度比较高的情况（游戏音效或按键声等），文件大小一般控制在几十K到几百K，最好不超过1M，可以与MediaPlayer同时播放，SoundPool也可以同时播放多个声音；最终编解码实现与MediaPlayer相同；MediaPlayer只能同时播放一个声音，加载文件有一定的时间，适合文件比较大，响应时间要是不是非常高的场景； ## 实例代码 /* Copyright (c) 2009, Google Inc.* Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at* http://www.apache.org/licenses/LICENSE-2.0* Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.*/ package com.android.soundpooltest; import android.app.Activity;import android.widget.LinearLayout;import android.os.Bundle;import android.view.ViewGroup;import android.widget.Button;import android.view.View;import android.view.View.OnClickListener;import android.view.KeyEvent;import android.media.AudioSystem;import android.media.AudioManager;import android.media.SoundPool;import android.media.SoundPool.OnLoadCompleteListener;import android.util.Log;import java.util.HashMap;import java.lang.Math; import com.android.soundpooltest.R; public class SoundPoolTest extends Activity{ private static final String LOG_TAG = “SoundPoolTest”; private static final boolean DEBUG = true; private static final boolean VERBOSE = false; private TestThread mThread; private static final int[] mTestFiles = new int[] { R.raw.organ441, R.raw.sine441, R.raw.test1, R.raw.test2, R.raw.test3, R.raw.test4, R.raw.test5 }; private final static float SEMITONE = 1.059463094f; private final static float DEFAULT_VOLUME = 0.707f; private final static float MAX_VOLUME = 1.0f; private final static float MIN_VOLUME = 0.01f; private final static int LOW_PRIORITY = 1000; private final static int NORMAL_PRIORITY = 2000; private final static int HIGH_PRIORITY = 3000; private final static int DEFAULT_LOOP = -1; private final static int DEFAULT_SRC_QUALITY = 0; private final static double PI_OVER_2 = Math.PI / 2.0; public SoundPoolTest() {} private final class TestThread extends java.lang.Thread { private boolean mRunning; private SoundPool mSoundPool = null; private int mLastSample; private int mMaxStreams; private int mLoadStatus; private int[] mSounds; private float mScale[]; TestThread() { super(&quot;SoundPool.TestThread&quot;); } private final class LoadCompleteCallback implements android.media.SoundPool.OnLoadCompleteListener { public void onLoadComplete(SoundPool soundPool, int sampleId, int status) { synchronized(mSoundPool) { if (DEBUG) Log.d(LOG_TAG, &quot;Sample &quot; + sampleId + &quot; load status = &quot; + status); if (status != 0) { mLoadStatus = status; } if (sampleId == mLastSample) { mSoundPool.notify(); } } } } private int loadSound(int resId, int priority) { int id = mSoundPool.load(getApplicationContext(), resId, priority); if (id == 0) { Log.e(LOG_TAG, &quot;Unable to open resource&quot;); } return id; } private int initSoundPool(int numStreams) throws java.lang.InterruptedException { if (mSoundPool != null) { if ((mMaxStreams == numStreams) &amp;&amp; (mLoadStatus == 0)) return mLoadStatus; mSoundPool.release(); mSoundPool = null; } // create sound pool mLoadStatus = 0; mMaxStreams = numStreams; mSoundPool = new SoundPool(numStreams, AudioSystem.STREAM_MUSIC, 0); mSoundPool.setOnLoadCompleteListener(new LoadCompleteCallback()); int numSounds = mTestFiles.length; mSounds = new int[numSounds]; // load sounds synchronized(mSoundPool) { for (int index = 0; index &lt; numSounds; index++) { mSounds[index] = loadSound(mTestFiles[index], NORMAL_PRIORITY); mLastSample = mSounds[index]; } mSoundPool.wait(); } return mLoadStatus; } private boolean TestSounds() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin sounds test&quot;); int count = mSounds.length; for (int index = 0; index &lt; count; index++) { int id = mSoundPool.play(mSounds[index], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(450); mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); sleep(50); } if (DEBUG) Log.d(LOG_TAG, &quot;End sounds test&quot;); return true; } private boolean TestScales() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin scale test&quot;); // interate through pitch table int count = mScale.length; for (int step = 0; step &lt; count; step++) { int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[step]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(450); mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); sleep(50); } if (DEBUG) Log.d(LOG_TAG, &quot;End scale test&quot;); return true; } private boolean TestRates() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin rate test&quot;); // start the note int count = mScale.length; int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[0]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Test failed - exiting&quot;); return false; } // modify the pitch for (int step = 1; step &lt; count; step++) { sleep(250); mSoundPool.setRate(id, mScale[step]); if (DEBUG) Log.d(LOG_TAG, &quot;Change rate &quot; + mScale[step]); } mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); if (DEBUG) Log.d(LOG_TAG, &quot;End rate test&quot;); return true; } private boolean TestPriority() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin priority test&quot;); boolean result = true; // play a normal priority looping sound int normalId = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + normalId); if (normalId == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(1000); // play a low priority sound int id = mSoundPool.play(mSounds[1], DEFAULT_VOLUME, DEFAULT_VOLUME, LOW_PRIORITY, DEFAULT_LOOP, 1.0f); if (id != 0) { Log.e(LOG_TAG, &quot;Normal &gt; Low priority test failed&quot;); result = false; mSoundPool.stop(id); } else { sleep(1000); Log.i(LOG_TAG, &quot;Normal &gt; Low priority test passed&quot;); } // play a high priority sound id = mSoundPool.play(mSounds[2], DEFAULT_VOLUME, DEFAULT_VOLUME, HIGH_PRIORITY, DEFAULT_LOOP, 1.0f); if (id == 0) { Log.e(LOG_TAG, &quot;High &gt; Normal priority test failed&quot;); result = false; } else { sleep(1000); Log.i(LOG_TAG, &quot;Stopping high priority&quot;); mSoundPool.stop(id); sleep(1000); Log.i(LOG_TAG, &quot;High &gt; Normal priority test passed&quot;); } // stop normal note Log.i(LOG_TAG, &quot;Stopping normal priority&quot;); mSoundPool.stop(normalId); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;End priority test&quot;); return result; } private boolean TestPauseResume() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin pause/resume test&quot;); boolean result = true; // play a normal priority looping sound int id = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, 1.0f); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(2500); // pause and resume sound a few times for (int count = 0; count &lt; 5; count++) { if (DEBUG) Log.d(LOG_TAG, &quot;Pause note &quot; + id); mSoundPool.pause(id); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;Resume note &quot; + id); mSoundPool.resume(id); sleep(1000); } if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + id); mSoundPool.stop(id); sleep(1000); // play 5 sounds, forces one to be stolen int ids[] = new int[5]; for (int i = 0; i &lt; 5; i++) { ids[i] = mSoundPool.play(mSounds[0], DEFAULT_VOLUME, DEFAULT_VOLUME, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[i]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + ids[i]); if (ids[i] == 0) { Log.e(LOG_TAG, &quot;Error occurred starting note&quot;); return false; } sleep(1000); } // pause and resume sound a few times for (int count = 0; count &lt; 5; count++) { if (DEBUG) Log.d(LOG_TAG, &quot;autoPause&quot;); mSoundPool.autoPause(); sleep(1000); if (DEBUG) Log.d(LOG_TAG, &quot;autoResume&quot;); mSoundPool.autoResume(); sleep(1000); } for (int i = 0; i &lt; 5; i++) { if (DEBUG) Log.d(LOG_TAG, &quot;Stop note &quot; + ids[i]); mSoundPool.stop(ids[i]); } if (DEBUG) Log.d(LOG_TAG, &quot;End pause/resume test&quot;); return result; } private boolean TestVolume() throws java.lang.InterruptedException { if (DEBUG) Log.d(LOG_TAG, &quot;Begin volume test&quot;); // start the note int id = mSoundPool.play(mSounds[0], 0.0f, 1.0f, NORMAL_PRIORITY, DEFAULT_LOOP, mScale[0]); if (DEBUG) Log.d(LOG_TAG, &quot;Start note &quot; + id); if (id == 0) { Log.e(LOG_TAG, &quot;Test failed - exiting&quot;); return false; } // pan from right to left for (int count = 0; count &lt; 101; count++) { sleep(50); double radians = PI_OVER_2 * count / 100.0; float leftVolume = (float) Math.sin(radians); float rightVolume = (float) Math.cos(radians); mSoundPool.setVolume(id, leftVolume, rightVolume); if (DEBUG) Log.d(LOG_TAG, &quot;Change volume (&quot; + leftVolume + &quot;,&quot; + rightVolume + &quot;)&quot;); } mSoundPool.stop(id); if (DEBUG) Log.d(LOG_TAG, &quot;End volume test&quot;); return true; } public void run() { if (DEBUG) Log.d(LOG_TAG, &quot;Test thread running&quot;); // initialize mRunning = true; int failures = 0; // initialize pitch table float pitch = 0.5f; mScale = new float[13]; for (int i = 0; i &lt; 13; ++i) { mScale[i] = pitch; pitch *= SEMITONE; } try { // do single stream tests initSoundPool(1); if (!TestSounds()) failures = failures + 1; if (!TestScales()) failures = failures + 1; if (!TestRates()) failures = failures + 1; if (!TestPriority()) failures = failures + 1; if (!TestVolume()) failures = failures + 1; // do multiple stream tests initSoundPool(4); if (!TestPauseResume()) failures = failures + 1; } catch (java.lang.InterruptedException e) { if (DEBUG) Log.d(LOG_TAG, &quot;Test interrupted&quot;); failures = failures + 1; } finally { mRunning = false; } // release sound pool if (mSoundPool != null) { mSoundPool.release(); mSoundPool = null; } // output stats if (DEBUG) Log.d(LOG_TAG, &quot;Test thread exit&quot;); if (failures == 0) { Log.i(LOG_TAG, &quot;All tests passed&quot;); } else { Log.i(LOG_TAG, failures + &quot; tests failed&quot;); } } public void quit() { if (DEBUG) Log.d(LOG_TAG, &quot;interrupt&quot;); interrupt(); while (mRunning) { try { sleep(20); } catch (java.lang.InterruptedException e) { } } if (DEBUG) Log.d(LOG_TAG, &quot;quit&quot;); } } private void startTests() { mThread = new TestThread(); mThread.start(); } protected void onPause() { Log.v(LOG_TAG, &quot;onPause&quot;); super.onPause(); mThread.quit(); mThread = null; } protected void onResume() { Log.v(LOG_TAG, &quot;onResume&quot;); super.onResume(); startTests(); } public void onCreate(Bundle icicle) { super.onCreate(icicle); setVolumeControlStream(AudioManager.STREAM_MUSIC); } } ``` 参考文档 http://www.android-doc.com/reference/android/media/SoundPool.html http://www.cnblogs.com/tgyf/p/4740003.html http://gqdy365.iteye.com/blog/2247793]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SoundPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Markdown]]></title>
    <url>%2F2017%2F01%2F23%2Fmarkdown-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. 声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」–By @riku 注： 本项目托管于 GitCafe上，请通过”派生”和”合并请求”来帮忙改进本项目。 Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（` ），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Hexo]]></title>
    <url>%2F2017%2F01%2F23%2Fhexo-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Clean1hexo clean Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android SharedPreferences 详解]]></title>
    <url>%2F2017%2F01%2F08%2FSharedPreferences%2F</url>
    <content type="text"><![CDATA[概述 Store private primitive data in key-value pairs. SharedPreferences是一种轻量级的数据存储方式。 用键值对的方式把简单数据类型（boolean、int、float、long和String）存储在应用程序的私有目录下(data/data/包名/shared_prefs/)自己定义的xml文件中。例如：1&lt;string name=&quot;voicemail_notification_ringtone_1&quot;&gt;content://media/internal/audio/media/14&lt;/string&gt; 接口SharedPreferences接口主要负责读取应用程序的Preferences数据 常用的属性和方法1234567public abstract boolean contains (String key) // 判断SharedPreferences是否包含特定key的数据public abstract SharedPreferences.Editor edit () // 返回一个Edit对象用于操作SharedPreferencespublic abstract Map&lt;String, ?&gt; getAll () // 获取SharedPreferences数据里全部的key-value对getXXX(String key,XXX defvlaue) //获取SharedPreferences数据指定key所对应的value，如果该key不存在，返回默认值defValue。其中XXX可以是boolean、float、int、long、String等基本类型的值 EditorSharedPreference是一个接口，而且在这个接口里并没有提供写入数据和读取数据的能力。但是在其内部有一个Editor内部的接口，Edit这个接口有一系列的方法用于操作SharedPreference。12345678public abstract SharedPreferences.Editor clear () // 清空SharedPreferences里所有的数据public abstract boolean commit () // 当Editor编辑完成后，调用该方法可以提交修改，而且必须要调用这个数据才修改public abstract SharedPreferences.Editor putXXX (String key, boolean XXX)// 向SharedPreferences存入指定的key对应的数据，其中XXX可以是boolean、float、int、long、String等基本类型的值public abstract SharedPreferences.Editor remove (String key) // 删除SharedPreferences里指定key对应的数据项 获取实例SharedPreferences是一个接口，程序是无法创建SharedPreferences实例的，可以通过123456Context.getSharedPreferences(String name,int mode) // 来得到一个SharedPreferences实例// name：是指文件名称，不需要加后缀.xml，系统会自动为我们添加上。一般这个文件存储在/data/data/&lt;package name&gt;/shared_prefs下// mode：是指定读写方式，其值有三种，分别为：// Context.MODE_PRIVATE：指定该SharedPreferences数据只能被本应用程序读、写// Context.MODE_WORLD_READABLE：指定该SharedPreferences数据能被其他应用程序读，但不能写// Context.MODE_WORLD_WRITEABLE：指定该SharedPreferences数据能被其他应用程序读写。 读写其他应用SharedPreferences要实现这样的功能，我们必须要保证要访问的那个应用程序的SharedPreferences的访问权限要是MODE_WORLD_READABLE，这表明该SharedPreferences可以被其他应用程序读取，如果指定的MODE_WORLD_WRITEABLE表明该SharedPreferences可以被其他应用程序读取写入实现思路如下：1、 获得其他应用程序对应的Context 2、 通过这个Context得到这个应用程序的SharedPreferences，然后再利用这个SharedPreferences读取内容以上一例的SharedPreference为例。12345678try &#123; othercontext = createPackageContext(&quot;com.learn.android&quot;, Context.CONTEXT_IGNORE_SECURITY); sp = othercontext.getSharedPreferences(&quot;preferences&quot;,othercontext.MODE_PRIVATE); &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 注意事项 编辑完SharedPreferences一定要记得调用Editor的commit()方法，否则不会将数据写入到文件里的。 关键点1、 如何得到SharedPreferences SharedPreferences preferences=getPreferences(“test”,MODE_PRIVATE); 2、 如何编辑SharedPreferences 得到Editor对象实例 SharedPreferences.Editor editor=preferences.editor(); 3、 SharedPreferences的存储位置 /data/data//shared_prefs 官方文档1234567891011121314The SharedPreferences class provides a general framework that allows you to save and retrieve persistent key-value pairs of primitive data types. You can use SharedPreferences to save any primitive data: booleans, floats, ints, longs, and strings. This data will persist across user sessions (even if your application is killed).To get a SharedPreferences object for your application, use one of two methods: getSharedPreferences() - Use this if you need multiple preferences files identified by name, which you specify with the first parameter. getPreferences() - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don&apos;t supply a name.To write values: Call edit() to get a SharedPreferences.Editor. Add values with methods such as putBoolean() and putString(). Commit the new values with commit()To read values, use SharedPreferences methods such as getBoolean() and getString(). Here is an example that saves a preference for silent keypress mode in a calculator:12345678910111213141516171819202122232425262728public class Calc extends Activity &#123; public static final String PREFS_NAME = &quot;MyPrefsFile&quot;; @Override protected void onCreate(Bundle state)&#123; super.onCreate(state); . . . // Restore preferences SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); boolean silent = settings.getBoolean(&quot;silentMode&quot;, false); setSilent(silent); &#125; @Override protected void onStop()&#123; super.onStop(); // We need an Editor object to make preference changes. // All objects are from android.context.Context SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); SharedPreferences.Editor editor = settings.edit(); editor.putBoolean(&quot;silentMode&quot;, mSilentMode); // Commit the edits! editor.commit(); &#125;&#125; 存储位置 data/date目录下的 data/user_de/0 目录下 比如telecom 1234567sp9832a_2h11_volte:/data/user_de/0/com.android.server.telecom/shared_prefs # cat com.android.server.telecom_preferences.xml &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;&lt;map&gt; &lt;boolean name=&quot;silent_call_by_flipping_key&quot; value=&quot;true&quot; /&gt; &lt;boolean name=&quot;fade_in_key&quot; value=&quot;false&quot; /&gt;&lt;/map&gt; /data/user/0 下 12345方法在ContextImpl中的getSharedPreferencesPath()09-07 15:49:41.750 1431 1431 D dhy : getSharedPreferencesPath == /data/user/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml09-07 15:49:41.750 1431 1431 D dhy : getSharedPreferencesPath == /data/user_de/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml09-07 15:49:41.751 1431 1431 D dhy : getSharedPreferencesPath == /data/user_de/0/com.android.deskclock/shared_prefs/com.android.deskclock_preferences.xml]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RegistrantList 详解]]></title>
    <url>%2F2016%2F12%2F18%2FRegistrantList%2F</url>
    <content type="text"><![CDATA[概述这其实是观察者模式的一种实现形式 先明确两个身份 1.RefistrantList 通知者 2.Registrant 观察者，这是一个一对多的关系，在有事件更新时，凡是在名单上登记过的对象，都会收到通知。RegistrantList通知者支持对通知者的增加（add/addUnique）删除（remove），并且能够发出通知（notifyRegitrants）；而Registrant作为观察者，响应通知者发出的notifyRegistrant通知，并由其internalNotifyRegistrants方法响应通知者发出的通知。整体上这个消息注册机制分为两部分，消息注册和消息通知。其总体思想是：一个对象中开辟一个空间用于存放Message，当调用regist方法时将Message存放进去，当其调用notify方法时将所有Message取出并发送到MessageQueue中等待处理。 下面我们以android 5.0上 来电流程为例讲一下RegistrantList机制的使用。 注册为观察者PstnIncomingCallNotifier这个类中调用mphoneBase中的registerForNewRingingConnection方法注册为观察者，android中的注册为观察者的方法通常写为registerFor***()形式，即为某事件注册消息通知。 PstnIncomingCallNotifier.java 12345678910111213141516private void registerForNotifications() &#123; Phone newPhone = mPhoneProxy.getActivePhone(); if (newPhone != mPhoneBase) &#123; unregisterForNotifications(); if (newPhone != null) &#123; Log.i(this, &quot;Registering: %s&quot;, newPhone); mPhoneBase = newPhone; mPhoneBase.registerForNewRingingConnection( mHandler, EVENT_NEW_RINGING_CONNECTION, null); mPhoneBase.registerForCallWaiting( mHandler, EVENT_CDMA_CALL_WAITING, null); mPhoneBase.registerForUnknownConnection(mHandler, EVENT_UNKNOWN_CONNECTION, null); &#125; &#125;&#125; 然后我们看注册为观察者具体是怎么实现的： 调用addUnique添加为观察者 phoneBase.java 1234567// Inherited documentation suffices.@Overridepublic void registerForNewRingingConnection( Handler h, int what, Object obj) &#123; checkCorrectThread(h); mNewRingingConnectionRegistrants.addUnique(h, what, obj);&#125; 而这个mNewRingingConnectionRegistrants是什么呢？ 1protected final RegistrantList mNewRingingConnectionRegistrants = new RegistrantList(); mNewRingingConnectionRegistrants是一个RegistrantList 。 添加到通知者列表。用传进来的三个参数新建一个观察者，然后将其添加到通知者所要通知对象的列表中 RefistrantList.java 1234567public synchronized voidaddUnique(Handler h, int what, Object obj)&#123; // if the handler is already in the registrant list, remove it remove(h); add(new Registrant(h, what, obj));&#125; 3.1新建一个Registrant观察者 1234567publicRegistrant(Handler h, int what, Object obj)&#123; refH = new WeakReference(h);//Handler 泛型WeakReference this.what = what;//消息类型 userObj = obj;//Object数据对象，用于封装传递的数据&#125; 3.2添加到通知者须通知的对象的列表中，用列表保存观察者。registrants对象就是一个ArrayList。到此我们看到，RegistrantList维护了一个Registrants对象，而Registrants管理了多个Registrant。 123456public synchronized voidadd(Registrant r)&#123; removeCleared(); registrants.add(r);&#125; 自此消息的注册完成。 发出通知1.handlePollCalls方法根据RIL发出的Call List对象判断Call的状态，并发出不同的通知，有新的来电将执行： phone.notifyNewRingingConnection; 123456789101112 Connection newRinging = null; //or waiting handlePollCalls()&#123; ... if (newRinging != null) &#123; mPhone.notifyNewRingingConnection(newRinging); &#125;2.GSMPhone.java public void notifyNewRingingConnection(Connection c) &#123; super.notifyNewRingingConnectionP(c); &#125; 调用父类 PhoneBase.java notifyNewRingingConnectionP()发出来电通知 mNewRingingConnectionRegistrants.notifyRegistrants(ar);前面有说过mNewRingingConnectionRegistrants是一个RegistrantList通知者 1234567891011/** * Notify registrants of a new ringing Connection. * Subclasses of Phone probably want to replace this with a * version scoped to their packages */public void notifyNewRingingConnectionP(Connection cn) &#123; if (!mIsVoiceCapable) return; AsyncResult ar = new AsyncResult(null, cn, null); mNewRingingConnectionRegistrants.notifyRegistrants(ar);&#125; 通知者RegistrantList.java通知者调用内部的通知观察者的方法 12345public /*synchronized*/ voidnotifyRegistrants(AsyncResult ar)&#123; internalNotifyRegistrants(ar.result, ar.exception);&#125; 一般来说观察者不止一个，所以用for循环遍历感兴趣的观察者，调用观察内部的internalNotifyRegistrant()响应通知 12345678private synchronized voidinternalNotifyRegistrants (Object result, Throwable exception)&#123; for (int i = 0, s = registrants.size(); i &lt; s ; i++) &#123; Registrant r = (Registrant) registrants.get(i); r.internalNotifyRegistrant(result, exception); &#125;&#125; s = registrants.size() 获得观察者数量。响应通知消息 Registrant.java响应通知 1234567891011121314151617/*package*/ voidinternalNotifyRegistrant (Object result, Throwable exception)&#123; Handler h = getHandler(); if (h == null) &#123; clear(); &#125; else &#123; Message msg = Message.obtain(); msg.what = what; msg.obj = new AsyncResult(userObj, result, exception); h.sendMessage(msg); &#125;&#125; 这个消息是一开始注册为观察者就携带进去的 12345678910111213141516171819 private final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case EVENT_NEW_RINGING_CONNECTION: handleNewRingingConnection((AsyncResult) msg.obj); break; case EVENT_CDMA_CALL_WAITING: handleCdmaCallWaiting((AsyncResult) msg.obj); break; case EVENT_UNKNOWN_CONNECTION: handleNewUnknownConnection((AsyncResult) msg.obj); break; default: break; &#125; &#125; &#125;;` 至于响应通知做了什么工作不是这次的重点。 补充Message msg = Message.obtain():Handler h = getHandler();h.sendMessage(msg); 从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool = null 的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 使用Handler中的sendMessage (Message msg)方式来发送消息. 我们可以知道android 中发送消息不管是Message中的几种重载的obtain()方式，还是Handler中的几种重载的sendMessage最终都是通过Handler.sendMessage来发送的,而Handler中的几种sendMessage()重载方法最终都会调用到sendMessageAtTime()方法来完成消息的入队操作。 发送一个消息到消息队列的对尾，它会在处理这个时间的线程中的handleMessage(Message),方法中被接受到并且处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RegistrantList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Proguard 注解]]></title>
    <url>%2F2016%2F11%2F18%2FProguard%2F</url>
    <content type="text"><![CDATA[[TOC] 使用proguard语法 之前大家在开发插件时可能会遇到调不到Dialer中的方法，之前的解决方案是去直接修改proguard.flags文件,这个需要大家去学习 proguard的声明语法，感兴趣的可以学习下。 例如防止DialerApplication中的所以方法被混淆，可以使用下面的语法声明 -keep class com.android.dialer.DialerApplication {*;} 如果是防止一个类中的某个方法不被混淆，可以使用下面的语法声明： -keepclasseswithmembers class com.android.incallui.CallCardFragment { public void setCallNumberAndLabel(java.lang.String , java.lang.String ); } 其中setCallNumberAndLabel是 我在CallCardFragment中新增的方法 public void setCallNumberAndLabel(String number, String label) 上面的去混淆方法都需要我们对proguard的语法有一定的了解，但是如果使用注解的话会更加简单，就不需要每一次去混淆都去修改 proguard.flags文件了。 使用注解 如果只是想一个方法不被混淆，可以直接在方法定义处加上注解@NeededForReflection即可，例如原生在DialpadFragment就 有用到的: @NeededForReflectionpublic void setYFraction(float yFraction) { setTranslationY(yFraction * getHeight());} 同样，不混淆一个属性，也是在其定义处加上@NeededForReflection注解即可。 但是这个注解只适用于不混淆方法和属性，而不能不混淆方法，原因就是在于proguard.flags文件中只声明不混淆类中的方法和属性，可能是原生不 想不混淆整个类（一般也没有这种需求），具体原因请看下面的NeededForReflection注解原理分析。 @NeededForReflection原理 实际上，@NeededForReflection这个注解的原理同样是使用proguard的语法声明的。具体的步骤如下： 1）. 先定义一个注解：./src/com/android/incallui/NeededForReflection.java @Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD})public @interface NeededForReflection {} 2）. 然后在proguard.flags文件中声明： Any class or method annotated with NeededForTesting or NeededForReflection.-keepclassmembers class {@com.android.contacts.common.test.NeededForTesting ;@com.android.incallui.NeededForReflection *;} 可以看到上面的声明语法只是不混淆类的成员，如果@NeededForReflection声明的类不被混淆的话，需要在 proguard.flags中添加如下声明： -keep @com.android.incallui.NeededForReflection class {;} 综上，建议之后在需要不混淆一个方法或者属性时使用@NeededForReflection 注解，如果需要不混淆整个类（一般用不到），再去在proguard.flags文件添加声明]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Preference 详解]]></title>
    <url>%2F2016%2F10%2F18%2FPreference%2F</url>
    <content type="text"><![CDATA[概述preference非常适合于参数设置功能。实际上，它也确实是干这个的，我们通过使用preference可以迅速的将某些值保存进xml文件中，然后我们可以读取这些设置信息进行相应的操作。为了简化与preference相关的应用开发，android为我们提供了一系列的api来帮助我们。主要有 PreferenceActivity，ListPreference,EditTextPreference,CheckBoxPreference,RingtonePreference CheckBoxPreference1234567891011121314151617private static final String BUTTON_AUTOMATIC_RECORDING = &quot;automatic_recording_key&quot;;mAutomaticRecording = (CheckBoxPreference) findPreference(BUTTON_AUTOMATIC_RECORDING); if (mAutomaticRecording != null) &#123; mAutomaticRecording.setOnPreferenceChangeListener(this); &#125; /** * Supports onPreferenceChangeListener to look for preference changes. * * @param preference The preference to be changed * @param objValue The value of the selection, NOT its localized display value. */ @Override public boolean onPreferenceChange(Preference preference, Object objValue) &#123; // if (preference == mVibrateWhenRinging) &#123; // 在这里加额外的判断去处理数据 return true; // true to update the state of the preference with the new value. &#125; 12345678910111213//xml: &lt;PreferenceCategory android:key=&quot;dialer_general_call_recording_settings_category_key&quot; android:title=&quot;@string/call_recording_setting_title&quot; android:persistent=&quot;false&quot; &gt; &lt;CheckBoxPreference android:key=&quot;automatic_recording_key&quot; android:title=&quot;@string/automatic_recording_title&quot; android:persistent=&quot;true&quot; android:defaultValue=&quot;false&quot; /&gt; &lt;/PreferenceCategory&gt; android:persistent=”true”Preference 可以自动保存状态值，保存是以 xml 文件形式保存的，保存路径在 /data/data/packageName/shared_prefs/×××.xml设置这个属性为 true，android 就会为你自动保存,否则，不保存 1onclick --&gt; setchecked(newvalue) --&gt; persistboolean(checked) --&gt; 然后调用 PreferenceManager 相关的方法获取 SharedPreference 来保存文件 如何动态获取 CheckBoxPreerence 的值–&gt; 实现 OnSharedPreferenceChangeListener 接口12 Preferencescreen Preferencescreen中启动activity 123456789101112例如general_setting.xml中有如下片段 &lt;PreferenceScreen android:enabled=&quot;true&quot; android:key=&quot;fast_dial_preference_key&quot; android:persistent=&quot;false&quot; android:title=&quot;@string/fast_dial_title&quot; &gt; &lt;intent android:action=&quot;android.intent.action.MAIN&quot; android:targetPackage=&quot;com.android.phone&quot; android:targetClass=&quot;com.sprd.phone.settings.fastdial.FastDialSettingActivity&quot; /&gt; &lt;/PreferenceScreen&gt; android:targetPackage=”com.android.phone” // 工程的包名 android:targetClass=”com.sprd.phone.settings.fastdial.FastDialSettingActivity” // 要启动的类 一般情况下，这样就ok了，点击对应的Preference就能够启动对应的activity，然而仅仅这样有时这样，并不一定能够启动对应的activity，因为它与回调函数onPreferenceTreeClick有关 12345678910111213141516171819202122/** * Click listener for toggle events. */@Overridepublic boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) &#123; /** SPRD: IP_DIAL&amp;FAST_DIAL_FEATURE BEGIN @&#123; */ String key = preference.getKey(); /** SPRD: END @&#125; */ if (preference == mPlayDtmfTone) &#123; Settings.System.putInt(mContext.getContentResolver(), Settings.System.DTMF_TONE_WHEN_DIALING, mPlayDtmfTone.isChecked() ? 1 : 0); &#125; else if (preference == mRespondViaSms) &#123; // Needs to return false for the intent to launch. return false; &#125; /** SPRD: IP_DIAL&amp;FAST_DIAL_FEATURE BEGIN @&#123; */ else if (BUTTON_IP_DIALING_KAY.equals(key) || BUTTON_FAST_DIAL_KAY.equals(key)) &#123; return false; &#125; /** SPRD: END @&#125; */ return true;&#125; 当返回值为true时,你怎么点击Preference都不会跳转到activity的，只有等到它的返回值为false的时候，才可以正常跳转，因为点击某一个Preference的真正实现在Preference.java的performClick函数中1234567891011121314151617181920212223242526272829303132333435/** * Called when a click should be performed. * * @param preferenceScreen A &#123;@link PreferenceScreen&#125; whose hierarchy click * listener should be called in the proper order (between other * processing). May be null. * @hide */public void performClick(PreferenceScreen preferenceScreen) &#123; if (!isEnabled()) &#123; return; &#125; onClick(); if (mOnClickListener != null &amp;&amp; mOnClickListener.onPreferenceClick(this)) &#123; return; &#125; PreferenceManager preferenceManager = getPreferenceManager(); if (preferenceManager != null) &#123; PreferenceManager.OnPreferenceTreeClickListener listener = preferenceManager .getOnPreferenceTreeClickListener(); if (preferenceScreen != null &amp;&amp; listener != null &amp;&amp; listener.onPreferenceTreeClick(preferenceScreen, this)) &#123; return; &#125; &#125; if (mIntent != null) &#123; Context context = getContext(); context.startActivity(mIntent); &#125;&#125; 当点击某个Preference时的调用流程是AdapterView.performItemClick –&gt; PreferenceScreen.onItemClick–&gt; Preference.performClick –&gt; PreferenceActivity.onPreferenceTreeClick当onPreferenceTreeClick返回true的时候就直接return了，没有走下面启动activity的地方了.因此要使一个Preference能够正常跳转到另外一个activity有两个条件，一是xml里面是否设置正确，第二是调用该xml的java类是否在onPreferenceTreeClick这个函数需要返回false。 PreferenceScreen监听子项的刷新有个PreferenceScreen，他有一些个子项目。它的Summary需要根据子项的设置来改变的，所以需要监听子项的刷新事件。preferenceScreen.setOnPreferenceChangeListener( ) 是不管用的。 不过，它的RootAdapter在子项更新时却能够收到事件，所以就直接上代码了123456789// Auto update Summary when related preference changed.preferenceScreen.getRootAdapter().registerDataSetObserver(new DataSetObserver() &#123; @Override public void onChanged() &#123; super.onChanged(); // Update Summary... &#125;&#125;); 收到这个事件的时候，Preference的Value已经改变了，所以就可以放心地读取新的值了。Tips：这时可以使用Handler.post()方法。 ListPreferencePreferenceActivity]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Preference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova原生插件之Android消息通知]]></title>
    <url>%2F2016%2F09%2F21%2FCordova%E6%8F%92%E4%BB%B6%E4%B9%8Bandroid%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[概述架构插件目录结构如下：notifyplugin * plugin.xml * www/notifysrv.js * src/android/NotifysrvPlugin.java * libs/android-support-v4.jar 这个需要自己手动添加到android的libs文件夹下、或者通过自定义hooks文件实现 plugin.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;plugin xmlns="http://apache.org/cordova/ns/plugins/1.0" id="com.dhyuestc.cordova.plugin" version="0.0.1"&gt; &lt;name&gt;NotifysrvPlugin&lt;/name&gt; &lt;description&gt;NotifysrvPlugin Description&lt;/description&gt; &lt;author&gt;dhyuestc&lt;/author&gt; &lt;license&gt;Apache 2.0 License&lt;/license&gt; &lt;engines&gt; &lt;engine name="cordova" version="&gt;=3.0.0" /&gt; &lt;/engines&gt; &lt;js-module src="www/notifysrv.js" name="notifysrv"&gt; &lt;clobbers target="Notify" /&gt; &lt;/js-module&gt; &lt;platform name="android"&gt; &lt;source-file src="src/android/NotifysrvPlugin.java" target-dir="src/com/dhyuestc/cordova/plugin" /&gt; &lt;config-file target="res/xml/config.xml" parent="/*"&gt; &lt;feature name="NotifysrvPlugin"&gt; &lt;param name="android-package" value="com.dhyuestc.cordova.plugin.NotifysrvPlugin"/&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file target="AndroidManifest.xml" parent="/*"&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;/config-file&gt; &lt;/platform&gt;&lt;/plugin&gt; NotifysrvPlugin.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.dhyuestc.cordova.plugin;import org.apache.cordova.CordovaPlugin;import org.apache.cordova.CallbackContext;import org.apache.cordova.CordovaWebView;import org.apache.cordova.CordovaInterface;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import android.content.Context;import android.support.v4.app.NotificationCompat;public class NotifysrvPlugin extends CordovaPlugin &#123; public static final String TAG = "NotifysrvPlugin"; public static final String iconname = "icon"; //icon res name public NotificationManager nm; public Context m_context; public void initialize(CordovaInterface cordova, CordovaWebView webView) &#123; super.initialize(cordova, webView); m_context = this.cordova.getActivity().getApplicationContext(); nm = (NotificationManager) m_context.getSystemService(android.content.Context.NOTIFICATION_SERVICE); // 首先要获得通知服务 &#125; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException &#123; if ("send".equals(action)) &#123; String title = args.getString(0); String text = args.getString(1); PendingIntent m_PendingIntent=PendingIntent.getActivity(this.cordova.getActivity(), 0, this.cordova.getActivity().getIntent(), 0); int iconResID = m_context.getResources().getIdentifier(iconname,"drawable", m_context.getPackageName()); Notification notification = new NotificationCompat.Builder(m_context) // 构造器 .setContentTitle(title) .setContentText(text) .setDefaults(Notification.DEFAULT_ALL) //设置默认铃声，震动等 .setSmallIcon(iconResID) .setContentIntent(m_PendingIntent) // Supply a PendingIntent to send when the notification is clicked. .setAutoCancel(true) // .setLargeIcon(aBitmap) .build(); // Combine all of the options that have been set and return a new Notification object. nm.notify(1, notification); // callbackContext.success(); return true; &#125; return false; &#125;&#125;/***public void notify (int id, Notification notification) * Post a notification to be shown in the status bar. * If a notification with the same id has already been posted by your application and has not yet been canceled, * it will be replaced by the updated information.**Parameters* id An identifier for this notification unique within your application. * notification A Notification object describing what to show the user. Must not be null. **/```bashvar argscheck = require('cordova/argscheck');var exec = require('cordova/exec');var Notify = function() &#123;&#125;;Notify.prototype.send = function(message, success, error) &#123; //argscheck.checkArgs('AFF', 'notify.send', arguments); console.log("send notification["+message[1]+"]"); if(!message) error &amp;&amp; error("please input message"); else exec(success, error, 'NotifysrvPlugin', 'send', message);&#125;;var notify = new Notify();module.exports = notify; 安装插件将插件加入cordova工程的办法进入CMD，进入cordova工程文件夹，然后输入如下命令1cordova plugin add [插件目录] 使用方法12345 Notify.send(msg,function()&#123; //success code &#125;,function(msg)&#123; // error &#125;); 注意问题 libs/android-support-v4.jar 这个需要自己手动添加到android的libs文件夹下、或者通过自定义hooks文件实现 参考文献]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2016%2F09%2F21%2Fgit%2F</url>
    <content type="text"><![CDATA[[TOC] 概述Git是目前世界上最先进的分布式版本控制系统。下面是对常用的git命令的总结归纳。基于ubuntu系统。 安装Debian/Ubuntu1$ sudo apt-get install git 其他平台详见官方Downloads地址 常用命令创建版本库123$ mkdir gitlibrary // 本地创建一个git目录$ cd gitlibrary$ git init 将文件添加到git库1$ git add readme.txt 将文件提交到仓库1$ git commit -m "wrote a readme file" // -m后面输入的是本次提交的说明内容 删除仓库中的文件1$ git rm 查看git库状态1$ git status 查看差异1$ git diff 显示从最近到最远的提交日志123$ git log$ git log --pretty=oneline // 简化输出信息$ git log --graph --pretty=oneline --abbrev-commit // 查看分支历史 回退修改在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上多个版本写多个^比较容易数不过来，所以写成HEAD~n,表示向上第n个版本 1$ git reset --hard HEAD^ 1--hard // 指定回到未来的某个版本1$ git reset --hard 3628164 // 3628164代表某次提交的commit id，也可以不写全，git会自动补全，当然，最好是写全，以免多个提交的前面数字一样git无法区分 查看使用过的每一次命令1git reflog 丢弃工作区的修改1git checkout -- file // 没有--，就变成了“切换到另一个分支”的命令.事实上不加-- 指定文件的路径话也是可以的。 关联一个远程库1234$ git remote add origin git@server-name:path/repo-name.git```bash关联后，使用下面的命令第一次推送master分支的所有内容； git push -u origin master12345### 将本地修改推送到远程库```bash$ git push origin master 其中远程库的地址信息master可以在本地库的.git/config文件中查看,例如 123[branch "m-android-dev"] remote = origin merge = android-m 上面的”m-android-dev”即为本地库所指向的远程库分支，”HEAD:android-m”对应的就是master,即可以使用下面的命令将代码提交到远程库 1$ git push origin HEAD:android-m 将远程库克隆到本地1$ git clone git@github.com:sunnycoder/Hello-World.git // 最后的是远程git库的SSH地址，此处使用的是我的github上的一个git库ssh地址 分支管理创建分支1$ git branch dev 切换分支1$ git checkout dev 创建并切换1$ git checkout -b dev 查看当前分支1$ git branch 合并分支git merge命令用于合并指定分支到当前分支，通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 123$ git merge dev // 把dev分支的工作成果合并到master分支上$ git merge --no-ff -m "merge with no-ff" dev // --no-ff参数，表示禁用Fast forward -m参数用于添加commit描述。 删除分支1$ git branch -d dev 存储现场1$ git stash 查看存储的信息1$ git stash list 恢复现场1234$ git stash apply // 恢复后，stash内容并不删除$ git stash drop$ git stash apply stash@&#123;0&#125; // stash list存在多个时，恢复指定的stash 另外一种方式： 1$ git stash pop // 恢复的同时把删除stash内容 查看远程库的信息12$ git remote$ git remote -v // 显示更详细的信息,会显示可以抓取和推送的地址 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 123456789101112$ git tag &lt;name&gt; // 添加名称为name的标签$ git tag // 查看所有标签$ git tag &lt;name&gt; &lt;commit_id&gt; // 对某一次提交打标签$ git tag -d &lt;name&gt; // 删除一个本地标签$ git push origin &lt;tagname&gt; // 推送某个标签到远程库$ git push origin --tags // 一次性推送全部尚未推送到远程的本地标签$ git push origin :refs/tags/&lt;tagname&gt; 删除一个远程标签 自定义git让Git显示颜色1$ git config --global color.ui true 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 例如，下面就是一个.gitignore文件的内容 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后需要把.gitignore也提交到Git 12$ git add -f App.class // 强制添加到Git$ git check-ignore -v App.class // 检测规则 配置别名12345678$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch$ git config --global alias.last 'log -1' // 显示最后一次提交信息$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 配置文件配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 每个仓库的Git配置文件都放在.git/config文件中 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig Git全局配置和单个仓库的用户名邮箱配置学习git的时候, 大家刚开始使用之前都配置了一个全局的用户名和邮箱 $ git config –global user.name “github’s Name” $ git config –global user.email “github@xx.com” $ git config –list 如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置 $ git config user.name “gitlab’s Name” $ git config user.email “gitlab@xx.com” $ git config –list git config –list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置 repo google提供的git集成工具 总结### 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作. &lt; 事实上直接reset掉提交就可以了。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 参考资料 官方文档 廖雪峰的Git教程]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android M Permission 详解]]></title>
    <url>%2F2016%2F09%2F18%2FPermission%2F</url>
    <content type="text"><![CDATA[[TOC] Android M新增运行时申请权限的机制， 如果是在M上的应用，不需要在安装时申请权限，而是在应用运行时动态的申请权限，系统会弹出一个对话框向用户请求权限。 支持动态申请权限机制的应用安装在之前的版本，依然采用过去的权限机制：安装时申请权限。 概述(Overview)下面是运行时权限机制的关键部分的简要概述 声明权限(Declaring Permissions): 应用需要在manifest文件中申请它所需要的所以权限，这一点和之前一样 权限组(Permission Groups): 权限被划分为一些权限组(permission group) 例如存储的权限组包含读取存储和写存储的权限 存储貌似只要申请READ_EXTERNAL_STORAGE就可以了android.permission-group.STORAGE ： android.permission.READ_EXTERNAL_STORAGE 和android.permission.WRITE_EXTERNAL_STORAGE 有限制的安装时赋予权限(Limited Permissions Granted at Install Time): 当安装或者升级应用时，系统会赋予应用manifest中所有的PROTECTION_NORMAL类型的权限，详见 PROTECTION_NORMAL列表 运行时用户赋予权限(User Grants Permissions at Run-Time): 当用户请求权限时，系统弹出一个选择框供用户选择，然后通过回调机制判断用户的选择 总是检测权限 (Always Check for Permission): 当一个应用执行一些权限时，每一次运行时都需要检查应用是否已经具备了相应的权限，如果没有，需要被赋予权限，对应PROTECTION_NORMAL类型的权限，不需要动态的检测申请 优雅的处理缺少权限的情况 (Handle Lack of Permissions Gracefully) : 如果一个应用没有被赋予需要的权限，需要处理权限申请失败的情况。 如果这个权限影响一个功能，没有权限时可以使得权限不生效 如果一个权限是应用必备的，需要使得整个应用不可用，并提示用户赋予权限才能运行 权限是可以取消的(Permissions are Revocable) : 用户可以在任何时候取消权限，如果用户在设置中取消应用的权限，不会通知应用，需要应用在执行一些需要运行时权限的动作时确保具备相应的权限 权限组(Permission groups)一些相关的权限被划分为一个组，这样用户在赋予权限时可以一次操作赋予一个权限组内的多个权限.如果一个应用随后又请求同一个组内权限，系统默认给予权限而不需要用户操作。系统会回调onRequestPermissionsResult()方法，好像用户在权限选择框中选择允许权限一样。 关键点在于第一次会记录用户的一个选择？ 例如： 系统应用和签名类型的权限(System components and signature permissions )正常的，当安装一个应用时，系统会赋予应用manifest中所有的PROTECTION_NORMAL类型的权限，但是在一些特殊的情况下，系统会允许应用更多的权限： １． 系统应用自动获取manifest中声明的所有权限２． 如果应用申请在manifest文件中声明的PROTECTION_SIGNATURE类型的权限，同时应用具备和声明这个权限的应用一样的证书时，系统会在应用安装时赋予这些权限。应用是不能在运行时申请PROTECTION_SIGNATURE类型的权限的。 兼容旧版本 (Forwards and backwards compatibility) 如果一个应用不打算运行在Android M上，还是使用之前的权限机制即可：安装时赋予manifest中声明的权限 使用运行时权限机制的应用运行在非M版本上，依然采取之前的权限机制。 权限 VS 意图 (Permissions versus intents)在很多情况下，你有两种选择让你的应用去执行一个任务： 让你的应用去申请执行相应操作所需要的权限 通过intents让其他应用去执行相应的操作 例如：拨打一路电话，查看联系人等，应用可以自己申请权限，调用API去执行相应的操作，也可以选择发送Intents到拨号应用或者联系人应用去执行相应的操作，然后在onActivityResult() 中获取返回的结果 优劣对比： 1.使用权限 应用可以完整的控制执行功能时的用户体验，当然如果你需要设计一个合适的UI的话，这样全局的控制可能会增加任务的复杂性 第一次执行任务时，需要用户赋予应用对应的权限，之前运行就不需要用户再赋予权限，如果用户拒接权限或者之后在设置中关闭权限，应用就无法执行相应的操作。 2.使用Intents 无需设计这部分操作的UI体验，但这也就意味着应用失去对这一部分用户体验的控制，用户可能会与一个你从未见过的应用进行交互。 如果系统没有默认的应用处理对应的操作，系统会弹出一个选择框让用户选择使用哪一个应用去执行操作。如果此时用户没有选择一个默认的应用，每次执行这个操作时都需要弹出对话框 运行时权限机制相关代码(Coding for Runtime Permissions) 使新的权限机制可用 (Enabling the new permissions model) 应用想要使用M的权限机制，你需要首先设置uses-sdk12345678&lt;uses-sdktargetSdkVersion = &quot;MNC&quot;compileSdkVersion = &quot;android-MNC&quot; /&gt;// Dialer应用 &lt;uses-sdk android:minSdkVersion=&quot;23&quot; android:targetSdkVersion=&quot;23&quot; /&gt; 设计Android M专属权限 (Designating a permission for the M only) 你可以使用元素来表明这个权限只在Android M上需要。如果你这么做的话，当应用安装在旧版本上时，系统不会让用户赋予应用相应的权限。通过使用元素你可以添加新的权限去更新你的版本而不需要强制用户在安装或者更新时赋予相应的权限 如果应用安装运行在M上，和 是一样的效果 权限提示 (Prompting for permissions ) 检测app所运行的平台版本 (Check what platform the app is running on) 新的权限机制只在M上支持，在执行对应的方法时需要判断当前运行的系统版本应用可用使用Build.VERSION.CODENAME来获取当前运行的平台，如果是运行在M上，CODENAME对应的是”MNC” 检测应用是否拥有需要的权限(Check if the app has the needed permission) 当用户执行一些需要权限的操作时，应用应该首先检查当前是否已经拥有权限去执行操作，使用下面的方法 123Context.checkSelfPermission(permission_name)// for exampleContext.checkSelfPermission(android.permission.WRITE_EXTERNAL_STORAGE) 即可应用知道用户已经赋予过权限，也需要每次都去检查，因为用户可能在任何时候撤销权限 说明为什么需要权限(Explain why the app needs permissions) 在一些情况下，你可能希望帮忙用户理解为什么应用需要权限，例如： 一些情况需要提供额外的解释，可以使用下面的方法，返回true的话意味着你需要提供额外的信息解释应用为什么需要权限1234Activity.shouldShowRequestPermissionRationale(String)// true ：app has requested this permission previously and the user denied the request.If the user turned down the permission request in the past and chose the Don&apos;t ask again option in the permission request system dialog, this method returns false. The method also returns false if the device policy prohibits the app from having that permission. 如果用户拒接权限同时选择不再询问，这个方法返回false. 这种情况下应用不需要再弹任何提示 请求权限 (Request permissions if necessary) 如果应用不具备相应的权限，可以调用下面的方法去申请权限12345@param permissions The requested permissions.@param requestCode Application specific request code to match with a result reported to &#123;@link #onRequestPermissionsResult(int, String[], int[])&#125;.Should be &gt;= 0.Activity.(@NonNull String[] permissions, int requestCode) 当用户在弹出的对话框中做出选择后，系统会回调onRequestPermissionsResult方法来处理用户的选择 请求权限的代码示例1234567891011121314151617if (checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (shouldShowRequestPermissionRationale( Manifest.permission.READ_CONTACTS)) &#123; // Explain to the user why we need to read the contacts &#125; requestPermissions(new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant return;&#125; 处理权限请求响应 (Handle the permissions request response) 当一个应用请求权限时，系统会显示一个对话框给用户，当用户做出选择后，系统会回调下面的方法并传入用户的选择应用需要重写这方法， 12345678 * @param requestCode The request code passed in &#123;@link #requestPermissions(String[], int)&#125;. * @param permissions The requested permissions. Never null. * @param grantResults The grant results for the corresponding permissions * which is either &#123;@link android.content.pm.PackageManager#PERMISSION_GRANTED&#125; * or &#123;@link android.content.pm.PackageManager#PERMISSION_DENIED&#125;. Never null.Activity.onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; 代码示例，请求READ_CONTACTS权限的代码回调：12345678910111213141516171819202122@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! do the // calendar task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other &apos;switch&apos; lines to check for other // permissions this app might request &#125;&#125; 如果用户拒接了申请的权限，应用需要做出处理，例如弹出一个dialog解释为什么无法执行相应的操作 当系统向用户询问权限申请时，用户可以选择不再询问，在这种情况下，应用再去调用requestPermissions方法时，系统会立即拒绝这个请求这种情况下，系统在回调onRequestPermissionsResult()方法时的结果和用户再次拒绝请求一样因此，你的应用无法确保任何与用户直接交互的操作的执行 (这句话没看懂) Testing Runtime Permissions如果你的应用是想运行在Android M平台，你必须验证你的应用可以很好的处理权限问题Android M SDK新提供了一个adb命令，使得你可以测试你想设置的任何权限 New adb commands and options Install with permissions 安装应用并赋予manifest文件中的所有权限 1$ adb install -g &lt;path_to_apk&gt; Grant and revoke permissions 1234$ adb pm grant &lt;package_name&gt; &lt;permission_name&gt;$ adb pm grant com.example.myapp android.permission.RECORD_AUDIO$ adb pm revoke &lt;package_name&gt; &lt;permission_name&gt; Best Practices and Usage Notes Only ask for permissions you need Don’t overwhelm the user Explain why you need permissions Normal Permissions android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.ACCESS_WIMAX_STATE android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_MULTICAST_STATE android.permission.CHANGE_WIFI_STATE android.permission.DISABLE_KEYGUARD android.permission.EXPAND_STATUS_BAR android.permission.FLASHLIGHT android.permission.GET_ACCOUNTS android.permission.GET_PACKAGE_SIZE android.permission.INTERNET android.permission.KILL_BACKGROUND_PROCESSES android.permission.MODIFY_AUDIO_SETTINGS android.permission.NFC android.permission.PERSISTENT_ACTIVITY android.permission.READ_SYNC_SETTINGS android.permission.READ_SYNC_STATS android.permission.READ_USER_DICTIONARY android.permission.RECEIVE_BOOT_COMPLETED android.permission.REORDER_TASKS android.permission.SET_TIME_ZONE android.permission.SET_WALLPAPER android.permission.SET_WALLPAPER_HINTS android.permission.SUBSCRIBED_FEEDS_READ android.permission.TRANSMIT_IR android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_SETTINGS android.permission.WRITE_SYNC_SETTINGS android.permission.WRITE_USER_DICTIONARY com.android.alarm.permission.SET_ALARM com.android.launcher.permission.INSTALL_SHORTCUT ## 案例分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Notifications 详解]]></title>
    <url>%2F2016%2F08%2F18%2FNotification%2F</url>
    <content type="text"><![CDATA[[TOC] 概述A notification is a message you can display to the user outside of your application’s normal UI. When you tell the system to issue a notification, it first appears as an icon in the notification area. To see the details of the notification, the user opens the notification drawer. Both the notification area and the notification drawer are system-controlled areas that the user can view at any time. Design Considerations 设计注意事项Notifications, as an important part of the Android user interface, have their own design guidelines. The material design changes introduced in Android 5.0 (API level 21) are of particular importance, and you should review the Material Design training for more information. To learn how to design notifications and their interactions, read the Notifications design guide. 通知是android用户界面的一个重要组成部分 需要使用Material Design来说设计通知 特殊说明 除非特别注明，否则本指南均引用版本 4 支持库中的 NotificationCompat.Builder 类。 Android 3.0（API 级别 11）中已添加类 Notification.Builder。 &lt;&lt;&lt; 现在都是用这个 Creating a Notification 创建通知You specify the UI information and actions for a notification in a NotificationCompat.Builder object. To create the notification itself, you call NotificationCompat.Builder.build(), which returns a Notification object containing your specifications. To issue the notification, you pass the Notification object to the system by calling NotificationManager.notify(). 使用NotificationCompat.Builder创建一个Notification对象 (Notification.Builder) 调用NotificationManager.notify()发出一个通知 必要的通知内容 Required notification contents一个Notification 对象必须包含以下内容： 小图标 A small icon, set by setSmallIcon() 显示在通知的左边的图标部分的右下角，其余部分显示的是largeIcon, 例如来电通知，头像是大图标，call状态是小图标：普通情况是电话图标，电话被保持是暂停图标 1234567891011if (mLargeIcon != null) &#123; contentView.setImageViewIcon(R.id.icon, mLargeIcon); processLargeLegacyIcon(mLargeIcon, contentView); contentView.setImageViewIcon(R.id.right_icon, mSmallIcon); contentView.setViewVisibility(R.id.right_icon, View.VISIBLE); processSmallRightIcon(mSmallIcon, contentView);&#125; else &#123; // small icon at left contentView.setImageViewIcon(R.id.icon, mSmallIcon); contentView.setViewVisibility(R.id.icon, View.VISIBLE); processSmallIconAsLarge(mSmallIcon, contentView);&#125; 标题 A title, set by setContentTitle() 详细文本 Detail text, set by setContentText() 可选通知内容和设置 Optional notification contents and settings请参阅 NotificationCompat.Builder 参考文档。 http://developer.android.com/intl/zh-cn/reference/android/support/v4/app/NotificationCompat.Builder.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364* setOngoing(boolean ongoing) // true:正在进行中，常驻通知，无法通过左右滑动的方式清除 ，只有发起者调用cancle才能取消 通常是用来表示一个后台任务,* setWhen(long when) // 设置右上角的通知时间，如果不设置则使用默认使用当前系统时间* setUsesChronometer(boolean b) // Show the when field as a stopwatch. // 设置是否在通知时间的地方显示自动计时的时间。设置true后一般也会setwhen,不然也是使用默认的发起时间* setAutoCancel(boolean autoCancel) // true: 点击自动取消通知* setDeleteIntent(PendingIntent intent) // 清除通知时启动 Activity* setContentIntent(PendingIntent intent) // 点击通知时启动 Activity 最常见的场景* setPriority(int pri) // 设置优先级* setCategory(String category) // 设置类别* setColor(int argb) // 设置颜色 : 进度条的颜色；小图标的颜色？* setContent(RemoteViews views) // 设置自定义布局* setContentInfo(CharSequence info) // A small piece of additional information pertaining to this notification. * setDefaults(int defaults) // 使用默认属性 例如 .setDefaults(Notification.DEFAULT_SOUND) // 设置默认铃声* setExtras(Bundle extras) Set metadata for this notification. * setFullScreenIntent(PendingIntent intent, boolean highPriority) // An intent to launch instead of posting the notification to the status bar. 悬挂式通知* setGroup(String groupKey) // Set this notification to be part of a group of notifications sharing the same key. * setGroupSummary(boolean isGroupSummary) // Set this notification to be the group summary for a group of notifications. * setLargeIcon(Icon icon) setLargeIcon(Bitmap b) // Add a large icon to the notification content view. * setLights(int argb, int onMs, int offMs) // 设置三色灯* setLocalOnly(boolean localOnly) // Set whether or not this notification should not bridge to other devices. * setNumber(int number) // Set the large number at the right-hand side of the notification. 在右下角显示数字* setOnlyAlertOnce(boolean onlyAlertOnce) // et this flag if you would only like the sound, vibrate and ticker to be played if the notification is not already showing. * setProgress(int max, int progress, boolean indeterminate) // 设置进度条* setShowWhen(boolean show) // Control whether the timestamp set with setWhen is shown in the content view. * setSound(Uri sound, AudioAttributes audioAttributes) setSound(Uri sound) // setSound(Uri.parse(&quot;file:///sdcard/xx/xx.mp3&quot;)) setSound(Uri.withAppendedPath(Audio.Media.INTERNAL_CONTENT_URI, &quot;5&quot;)) * setStyle(Notification.Style style)* setSubText(CharSequence text) // Set the third line of text in the platform notification template. 通知的右侧正文内容一共有三行，第一行标题，第二行主要内容，第三行次要内容* setTicker(CharSequence tickerText) // Set the &quot;ticker&quot; text which is sent to accessibility services. 设置发出通知时在status bar进行提醒 旧版本使用，新版本已无用* setVibrate(long[] pattern) // Set the vibration pattern to use. builder.setVibrate(new long[]&#123;2000,1000,4000&#125;);* addAction(Notification.Action action) // 添加动作* addExtras(Bundle extras) // Merge additional metadata into this notification. getExtras()* addPerson(String uri) // 关联一个person 传入的参数必现是一个联系人uri Notification actions 通知操作 通知操作都是可选的，但是您至少应向通知添加一个操作 一个通知可以提供多个操作 始终定义一个当用户点击通知时会触发的操作；通常，此操作会在应用中打开 Activity。 也可以向通知添加按钮来执行其他操作，例如，暂停闹铃或立即答复短信 点击通知时启动 Activity 是最常见的操作场景,对应的接口为setContentIntent 还可以在用户清除通知时启动 Activity.对应的接口为setDeleteIntent 优先级 Notification priority NotificationCompat.Builder.setPriority() 您可以根据需要设置通知的优先级,范围从 PRIORITY_MIN (-2) 到 PRIORITY_MAX (2)；如果未设置，则优先级默认为 PRIORITY_DEFAULT (0) 12345PRIORITY_DEFAULT : 0 PRIORITY_LOW : -1PRIORITY_MIN : -2PRIORITY_HIGH : 1PRIORITY_MAX : 2 创建一个简单的通知 Creating a simple notification12345678910111213141516171819202122232425262728293031NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;);// Creates an explicit intent for an Activity in your appIntent resultIntent = new Intent(this, ResultActivity.class);// The stack builder object will contain an artificial back stack for the started Activity.// This ensures that navigating backward from the Activity leads out of your application to the Home screen.TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);// Adds the back stack for the Intent (but not the Intent itself)stackBuilder.addParentStack(ResultActivity.class);// Adds the Intent that starts the Activity to the top of the stackstackBuilder.addNextIntent(resultIntent);PendingIntent resultPendingIntent = stackBuilder.getPendingIntent( 0, PendingIntent.FLAG_UPDATE_CURRENT );mBuilder.setContentIntent(resultPendingIntent);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// mId allows you to update the notification later on. mId唯一标示通知，用于之后对通知对象的操作mNotificationManager.notify(mId, mBuilder.build()); Applying an expanded layout to a notification 将拓展布局应用于通知 折叠通知 NotificationCompat.Builder.setStyle() 扩展通知在 Android 4.1 之前的平台上不可用 注意处理兼容性 使用扩展布局示例 1234567891011121314151617181920NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;Event tracker&quot;) .setContentText(&quot;Events received&quot;)NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle();String[] events = new String[6];// Sets a title for the Inbox in expanded layoutinboxStyle.setBigContentTitle(&quot;Event tracker details:&quot;);...// Moves events into the expanded layoutfor (int i=0; i &lt; events.length; i++) &#123; inboxStyle.addLine(events[i]);&#125;// Moves the expanded layout object into the notification object.mBuilder.setStyle(inBoxStyle); // 关键方法...// Issue the notification here. Handling compatibility 处理兼容性 使用NotificationCompat 及其子类（特别是 NotificationCompat.Builder）创建通知 为所有用户提供通知的全部功能，无论他们使用何种版本的 Android 系统 确保所有用户均可通过点击通知启动 Activity 来获得该Activity中的功能 将要使用的扩展通知功能添加到通知。 Managing Notifications 管理通知 当您需要为同一类型的事件多次发出同一通知时，应避免创建全新的通知， 而是应考虑通过更改之前通知的某些值和/或为其添加某些值来更新通知。 “stacking” the notification; it’s described in more detail in the Notifications Design guide. Gmail 通过增加未读消息计数并将每封电子邮件的摘要添加到通知，通知用户收到了新的电子邮件。 这称为“堆叠”通知； Updating notifications 更新通知* 12345678910111213141516171819mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// Sets an ID for the notification, so it can be updatedint notifyID = 1;mNotifyBuilder = new NotificationCompat.Builder(this) .setContentTitle(&quot;New Message&quot;) .setContentText(&quot;You&apos;ve received new messages.&quot;) .setSmallIcon(R.drawable.ic_notify_status)numMessages = 0;// Start of a loop that processes data and then notifies the user... mNotifyBuilder.setContentText(currentText) .setNumber(++numMessages); // Because the ID remains unchanged, the existing notification is // updated. mNotificationManager.notify( notifyID, mNotifyBuilder.build()); //如果之前的通知依然可见，则更新，如果已经销毁，则重新创建... Removing notifications 删除通知 用户单独或通过使用“全部清除”清除了该通知（如果通知可以清除）。 用户点击通知，且您在创建通知时调用了 setAutoCancel() 您针对特定的通知 ID 调用了 cancel()。此方法还会删除当前通知。 您调用了 cancelAll() 方法，该方法将删除之前发出的所有通知。 Preserving Navigation when Starting an Activity 启动 Activity 时保留导航设置常规 Activity PendingIntent &lt;不设置好像也可以返回&gt; 123456789101112131415Intent resultIntent = new Intent(this, ResultActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);// Adds the back stackstackBuilder.addParentStack(ResultActivity.class);// Adds the Intent to the top of the stackstackBuilder.addNextIntent(resultIntent);// Gets a PendingIntent containing the entire back stackPendingIntent resultPendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);...NotificationCompat.Builder builder = new NotificationCompat.Builder(this);builder.setContentIntent(resultPendingIntent);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mNotificationManager.notify(id, builder.build()); 设置特殊 Activity PendingIntent1234567891011121314151617181920212223242526// Instantiate a Builder object.NotificationCompat.Builder builder = new NotificationCompat.Builder(this);// Creates an Intent for the ActivityIntent notifyIntent = new Intent(this, ResultActivity.class);// Sets the Activity to start in a new, empty tasknotifyIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);// Creates the PendingIntentPendingIntent notifyPendingIntent = PendingIntent.getActivity( this, 0, notifyIntent, PendingIntent.FLAG_UPDATE_CURRENT);// Puts the PendingIntent into the notification builderbuilder.setContentIntent(notifyPendingIntent);// Notifications are issued by sending them to the// NotificationManager system service.NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// Builds an anonymous Notification object from the builder, and// passes it to the NotificationManagermNotificationManager.notify(id, builder.build()); 在通知中显示进度 setProgress() 12 显示持续时间固定的进度指示器 要删除进度栏，请调用 setProgress(0, 0, false) 1234567891011121314151617181920212223242526272829303132333435363738mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mBuilder = new NotificationCompat.Builder(this);mBuilder.setContentTitle(&quot;Picture Download&quot;) .setContentText(&quot;Download in progress&quot;) .setSmallIcon(R.drawable.ic_notification);// Start a lengthy operation in a background threadnew Thread( new Runnable() &#123; @Override public void run() &#123; int incr; // Do the &quot;lengthy&quot; operation 20 times for (incr = 0; incr &lt;= 100; incr+=5) &#123; // Sets the progress indicator to a max value, the // current completion percentage, and &quot;determinate&quot; // state mBuilder.setProgress(100, incr, false); // Displays the progress bar for the first time. mNotifyManager.notify(0, mBuilder.build()); // Sleeps the thread, simulating an operation // that takes time try &#123; // Sleep for 5 seconds Thread.sleep(5*1000); &#125; catch (InterruptedException e) &#123; Log.d(TAG, &quot;sleep failure&quot;); &#125; &#125; // When the loop is finished, updates the notification mBuilder.setContentText(&quot;Download complete&quot;) // Removes the progress bar .setProgress(0,0,false); mNotifyManager.notify(ID, mBuilder.build()); &#125; &#125;// Starts the thread by calling the run() method in its Runnable).start(); 显示持续 Activity 指示器通知元数据 Notification Metadata 当设备处于“优先”模式时，setCategory() 会告知系统如何处理应用通知（例如，通知代表传入呼叫、即时消息还是闹铃）。 如果优先级字段设置为 PRIORITY_MAX 或 PRIORITY_HIGH 的通知还有声音或振动，则 setPriority() 会将其显示在小型浮动窗口中。 addPerson() 允许您向通知添加人员名单。您的应用可以使用此名单指示系统将指定人员发出的通知归成一组，或者将这些人员发出的通知视为更重要的通知。 浮动通知 Heads-up Notifications对于 Android 5.0（API 级别 21），当设备处于活动状态时（即，设备未锁定且其屏幕已打开），通知可以显示在小型浮动窗口中（也称为“浮动通知”）。 用户的 Activity 处于全屏模式中（应用使用 fullScreenIntent） 通知具有较高的优先级并使用铃声或振动 锁定屏幕通知随着 Android 5.0（API 级别 21）的发布，通知现在还可显示在锁定屏幕上 用户可以通过“设置”选择是否将通知显示在锁定屏幕上，并且您可以指定您应用中的通知在锁定屏幕上是否可见。(设定为图案，pin锁，密码) 设置可见性您的应用可以控制在安全锁定屏幕上显示的通知中可见的详细级别。 调用 setVisibility()并指定以下值之一： VISIBILITY_PUBLIC 显示通知的完整内容。VISIBILITY_SECRET 不会在锁定屏幕上显示此通知的任何部分。VISIBILITY_PRIVATE 显示通知图标和内容标题等基本信息，但是隐藏通知的完整内容。 设置 VISIBILITY_PRIVATE 后，您还可以提供其中隐藏了某些详细信息的替换版本通知内容。 在锁定屏幕上控制媒体播放自定义通知布局可以利用通知框架定义自定义通知布局，由该布局定义通知在 RemoteViews 对象中的外观。 自定义通知布局的可用高度取决于通知视图。普通视图布局限制为 64 dp，扩展视图布局限制为 256 dp。 要定义自定义通知布局，请首先实例化 RemoteViews 对象来扩充 XML 布局文件。然后，调用 setContent()，而不是调用 setContentTitle() 等方法。 要在自定义通知中设置内容详细信息，请使用 RemoteViews 中的方法设置视图子项的值： 在单独的文件中为通知创建 XML 布局。 在您的应用中，使用 RemoteViews 方法定义通知的图标和文本。 通过调用 setContent() 将此 RemoteViews 对象放入 Notification.Builder 中 ### 标准布局 12345678910111213141516171819202122232425262728 private int getBaseLayoutResource() &#123; return R.layout.notification_template_material_base; &#125;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/status_bar_latest_event_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;64dp&quot; android:tag=&quot;base&quot; &gt; &lt;include layout=&quot;@layout/notification_template_icon_group&quot; android:layout_width=&quot;@dimen/notification_large_icon_width&quot; android:layout_height=&quot;@dimen/notification_large_icon_height&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/notification_main_column&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;top&quot; android:layout_marginStart=&quot;@dimen/notification_large_icon_width&quot; android:minHeight=&quot;@dimen/notification_large_icon_height&quot; android:orientation=&quot;vertical&quot; &gt; &lt;include layout=&quot;@layout/notification_template_part_line1&quot; /&gt; &lt;include layout=&quot;@layout/notification_template_part_line2&quot; /&gt; &lt;include layout=&quot;@layout/notification_template_part_line3&quot; /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; pengdingIntent pendingIntent 主要的区别在于Intent的执行立刻的，而pendingIntent的执行不是立刻的.使用pendingIntent的目的在于它所包含的Intent的操作的执行是需要满足某些条件的。 主要的使用的地方和例子：通知Notificatio的发送，短消息SmsManager的发送和警报器AlarmManager的执行等等。 获取方法1234567891011PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, mIntent, 0);* 第四个参数可以设置不同的flag,0表示没有flag FLAG_ONE_SHOT 表示返回的PendingIntent仅能执行一次，执行完后自动取消FLAG_NO_CREATE 表示如果描述的PendingIntent不存在，并不创建相应的PendingIntent，而是返回NULLFLAG_CANCEL_CURRENT 表示相应的PendingIntent已经存在，则取消前者，然后创建新的PendingIntent，这个有利于数据保持为最新的，可以用于即时通信的通信场景FLAG_UPDATE_CURRENT 表示更新的PendingIntent Intent和PendingIntent的区别 a. Intent是立即使用的，而PendingIntent可以等到事件发生后触发，PendingIntent可以cancelb. Intent在程序结束后即终止，而PendingIntent在程序结束后依然有效c. PendingIntent自带Context，而Intent需要在某个Context内运行d. Intent在原task中运行，PendingIntent在新的task中运行 通过getActivity(Context context, int requestCode, Intent intent, int flags)系列方法从系统取得一个用于启动一个Activity的PendingIntent对象,通过getService(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于启动一个Service的PendingIntent对象通过getBroadcast(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于向BroadcastReceiver的Intent广播的PendingIntent对象 contentIntent：在通知窗口区域，Notification被单击时的响应事件由该intent触发； deleteIntent：当用户点击全部清除按钮时，响应该清除事件的Intent； fullScreenIntent：响应紧急状态的全屏事件（例如来电事件），也就是说通知来的时候，跳过在通知区域点击通知这一步，直接执行fullScreenIntent代表的事件 NotificationManagerService详解设计规范 http://developer.android.com/intl/zh-cn/design/patterns/notifications.html 参考资料 http://developer.android.com/intl/zh-cn/guide/topics/ui/notifiers/notifications.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Notifications</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Monkey详解]]></title>
    <url>%2F2016%2F07%2F18%2FMonkey%2F</url>
    <content type="text"><![CDATA[Monkey命令行可用的全部选项常规 –help 列出简单的用法。 -v 命令行的每一个-v将增加反馈信息的级别。 Level 0(缺省值)除启动提示、测试完成和最终结果之外，提供较少信息。 Level 1提供较为详细的测试信息，如逐个发送到Activity的事件。 Level 2提供更加详细的设置信息，如测试中被选中的或未被选中的Activity。 日志级别 Level 0 *示例 adbshell monkey -p com.htc.Weather –v 100 说明缺省值，仅提供启动提示、测试完成和最终结果等少量信息 日志级别 Level 1 *示例 adbshell monkey -p com.htc.Weather –v -v 100 说明 提供较为详细的日志，包括每个发送到Activity的事件信息 日志级别 Level 2 *示例 adbshell monkey -p com.htc.Weather –v -v –v 100 说明 最详细的日志，包括了测试中选中/未选中的Activity信息 事件 -s 用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。 示例： Monkey测试1：adb shellmonkey -p com.htc.Weather –s 10 100 Monkey 测试2：adb shellmonkey -p com.htc.Weather –s 10 100 两次测试的效果是相同的，因为模拟的用户操作序列（每次操作按照一定的先后顺序所组成的一系列操作，即一个序列）是一样的。操作序列虽 然是随机生成的，但是只要我们指定了相同的Seed值，就可以保证两次测试产生的随机操作序列是完全相同的，所以这个操作序列伪随机的； –throttle 在事件之间插入固定延迟。通过这个选项可以减缓Monkey的执行速度。如果不指定该选项，Monkey将不会被延迟，事件将尽可能快地被产成。 示例：adb shellmonkey -p com.htc.Weather –throttle 3000 100 –pct-touch 调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)。 示例：adb shellmonkey -p com.htc.Weather –pct-touch 10 1000 –pct-motion调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)。 示例：adb shellmonkey -p com.htc.Weather –pct-motion 20 1000 –pct-trackball 调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)。 示例：adb shellmonkey -p com.htc.Weather –pct-trackball 30 1000 –pct-nav 调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)。 示例：adb shellmonkey -p com.htc.Weather –pct-nav 40 1000 –pct-majornav 调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键) 示例：adb shellmonkey -p com.htc.Weather –pct-majornav 50 1000 –pct-syskeys调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)。 示例：adb shellmonkey -p com.htc.Weather –pct-syskeys 60 1000 –pct-appswitch调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。 示例：adb shellmonkey -p com.htc.Weather –pct-appswitch 70 1000 –pct-anyevent调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。* 示例：adb shell monkey -p com.htc.Weather –pct -anyevent 1001000* 指定多个类型事件的百分比： adb shell monkey -pcom.htc.Weather –pct-anyevent 50 –pct-appswitch 50 1000注意：各事件类型的百分比总数不能超过100%； 约束限制 -p 如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。如果你的应用程序还需要访问其它包里的Activity(如选择取一个联系人)，那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。要指定多个包，需要使用多个 -p选项，每个-p选项只能用于一个包。 指定一个包： adb shell monkey -p com.htc.Weather 100 说明：com.htc.Weather为包名，100是事件计数（即让Monkey程序模拟100次随机用户事件）。 指定多个包：adb shell monkey -p com.htc.Weather –pcom.htc.pdfreader -p com.htc.photo.widgets 100 不指定包：adb shell monkey 100 说明：Monkey随机启动APP并发送100个随机事件。 要查看设备中所有的包，在CMD窗口中执行以下命令： adb shell #cd data/data #ls -c 如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任何类别，Monkey将选 择下列类别中列出的Activity： Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。要指定多个类别，需要使用多个-c选项，每个-c选 项只能用于一个类别。 调试–dbg-no-events设置此选项，Monkey将执行初始启动，进入到一个测试Activity，然后不会再进一步生成事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换。 –hprof设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要小心使用它。 –ignore-crashes通常，当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 示例1：adb shellmonkey -p com.htc.Weather –ignore-crashes 1000测试过程中即使Weather程序崩溃，Monkey依然会继续发送事件直到事件数目达到1000为止； 示例2：adb shell monkey -p com.htc.Weather 1000测试过程中，如果Weather程序崩溃，Monkey将会停止运行。 –ignore-timeouts通常，当应用程序发生任何超时错误(如“Application Not Responding”对话框)时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions通常，当应用程序发生许可错误(如启动一个需要某些许可的Activity)时，Monkey将停止运行。如果设置了此选项，Monkey将继续向系统发送事件，直到计数完成。 –kill-process-after-error通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发生错误的进程。注意，正常的(成功的)结束，并没有停止启动的进程，设备只是在结束事件之后，简单地保持在最后的状态。 –monitor-native-crashes监视并报告Android系统中本地代码的崩溃事件。如果设置了–kill-process-after-error，系统将停止运行。 –wait-dbg停止执行中的Monkey，直到有调试器和它相连接。 参考文档 http://www.cnblogs.com/xiwix/archive/2012/04/15/2450976.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Monkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android LruCache 源码解析]]></title>
    <url>%2F2016%2F06%2F18%2FLruCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 简介 Lru 是 Least Recently Used 最近最少使用算法。 曾经，在各大缓存图片的框架没流行的时候。有一种很常用的内存缓存技术：SoftReference 和 WeakReference（软引用和弱引用）。但是走到了 Android 2.3（Level 9）时代，垃圾回收机制更倾向于回收 SoftReference 或 WeakReference 的对象。后来，又来到了 Android3.0，图片缓存在内容中，因为不知道要在是什么时候释放内存，没有策略，没用一种可以预见的场合去将其释放。这就造成了内存溢出。 2. 使用方法当成一个 Map 用就可以了，只不过实现了 Lru 缓存策略 使用的时候记住几点即可： 1.（必填）你需要提供一个缓存容量作为构造参数 2.（个人认为必填） 覆写 sizeOf 方法 ，自定义设计一条数据放进来的容量计算。 2.（选填） 覆写 entryRemoved 方法 ，你可以知道最少使用的缓存被清除时的数据（ evicted, key, oldValue, newVaule ） 3.（记住）LruCache是线程安全的，在内部的 get、put、remove 包括 trimToSize 都是安全的（因为都上锁了）。 4.（选填） 还有就是覆写 create 方法 一般做到 1、2、3就足够了，4可以无视 。 以下是 一个 LruCache 实现 Bitmap 小缓存的案例, entryRemoved 里的自定义逻辑可以无视，这里是我的展示 demo 里的自定义 entryRemoved 逻辑(｡&gt;﹏&lt;｡)1234567891011121314151617181920212223242526272829303132333435363738394041private static final float ONE_MIB = 1024 * 1024;// 7MBprivate static final int CACHE_SIZE = (int) (7 * ONE_MIB);private LruCache&lt;String, Bitmap&gt; bitmapCache;this.bitmapCache = new LruCache&lt;String, Bitmap&gt;(CACHE_SIZE) &#123; protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount(); &#125; /** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 导致 * 4.newValue!=null，那么则被put()或get()调用。 */ @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; mEntryRemovedInfoText.setText( String.format(Locale.getDefault(), LRU_CACHE_ENTRY_REMOVED_INFO_FORMAT, evicted, key, oldValue != null ? oldValue.hashCode() : "null", newValue != null ? newValue.hashCode() : "null")); // 见上述 3. if (evicted) &#123; // 进行了trimToSize or remove (一般是溢出了 或 key-value被删除了 ) if (recentList.contains(key)) &#123; recentList.remove(key); refreshText(mRecentInfoText, LRU_CACHE_RECENT_FORMAT, recentList); &#125; &#125; else &#123; // put冲突后 或 get里成功create 后 recentList.remove(key); refreshText(mRecentInfoText, LRU_CACHE_RECENT_FORMAT, recentList); &#125; if (cacheList.contains(key)) &#123; cacheList.remove(key); refreshText(mCacheDataText, LRU_CACHE_CACHE_DATA_FORMAT, cacheList); &#125; &#125;&#125;; 3. 效果展示3.1 效果一（验证 Lru，最近没访问的，在溢出时优先被清理） 前提： 设置 LruCache 最大容量为 7MB，把图1、2、3放入了，此时占用容量为：1.87+0.38+2.47=4.47MB。 执行操作： 1.然后点 get 图3一共16次（证明访问次数和Lru没关系，只有访问顺序有关系）。Recent visit显示了图3 2.先 get 图2，再 get 图1，制造最近访问顺序为： 3. put 图4，预算容量需要4.47+2.47=7.19MB。会溢出。 4.溢出了，删除最近没访问的图3。 5.观察 entryRemoved 数据 图三被移除了（对照hashcode） 3.2 效果二（验证 entryRemoved 的 evicted=false，可以验证冲突） 前提：执行了效果一，put 了图4，删除了最近没访问的图3。 执行操作：再一次 put 图4，发生冲突，拿到 key、冲突 value 以及 put 的 value，这里我放到是同一个 hashcode 的 bitmap，所以 hashcode 一样，但是无关紧要吧。 4. 源码分析LruCache 就是 利用 LinkedHashMap 的一个特性再加上对 LinkedHashMap 的数据操作上锁实现的缓存策略。 4.1 LruCache 的唯一构造方法1234567891011121314151617/** * LruCache的构造方法：需要传入最大缓存个数 */public LruCache(int maxSize) &#123; // 最大缓存个数小于0，会抛出IllegalArgumentException if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; /* * 初始化LinkedHashMap * 第一个参数：initialCapacity，初始大小 * 第二个参数：loadFactor，负载因子=0.75f * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 */ this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 第一个参数 initialCapacity 用于初始化该 LinkedHashMap 的大小。 先简单介绍一下 第二个参数 loadFactor，这个其实的 HashMap 里的构造参数，涉及到扩容问题，比如 HashMap 的最大容量是100，那么这里设置0.75f的话，到75容量的时候就会扩容。 主要是第三个参数 accessOrder=true ，这样的话 LinkedHashMap 数据排序就会基于数据的访问顺序，从而实现了 LruCache 核心工作原理。 4.2 LruCache.get(K key)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 根据 key 查询缓存，如果存在于缓存或者被 create 方法创建了。 * 如果值返回了，那么它将被移动到队列的头部。 * 如果如果没有缓存的值，则返回 null。 */public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序 mapValue = map.get(key); // 计算 命中次数 if (mapValue != null) &#123; hitCount++; return mapValue; &#125; // 计算 丢失次数 missCount++; &#125; /* * 官方解释： * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时 * 候，一个冲突的值被添加到Map，我们在Map中删除这个值，释放被创造的值。 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; /*************************** * 不覆写create方法走不到下面 * ***************************/ /* * 正常情况走不到这里 * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑 * 因为默认的 create(K key) 逻辑为null */ synchronized (this) &#123; // 记录 create 的次数 createCount++; // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值 mapValue = map.put(key, createdValue); // 如果之前存在相同key的value，即有冲突。 if (mapValue != null) &#123; /* * 有冲突 * 所以 撤销 刚才的 操作 * 将 之前相同key 的值 重新放回去 */ map.put(key, mapValue); &#125; else &#123; // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, createdValue); &#125; &#125; // 如果上面 判断出了 将要放入的值发生冲突 if (mapValue != null) &#123; /* * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了 * 告诉 自定义 的 entryRemoved 方法 */ entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; // 上面 进行了 size += 操作 所以这里要重整长度 trimToSize(maxSize); return createdValue; &#125;&#125; 上述的 get 方法表面并没有看出哪里有实现了Lru的缓存策略。主要在 mapValue = map.get(key);里，调用了 LinkedHashMap 的 get 方法，再加上 LruCache 构造里默认设置 LinkedHashMap 的 accessOrder=true。 4.3 LinkedHashMap.get(Object key)1234567891011121314151617181920212223242526272829303132333435/** * Returns the value of the mapping with the specified key. * * @param key * the key. * @return the value of the mapping with the specified key, or &#123;@code null&#125; * if no mapping for the specified key is found. */@Override public V get(Object key) &#123; /* * This method is overridden to eliminate the need for a polymorphic * invocation in superclass at the expense of code duplication. */ if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; if (e == null) return null; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; &#125; return null;&#125; 其实仔细看 if (accessOrder) 的逻辑即可，如果 accessOrder=true 那么每次 get 都会执行 N 次 makeTail(LinkedEntry&lt;K, V&gt; e) 。 接下来看看 4.4 LinkedHashMap.makeTail(LinkedEntry e)123456789101112131415161718/** * Relinks the given entry to the tail of the list. Under access ordering, * this method is invoked whenever the value of a pre-existing entry is * read by Map.get or modified by Map.put. */private void makeTail(LinkedEntry&lt;K, V&gt; e) &#123; // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;&#125; // Unlink e // Relink e as tail LinkedHashMap是双向循环链表，然后此次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 以上就是 LruCache 核心工作原理(｡&gt;﹏&lt;｡) 接下来介绍 LruCache 的容量溢出策略 上述展示场景中，7M的容量，我添加三张图后，不会溢出，put后必然会超过7MB。 4.5 LruCache.put(K key, V value)123456789101112public final V put(K key, V value) &#123; ... synchronized (this) &#123; ... // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, value); ... &#125; ... trimToSize(maxSize); return previous;&#125; 记住几点： 1.put 开始的时候确实是把值放入 LinkedHashMap 了，不管超不超过你设定的缓存容量。 2.然后根据 safeSizeOf 方法计算 此次添加数据的容量是多少，并且加到 size 里 。 3.说到 safeSizeOf 就要讲到 sizeOf(K key, V value) 会计算出此次添加数据的大小 （像上面的 Demo，我的容量是7MB，我每次添加进来的 Bitmap 要是不覆写 sizeOf 方法的话，会视为该 bitmap 的容量计算为默认的容量计算 return 1。如此一来，这样的话 7MB 的 LruCache 容量可以放7x1024x1024张图片？明显这样的逻辑是不对的！） 4.直到 put 要结束时，进行了 trimToSize 才判断 size 是否 大于 maxSize 然后进行最近很少访问数据的移除 4.6 LruCache.trimToSize(int maxSize)1234567891011121314151617181920212223242526272829303132333435public void trimToSize(int maxSize) &#123; /* * 这是一个死循环， * 1.只有 扩容 的情况下能立即跳出 * 2.非扩容的情况下，map的数据会一个一个删除，直到map里没有值了，就会跳出 */ while (true) &#123; K key; V value; synchronized (this) &#123; // 在重新调整容量大小前，本身容量就为空的话，会出异常的。 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException( getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; // 如果是 扩容 或者 map为空了，就会中断，因为扩容不会涉及到丢弃数据的情况 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); // 拿到键值对，计算出在容量中的相对长度，然后减去。 size -= safeSizeOf(key, value); // 添加一次收回次数 evictionCount++; &#125; /* * 将最后一次删除的最少访问数据回调出去 */ entryRemoved(true, key, value, null); &#125;&#125; 简单描述：会判断之前 size 是否大于 maxSize 。是的话，直接跳出后什么也不做。不是的话，证明已经溢出容量了。由 makeTail 图已知，最近经常访问的数据在最末尾。拿到一个存放 key 的 Set，然后一直一直从头开始删除，删一个判断是否溢出，直到没有溢出。 最后看看 4.7 覆写 entryRemoved 的作用entryRemoved被LruCache调用的场景： 1.（put） put 发生 key 冲突时被调用，evicted=false，key=此次 put 的 key，oldValue=被覆盖的冲突 value，newValue=此次 put 的 value 2.（trimToSize） trimToSize 的时候，只会被调用一次，就是最后一次被删除的最少访问数据带回来。evicted=true，key=最后一次被删除的 key，oldValue=最后一次被删除的 value，newValue=null（此次没有冲突，只是 remove） 3.（remove） remove的时候，存在对应 key，并且被成功删除后被调用。evicted=false，key=此次 put的 key，oldValue=此次删除的 value，newValue=null（此次没有冲突，只是 remove） 4.（get后半段，查询丢失后处理情景，不过建议忽略） get 的时候，正常的话不实现自定义 create 的话，代码上看 get 方法只会走一半，如果你实现了自定义的 create(K key) 方法，并且在 你 create 后的值放入 LruCache 中发生 key 冲突时被调用，evicted=false，key=此次 get 的 key，oldValue=被你自定义 create(key)后的 value，newValue=原本存在 map 里的 key-value。 解释一下第四点吧：.第四点是这样的，先 get(key)，然后没拿到，丢失。.如果你提供了 自定义的 create(key) 方法，那么 LruCache 会根据你的逻辑自造一个 value，但是当放入的时候发现冲突了，但是已经放入了。.此时，会将那个冲突的值再让回去覆盖，此时调用上述4.的 entryRemoved。 因为 HashMap 在数据量大情况下，拿数据可能造成丢失，导致前半段查不到，你自定义的 create(key) 放入的时候发现又查到了（有冲突）。然后又急忙把原来的值放回去，此时你就白白create一趟，无所作为，还要走一遍entryRemoved。 综上就如同注释写的一样：12345678910/** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 * 导致 * 4.newValue!=null，那么则被put()或get()调用。 */protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; 可以参考我的 demo 里的 entryRemoved (｡&gt;﹏&lt;｡) 5. 开源项目中的使用square/picasso 6. 总结LruCache重要的几点： 1.LruCache 是通过 LinkedHashMap 构造方法的第三个参数的 accessOrder=true 实现了 Lru 算法缓存机制。 2.LruCache 在内部的get、put、remove包括 trimToSize 都是安全的（因为都上锁了）。 3.覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突。 4.maxSize 和 sizeOf(K key, V value) 方法的覆写息息相关，必须相同单位。（ 比如 maxSize 是7MB，自定义的 sizeOf 计算每个数据大小的时候必须能算出与MB之间有联系的单位 ） 5.LruCache 自身并没有释放内存，将 LinkedHashMap 的数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存。 7. 资源LruCacheActivity LruCache注释源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>LruCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android logcat详解]]></title>
    <url>%2F2016%2F05%2F18%2Flogcat%2F</url>
    <content type="text"><![CDATA[[TOC] logcat123456789101112131415161718192021222324252627282930313233343536371.logcat -c 清除已有log信息2.logcat -b main 显示主缓冲区的log logcat -b radio 显示无线缓冲区的log logcat -b events 显示事件缓冲区的log3.logcat -f [filename] 将log保存到指定的文件中，例如 logcat -b radio -f /data/radio.log4.logcat -v 设置logcat输出的格式 主要有7种: 1&gt; brief — Display priority/tag and PID of originating process (the default format). 2&gt; process — Display PID only. 3&gt; tag — Display the priority/tag only. 4&gt; thread — Display process:thread and priority/tag only. 5&gt; raw — Display the raw log message, with no other metadata fields. 6&gt; time — Display the date, invocation time, priority/tag, and PID of the originating process. 7&gt; long — Display all metadata fields and separate messages with a blank lines. 比较常用的是显示时间:logcat -v time &amp; 5.logcat -g 查看缓冲区的大小 * logcat -g main * logcat -g radio * logcat -g events]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>logcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Application详解]]></title>
    <url>%2F2016%2F05%2F08%2FApplication%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述先看看官方是怎么描述的 Base class for maintaining global application state.You can provide your own implementation by creating a subclass and specifying the fully-qualified name of this subclassas the “android:name” attribute in your AndroidManifest.xml’s tag.The Application class, or your subclass of the Application class, is instantiated before any other class when the processfor your application/package is created. Note: There is normally no need to subclass Application.In most situations, static singletons can provide the same functionality in a more modular way.If your singleton needs a global context (for example to register broadcast receivers),include Context.getApplicationContext() as a Context argument when invoking your singleton’s getInstance() method. Application和Activity,Service一样,是android框架的一个系统组件。当android程序启动时系统会创建一个 application对象，用来存储系统的一些信息。通常我们是不需要指定一个Application的，这时系统会自动帮我们创建。如果需要创建自己 的Application，需要创建一个类继承 Application并在manifest的application标签中进行注册。 android系统会为每个程序运行时创建一个Application类的对象且仅创建一个，所以Application可以说是单例 (singleton)模式的一个类.且application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局的单例的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以通过Application来进行一些，数据传递，数据共享 等,数据缓存等操作。 我们可以通过下面的方式在Manifest文件中来定义一个Application，下面是Android源码中Phone应用的Application定义： 123456789&lt;application android:name=&quot;PhoneApp&quot; android:persistent=&quot;true&quot; android:label=&quot;@string/phoneAppLabel&quot; android:icon=&quot;@mipmap/ic_launcher_phone&quot; android:allowBackup=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:usesCleartextTraffic=&quot;true&quot; android:defaultToDeviceProtectedStorage=&quot;true&quot; android:directBootAware=&quot;true&quot;&gt; 其中比较特殊的是android:persistent=”true” 标示该应用为永久应用，persistent应用开机时会被AMS自动加载，异常出现时，自动重新启动相应的，在代码中定义一个继承Application的类PhoneApp： 1234567891011121314151617181920public class PhoneApp extends Application &#123; PhoneGlobals mPhoneGlobals; TelephonyGlobals mTelephonyGlobals; public PhoneApp() &#123; &#125; @Override public void onCreate() &#123; if (UserHandle.myUserId() == 0) &#123; // We are running as the primary user, so should bring up the // global phone state. mPhoneGlobals = new PhoneGlobals(this); mPhoneGlobals.onCreate(); mTelephonyGlobals = new TelephonyGlobals(this); mTelephonyGlobals.onCreate(); &#125; &#125;&#125; Application的作用 维护全局应用程序状态的基类,Android程序的入口点,作为应用程序的全局唯一单例。我们可以在里面定义全局属性和全局方法 通过Application传递数据假如有一个Activity A, 跳转到 Activity B ,并需要传递一些数据。通常的作法是Intent.putExtra() 让Intent携带，或者有一个Bundle把信息加入Bundle让Intent推荐Bundle对象，实现传递。但这样作有一个问题在于，Intent和Bundle所能携带的数据类型都是一些基本的数据类型，如果想实现复杂的数据传递就比较麻烦了，通常需要实现 Serializable或者Parcellable接口。这其实是Android的一种IPC数据传递的方法。如果我们的两个Activity在同一个进程当中为什么还要这么麻烦呢，只要把需要传递的对象的引用传递过去就可以了。 基本思路是这样的。在Application中创建一个HashMap ，以字符串为索引，Object为value这样我们的HashMap就可以存储任何类型的对象了。在Activity A中把需要传递的对象放入这个HashMap，然后通过Intent或者其它途经再把这索引的字符串传递给ActivityB ,Activity B 就可以根据这个字符串在HashMap中取出这个对象了。只要再向下转个型 ，就实现了对象的传递。 Application数据缓存 我一般会习惯在application中建立两个HashMap一个用于数据的传递，一个用于缓 存一些数据。比如有一个Activity需要从网站获取一些数据，获取完之后我们就可以把这个数据cache到Application 当中，当页面设置到其它Activity再回来的时候，就可以直接使用缓存好的数据了。但如果需要cache一些大量的数据，最好是cache一些 (软引用)SoftReference ，并把这些数据cache到本地rom上或者sd卡上。如果在application中的缓存不存在，从本地缓存查找，如果本地缓存的数据也不存在再从网络上获取。 生命周期12345void onConfigurationChanged(Configuration newConfig) // Called by the system when the device configuration changes while your component is running.void onCreate() // Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created.void onLowMemory() // This is called when the overall system is running low on memory, and actively running processes should trim their memory usage.void onTerminate() // This method is for use in emulated process environments.void onTrimMemory(int level) // Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. onCreate1234567891011void onCreate ()Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created. Implementations should be as quick as possible (for example using lazy initialization of state) since the time spent in this function directlyimpacts the performance of starting the first activity, service, or receiver in a process. If you override this method, be sure to call super.onCreate().If you override this method you must call through to the superclass implementation. 在创建应用程序的时候调用。可以使用方法去初始化一些全局属性。 onLowMemory123456789void onLowMemory ()This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing.You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method.Preferably, you should implement onTrimMemory(int) from ComponentCallbacks2 to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this onLowMemory() method as a fallback for older versions, which can be treated the same as onTrimMemory(int) with the TRIM_MEMORY_COMPLETE level.If you override this method you must call through to the superclass implementation. 这个方法一般只会在后台进程已经终止，前台应用程序仍然缺少内存时调用。可以在这个方法内清空缓存或者释放不必要的资源。 onTerminate12345void onTerminate ()This method is for use in emulated process environments. It will never be called on a production Android device, where processes are removed by simply killing them; no user code (including this callback) is executed when doing so.If you override this method you must call through to the superclass implementation. 在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程。 onTrimMemory123456789101112void onTrimMemory (int level)Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.This will happen for example when it goes in the background and there is not enough memory to keep as many background processesrunning as desired. You should never compare to exact values of the level, since new intermediate values may be added-- you will typically want to compare if the value is greater or equal to a level you are interested in.To retrieve the processes current trim level at any point, you can use ActivityManager.getMyMemoryState(RunningAppProcessInfo).If you override this method you must call through to the superclass implementation.Parameterslevel int: The context of the trim, giving a hint of the amount of trimming the application may like to perform. 程序在进行内存清理时执行 其中参数level的选项定义在ComponentCallbacks2中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is nearing the end * of the background LRU list, and if more memory isn&apos;t found soon it will * be killed. */ static final int TRIM_MEMORY_COMPLETE = 80; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is around the middle * of the background LRU list; freeing memory can help the system keep * other processes running later in the list for better overall performance. */ static final int TRIM_MEMORY_MODERATE = 60; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process has gone on to the * LRU list. This is a good opportunity to clean up resources that can * efficiently and quickly be re-built if the user returns to the app. */ static final int TRIM_MEMORY_BACKGROUND = 40; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process had been showing * a user interface, and is no longer doing so. Large allocations with * the UI should be released at this point to allow memory to be better * managed. */ static final int TRIM_MEMORY_UI_HIDDEN = 20; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running extremely low on memory * and is about to not be able to keep any background processes running. * Your running process should free up as many non-critical resources as it * can to allow that memory to be used elsewhere. The next thing that * will happen after this is &#123;@link #onLowMemory()&#125; called to report that * nothing at all can be kept in the background, a situation that can start * to notably impact the user. */ static final int TRIM_MEMORY_RUNNING_CRITICAL = 15; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running low on memory. * Your running process should free up unneeded resources to allow that * memory to be used elsewhere. */ static final int TRIM_MEMORY_RUNNING_LOW = 10; /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is not an expendable * background process, but the device is running moderately low on memory. * Your running process may want to release some unneeded resources for * use elsewhere. */ static final int TRIM_MEMORY_RUNNING_MODERATE = 5; TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理 TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。 TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。 TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。 TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存 TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存 TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存 不单单是Application具有这个回调。我们看Application的源码，可以发现其内部也调用Activity、Service的onLowMemory方法 123456789101112@CallSuperpublic void onTrimMemory(int level) &#123; Object[] callbacks = collectComponentCallbacks(); if (callbacks != null) &#123; for (int i=0; i&lt;callbacks.length; i++) &#123; Object c = callbacks[i]; if (c instanceof ComponentCallbacks2) &#123; ((ComponentCallbacks2)c).onTrimMemory(level); &#125; &#125; &#125;&#125; 其中@CallSuper说明所有重写onTrimMemory()方法的方法都要有super.onTrimMemory(); 可以实现OnTrimMemory回调的组件 12345Application.onTrimMemory()Activity.onTrimMemory()Fragement.OnTrimMemory()Service.onTrimMemory()ContentProvider.OnTrimMemory() OnTrimMemory和onStop的关系onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。需要注意的是，onTrimMemory的TRIM_MEMORY_UI_HIDDEN 等级是在onStop方法之前调用的． OnTrimMemory和OnLowMemory的关系？ 在引入OnTrimMemory之前都是使用OnLowMemory回调，需要知道的是，OnLowMemory大概和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同.如果你想兼容api&lt;14的机器，那么可以用OnLowMemory来实现，否则你可以忽略OnLowMemory，直接使用OnTrimMemory即可． 为什么要调用OnTrimMemory？ 尽管系统在内存不足的时候杀进程的顺序是按照LRU Cache中从低到高来的，但是它同时也会考虑杀掉那些占用内存较高的应用来让系统更快地获得更多的内存。所以如果你的应用占用内存较小，就可以增加不被杀掉的几率，从而快速地恢复（如果不被杀掉，启动的时候就是热启动，否则就是冷启动，其速度差在2~3倍）。所以说在几个不同的OnTrimMemory回调中释放自己的UI资源，可以有效地提高用户体验。 OnTrimMemory回调中可以释放哪些资源 有哪些典型的使用场景？ 常驻内存的应用一些常驻内存的应用，比如Launcher、安全中心、电话等，在用户使用过要退出的时候，需要调用OnTrimMemory来及时释放用户使用的时候所产生的多余的内存资源：比如动态生成的View、图片缓存、Fragment等。 有后台Service运行的应用 这些应用不是常驻内存的，意味着可以被任务管理器杀掉，但是在某些场景下用户不会去杀。这类应用包括：音乐、下载等。用户退出UI界面后，音乐还在继续播放，下载程序还在运行。这时候音乐应该释放部分UI资源和Cache。 一个比较实际的例子：用户打开登录页面，输入了用户名和密码，但是这时候按下了home键，几个小时后，系统内存不足将要啥事我们此时在后台存在的App进程，而我们想要用户再次打开这个app的登录页面时，能够保存用户已经输入的用户名和密码，这时候我们就可以回调登录Activity的onTrimMemory()方法，并保存输入的信息，待下次打开时重新回调显示。 onConfigurationChanged1234567891011void onConfigurationChanged (Configuration newConfig)Called by the system when the device configuration changes while your component is running. Note that, unlike activities, other components are never restarted when a configuration changes: they must always deal with the results of the change, such as by re-retrieving resources.At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.For more information, read Handling Runtime Changes.If you override this method you must call through to the superclass implementation.ParametersnewConfig Configuration: The new device configuration. 与activity不同，在配置改变时，应用程序对象不会被终止或重启。 如果应用程序使用的值依赖于特定的配置，则重写这个方法来重新加载这些值或者在应用程序级别处理配置改变。 注意事项 内存泄露 使用Application如果保存了一些不该保存的对象很容易导致内存泄漏。 如果在Application的oncreate中执行比较 耗时的操作，将直接影响的程序的启动时间。 不些清理工作不能依靠onTerminate完成，因为android会尽量让你的程序一直运行，所以很有可能 onTerminate不会被调用。 参考文档 官方API Android Application之onLowMemory与omTrimMemory Android代码内存优化建议-OnTrimMemory优化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的Parcel机制]]></title>
    <url>%2F2016%2F04%2F08%2FAndroid%E4%B8%AD%E7%9A%84Parcel%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述在Android系统中，定位为针对内存受限的设备，因此对性能要求更高，另外系统中采用了新的IPC（进程间通信）机制，必然要求使用性能更出色的对象传输方式。在这样的环境下， Parcel被设计出来，其定位就是轻量级的高效的对象序列化和反序列化机制。 Android中序列化有以下几个特征： 1. 整个读写全是在内存中进行，所以效率比JAVA序列化中使用外部存储器会高很多； 2. 读写时是4字节对齐的 3. 如果预分配的空间不够时，会一次多分配50%； 4. 对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。 Android序列化对象主要有两种方法，实现Serializable接口、或者实现Parcelable接口。实现Serializable接口是Java SE本身就支持的，而Parcelable是Android特有的功能，效率比实现Serializable接口高，而且还可以用在IPC中。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。下面就介绍一下实现Parcelable接口的方法 通过实现Parcelable接口序列化对象的步骤： 1、声明实现接口Parcelable 2、实现Parcelable的方法writeToParcel，将你的对象序列化为一个Parcel对象 3、实例化静态内部对象CREATOR实现接口Parcelable.Creator： 4、完成CREATOR的代码，实现方法createFromParcel，将Parcel对象反序列化为你的对象 简而言之：通过writeToParcel将你的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成你的对象。也可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面，在通过createFromParcel从流里读取对象，只不过这个过程需要你来实现，因此写的顺序和读的顺序必须一致。 实现了Bundle传递对象使用Bundle传递对象，首先要将其序列化，但是，在Android中要使用这种传递对象的方式需要用到Android Parcel机制，即，Android实现的轻量级的高效的对象序列化和反序列化机制。 JAVA中的Serialize机制，译成串行化、序列化……，其作用是能将数据对象存入字节流当中，在需要时重新生成对象。主要应用是利用外部存储设备保存对象状态，以及通过网络传输对象等 Parcel对象可以通过以下方法写入或读取byte, double, float, int, long, String这6种类型变量。123456writeByte(byte), readByte() writeDouble(double), readDouble() writeFloat(float), readFloat() writeInt(int), readInt() writeLong(long), readLong() writeString(String), readString() 也可以读取或写入他们的数组123456789101112 writeBooleanArray(boolean[]), readBooleanArray(boolean[]), createBooleanArray() writeByteArray(byte[]), writeByteArray(byte[], int, int), readByteArray(byte[]), createByteArray() writeCharArray(char[]), readCharArray(char[]), createCharArray() writeDoubleArray(double[]), readDoubleArray(double[]), createDoubleArray() writeFloatArray(float[]), readFloatArray(float[]), createFloatArray() writeIntArray(int[]), readIntArray(int[]), createIntArray() writeLongArray(long[]), readLongArray(long[]), createLongArray() writeStringArray(String[]), readStringArray(String[]), createStringArray() writeSparseBooleanArray(SparseBooleanArray), readSparseBooleanArray() ``` ## 更多操作可以参阅：http://developer.android.com/reference/android/os/Parcel.html package com.ipjmc.demo.parcelable; import java.util.Date; import android.os.Parcel; import android.os.Parcelable; public class ParcelableDate implements Parcelable { //声明实现接口Parcelable //这里定义了两个变量来说明读和写的顺序要一致 public long mId; public Date mDate; public ParcelableDate(long id, long time) { mId = id; mDate = new Date(time); } public ParcelableDate(Parcel source) { //先读取mId，再读取mDate mId = source.readLong(); mDate = new Date(source.readLong()); } @Override public int describeContents() { return 0; } //实现Parcelable的方法writeToParcel，将ParcelableDate序列化为一个Parcel对象 @Override public void writeToParcel(Parcel dest, int flags) { //先写入mId，再写入mDate dest.writeLong(mId); dest.writeLong(mDate.getTime()); } //实例化静态内部对象CREATOR实现接口Parcelable.Creator public static final Parcelable.Creator&lt;ParcelableDate&gt; CREATOR = new Creator&lt;ParcelableDate&gt;() { @Override public ParcelableDate[] newArray(int size) { return new ParcelableDate[size]; } //将Parcel对象反序列化为ParcelableDate @Override public ParcelableDate createFromParcel(Parcel source) { return new ParcelableDate(source); } }; } ```]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB使用详解]]></title>
    <url>%2F2016%2F03%2F08%2Fadb%2F</url>
    <content type="text"><![CDATA[说明Android Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components: A client, which runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as the ADT plugin and DDMS also create adb clients. A server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device. A daemon, which runs as a background process on each emulator or device instance. You can find the adb tool in /platform-tools/. When you start an adb client, the client first checks whether there is an adb server process already running. If there isn’t, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from adb clients—all adb clients use port 5037 to communicate with the adb server. The server then sets up connections to all running emulator/device instances. It locates emulator/device instances by scanning odd-numbered ports in the range 5555 to 5585, the range used by emulators/devices. Where the server finds an adb daemon, it sets up a connection to that port. Note that each emulator/device instance acquires a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for adb connections. For example: Emulator 1, console: 5554Emulator 1, adb: 5555Emulator 2, console: 5556Emulator 2, adb: 5557and so on… As shown, the emulator instance connected to adb on port 5555 is the same as the instance whose console listens on port 5554. Once the server has set up connections to all emulator instances, you can use adb commands to access those instances. Because the server manages connections to emulator/device instances and handles commands from multiple adb clients, you can control any emulator/device instance from any client (or from a script). 配置手机设置 -&gt; 版本 -&gt; 多次点击版本号（7次） -&gt; 退出进入开发者选项 -&gt; usb调试 语法adb [-d|-e|-s ] // use the -d, -e, or -s option to specify the target device to which the command should be directed. 常用命令 adb help adb devices adb root remount reboot adb shell 1234567adb shell input keyevent // 模拟键盘输入adb shell input touchscreen // 模拟滑动输入adb shell dumpsys //查看系统运行状态adb shell am start -n + 包名/包名+类名 // 启动一个activityadb shell screenrecord path // 录制屏幕 adb start-server/kill-server adb logcat adb push/pull adb install/unintall adb shell pm list packages // adb shell input keyevent x // 模拟屏幕点击事件 x为按键对应的数值 adb shell am start -n 进程/包名 adb shell inputusage: input … input text input keyevent input tap input swipe keyevent指的是Android对应的keycode，比如home键的keycode=3，back键的keycode=4. 具体请查阅 http://blog.csdn.net/huiguixian/article/details/8550170 然后使用的话比较简单，比如想模拟home按键： adb shell input keyevent 3 请查阅上述文章，根据具体keycode编辑即可。 关于tap的话，他模拟的是touch屏幕的事件，只需给出x、y坐标即可。 此x、y坐标对应的是真实的屏幕分辨率，所以要根据具体手机具体看，比如你想点击屏幕(x, y) = (250, 250)位置： adb shell input tap 250 250 关于swipe同tap是一样的，只是他是模拟滑动的事件，给出起点和终点的坐标即可。例如从屏幕(250, 250), 到屏幕(300, 300)即 adb shell input swipe 250 250 300 300 来源 /system/core/toolbox frameworks/base/cmds]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova插件开发之Toast]]></title>
    <url>%2F2015%2F02%2F08%2FCordova%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8BToast%2F</url>
    <content type="text"><![CDATA[概述Toast是Android中用来显示显示信息的一种机制，和Dialog不一样的是，Toast是没有焦点的，而且Toast显示的时间有限，过一定的时间就会自动消失。Toast可以有五种实现方式，这里只实现最简单的一种。 结构插件的文件结构如下，与官方的插件相比，省略了一些与实现功能无关的部分123456|- plugin.xml |- www | +- ToastPlugin.js +- src |- android | | - ToastPlugin.java 代码 src/android/ToastPlugin.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.dhyuestc.cordova.toast;import org.apache.cordova.CordovaPlugin;import org.apache.cordova.CallbackContext;import org.apache.cordova.CordovaInterface;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import android.widget.Toast;/***@author:dhyuestc*@date:2015-1-30*/public class ToastPlugin extends CordovaPlugin &#123; public ToastPlugin() &#123; &#125; @Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException &#123; if (this.cordova.getActivity().isFinishing()) return true; // 如果当前Activity关闭，则不显示Toast if (action.equals("show")) &#123; this.show(args.getString(0)); &#125; else if (action.equals("showlong")) &#123; this.showlong(args.getString(0)); &#125; else &#123; return false; &#125; callbackContext.success(); return true; &#125; public void show(String message) &#123; Toast.makeText(this.cordova.getActivity(),message,Toast.LENGTH_SHORT).show(); // 显示2s &#125; public void showlong(String message) &#123; Toast.makeText(this.cordova.getActivity(),message,Toast.LENGTH_LONG).show(); // 显示3.5s &#125;&#125;``` - www/ToastPlugin.js```bash/***ToastPlugin.js*@author:dhyuestc*@date:2015-1-30*/var exec = require('cordova/exec');var Toast = function () &#123;&#125;;/*** show*/Toast.prototype.show = function (message) &#123; var LocalMessage = (message || "Toast"); // exec(null,null,"ToastPlugin","show",[LocalMessage]); // console.log("Toast Message:" + message); // &#125;/*** showlong*/Toast.prototype.showlong = function (message) &#123; var LocalMessage = (message || "ToastLong"); exec(null,null,"ToastPlugin","showlong",[LocalMessage]); console.log("Long Toast Message:" + message);&#125;var toast = new Toast(); module.exports = toast; // plugin.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;plugin xmlns="http://apache.org/cordova/ns/plugins/1.0" id="com.dhyuestc.cordova.toast" version="0.0.1"&gt; &lt;name&gt;Toast&lt;/name&gt; &lt;description&gt;Cordova Toast Plugin&lt;/description&gt; &lt;license&gt;Apache 2.0&lt;/license&gt; &lt;keywords&gt;cordova,toast&lt;/keywords&gt; &lt;js-module src="www/ToastPlugin.js" name="toast"&gt; &lt;!-- src指向的js文件的路径 name自定义，无影响 --&gt; &lt;clobbers target="Toast" /&gt; &lt;!-- clobbers 代表我们在客户端调用的时候的实例名 --&gt; &lt;/js-module&gt; &lt;platform name="android"&gt; &lt;source-file src="src/android/ToastPlugin.java" target-dir="src/com/dhyuestc/cordova/toast" /&gt; &lt;!-- src 代表 Java 源文件的地址， target-dir 代表你要拷贝到项目中的地址 --&gt; &lt;config-file target="res/xml/config.xml" parent="/*"&gt; &lt;feature name="ToastPlugin"&gt; &lt;param name="android-package" value="com.dhyuestc.cordova.toast.ToastPlugin"/&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file target="AndroidManifest.xml" parent="/*"&gt; &lt;/config-file&gt; &lt;/platform&gt; &lt;/plugin&gt; 使用方法12$ Toast.show("显示2s");$ Toast.showlong("显示3.5s"); 注意问题参考文献Cordova：Toast浮动提示插件Plugin Development Guide 联系我如果你阅读完这篇文章，发现有任何问题或者建议，请及时反馈给我，多谢。]]></content>
      <categories>
        <category>Cordova</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ssh 配置出错，运行ssh -T git@github.com时 Permission denied(publickey)]]></title>
    <url>%2F2015%2F01%2F13%2Fgit%E9%85%8D%E7%BD%AESSH%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题概述 git 配置ssh Keys时，根据官方的步骤Generating SSH keys，生成的key配置后总是无效。 找错记录首先查看了官方的错误的解决提示:Error: Permission denied (publickey)运行下面的命令，运行结果如下图： 12345678 ssh -vT git@github.com ``` &lt;img src=&quot;/img/git_ssh_vt.jpg&quot; alt=&quot;&quot;&gt; 通过上面的信息，我们发现这里请求的是identity file /.ssh/id_rsa 但是，我之前保存的Key名称并不是id_rsa!到这里，大概就找到了解决办法。 ## 解决办法将我们生成的SSH文件改名为id_rsa。再次运行 &quot;ssh -T git@github.com&quot; 成功输出官方配置步骤上的结果 Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. ``` 联系我上面是我在配置git SSH时遇到的问题及解决问题的过程记录，希望对看到这篇文章的你有帮助，如果你发现这篇文章中有什么问题，或者你有其他的见解，请留言告知，多谢。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门之安装配置]]></title>
    <url>%2F2015%2F01%2F11%2Fnodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[官网地址node.js官方网址node.js官方下载地址 安装流程环境：Window 在官网下载到适合系统的最新的软件后，点击安装。windows的安装msi文件在过程中会直接添加path的系统变量。 安装过程比较简单，选择自己的安装路径（例如“D:\Program Files\nodejs”。）后一直NEXT就可以了。 安装完成后可以使用cmd测试下是否安装成功。方法：在cmd下输入 1node -v 出现下类似下图版本提示即为成功安装。 npm(the package manager for javascript.)的安装。新版的NodeJS已经集成了npm，可以使用cmd命令行输入 1npm -v 来测试是否成功安装,出现版本提示便OK了。 虽然npm已经安装好，但是为了更好的使用npm和node.js,有必要配置一番。 我们要先配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立”node_global”及”node_cache”两个文件夹。如下图： 启动cmd，分别输入下面两条命令（安装路径要改成你自己的），注意顺序，注意文件名和第一步新建的一致。 npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot; ``npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; `` 关闭cmd，修改环境变量，在系统变量*下新建”NODE_PATH”，内容为：D:\ProgramFiles\nodejs\node_global\node_modules 路径要确保是你自己的安装路径。同时，由于改变了module的默认地址，所以上面的用户变量（不是系统path）都要跟着改变一下（用户变量”PATH”修改为“D:\Program Files\nodejs\node_global\”）。 *以后使用npm安装常用的模块时加速参数 -g 这样这下模块就可以在全局使用了！ 现在，一个基本的NodeJS的环境搭建已经完成了，接下来就是我们喜闻乐见的hello，world信息的输出了。你可以在”cmd“输入”node“进入node开发模式下，输入你的NodeJS第一条命令语句：console.log(‘hello world’)。怎么样？看到熟悉的hello，world了没？ 常见模块的安装 express(Fast, unopinionated, minimalist web framework for Node.js):最常用的node.js web开发框架 1npm install express -g nodemon(nodemon reload, automatically.): 使用nodemon 运行node.js程序时，当变更内容时，会自动重启运行程序。也可以使用 1npm install -g nodemon 常见问题 运行”node -v”时如果提示’node’不是内部或者外部命令，也不是可以运行的程序，或者批处理文件，尝试重新打开cmd,或者重启电脑，这样环境变量才能生效。 使用module的时候出现输入命令出现“xxx不是内部或外部命令，也不是可运行的程序或批处理文件”这个错误。参考第5步，确保正确配置npm的路径。 Contact me如果你在阅读本文中发现任何问题，请留言告知我，多谢。 参考文章NodeJS、NPM安装配置步骤(windows版本) - 逍遥仔的日志 - 网易博客]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
